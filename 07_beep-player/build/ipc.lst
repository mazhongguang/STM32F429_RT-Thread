ARM GAS  /tmp/ccOtHhPO.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"ipc.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.rt_sem_init,"ax",%progbits
  18              		.align	1
  19              		.global	rt_sem_init
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	rt_sem_init:
  26              	.LFB19:
  27              		.file 1 "rt-thread/src/ipc.c"
   1:rt-thread/src/ipc.c **** /*
   2:rt-thread/src/ipc.c ****  * Copyright (c) 2006-2018, RT-Thread Development Team
   3:rt-thread/src/ipc.c ****  *
   4:rt-thread/src/ipc.c ****  * SPDX-License-Identifier: Apache-2.0
   5:rt-thread/src/ipc.c ****  *
   6:rt-thread/src/ipc.c ****  * Change Logs:
   7:rt-thread/src/ipc.c ****  * Date           Author       Notes
   8:rt-thread/src/ipc.c ****  * 2006-03-14     Bernard      the first version
   9:rt-thread/src/ipc.c ****  * 2006-04-25     Bernard      implement semaphore
  10:rt-thread/src/ipc.c ****  * 2006-05-03     Bernard      add RT_IPC_DEBUG
  11:rt-thread/src/ipc.c ****  *                             modify the type of IPC waiting time to rt_int32_t
  12:rt-thread/src/ipc.c ****  * 2006-05-10     Bernard      fix the semaphore take bug and add IPC object
  13:rt-thread/src/ipc.c ****  * 2006-05-12     Bernard      implement mailbox and message queue
  14:rt-thread/src/ipc.c ****  * 2006-05-20     Bernard      implement mutex
  15:rt-thread/src/ipc.c ****  * 2006-05-23     Bernard      implement fast event
  16:rt-thread/src/ipc.c ****  * 2006-05-24     Bernard      implement event
  17:rt-thread/src/ipc.c ****  * 2006-06-03     Bernard      fix the thread timer init bug
  18:rt-thread/src/ipc.c ****  * 2006-06-05     Bernard      fix the mutex release bug
  19:rt-thread/src/ipc.c ****  * 2006-06-07     Bernard      fix the message queue send bug
  20:rt-thread/src/ipc.c ****  * 2006-08-04     Bernard      add hook support
  21:rt-thread/src/ipc.c ****  * 2009-05-21     Yi.qiu       fix the sem release bug
  22:rt-thread/src/ipc.c ****  * 2009-07-18     Bernard      fix the event clear bug
  23:rt-thread/src/ipc.c ****  * 2009-09-09     Bernard      remove fast event and fix ipc release bug
  24:rt-thread/src/ipc.c ****  * 2009-10-10     Bernard      change semaphore and mutex value to unsigned value
  25:rt-thread/src/ipc.c ****  * 2009-10-25     Bernard      change the mb/mq receive timeout to 0 if the
  26:rt-thread/src/ipc.c ****  *                             re-calculated delta tick is a negative number.
  27:rt-thread/src/ipc.c ****  * 2009-12-16     Bernard      fix the rt_ipc_object_suspend issue when IPC flag
  28:rt-thread/src/ipc.c ****  *                             is RT_IPC_FLAG_PRIO
  29:rt-thread/src/ipc.c ****  * 2010-01-20     mbbill       remove rt_ipc_object_decrease function.
  30:rt-thread/src/ipc.c ****  * 2010-04-20     Bernard      move memcpy outside interrupt disable in mq
  31:rt-thread/src/ipc.c ****  * 2010-10-26     yi.qiu       add module support in rt_mp_delete and rt_mq_delete
ARM GAS  /tmp/ccOtHhPO.s 			page 2


  32:rt-thread/src/ipc.c ****  * 2010-11-10     Bernard      add IPC reset command implementation.
  33:rt-thread/src/ipc.c ****  * 2011-12-18     Bernard      add more parameter checking in message queue
  34:rt-thread/src/ipc.c ****  * 2013-09-14     Grissiom     add an option check in rt_event_recv
  35:rt-thread/src/ipc.c ****  * 2018-10-02     Bernard      add 64bit support for mailbox
  36:rt-thread/src/ipc.c ****  * 2019-09-16     tyx          add send wait support for message queue
  37:rt-thread/src/ipc.c ****  */
  38:rt-thread/src/ipc.c **** 
  39:rt-thread/src/ipc.c **** #include <rtthread.h>
  40:rt-thread/src/ipc.c **** #include <rthw.h>
  41:rt-thread/src/ipc.c **** 
  42:rt-thread/src/ipc.c **** #ifdef RT_USING_HOOK
  43:rt-thread/src/ipc.c **** extern void (*rt_object_trytake_hook)(struct rt_object *object);
  44:rt-thread/src/ipc.c **** extern void (*rt_object_take_hook)(struct rt_object *object);
  45:rt-thread/src/ipc.c **** extern void (*rt_object_put_hook)(struct rt_object *object);
  46:rt-thread/src/ipc.c **** #endif
  47:rt-thread/src/ipc.c **** 
  48:rt-thread/src/ipc.c **** /**
  49:rt-thread/src/ipc.c ****  * @addtogroup IPC
  50:rt-thread/src/ipc.c ****  */
  51:rt-thread/src/ipc.c **** 
  52:rt-thread/src/ipc.c **** /**@{*/
  53:rt-thread/src/ipc.c **** 
  54:rt-thread/src/ipc.c **** /**
  55:rt-thread/src/ipc.c ****  * This function will initialize an IPC object
  56:rt-thread/src/ipc.c ****  *
  57:rt-thread/src/ipc.c ****  * @param ipc the IPC object
  58:rt-thread/src/ipc.c ****  *
  59:rt-thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
  60:rt-thread/src/ipc.c ****  */
  61:rt-thread/src/ipc.c **** rt_inline rt_err_t rt_ipc_object_init(struct rt_ipc_object *ipc)
  62:rt-thread/src/ipc.c **** {
  63:rt-thread/src/ipc.c ****     /* initialize ipc object */
  64:rt-thread/src/ipc.c ****     rt_list_init(&(ipc->suspend_thread));
  65:rt-thread/src/ipc.c **** 
  66:rt-thread/src/ipc.c ****     return RT_EOK;
  67:rt-thread/src/ipc.c **** }
  68:rt-thread/src/ipc.c **** 
  69:rt-thread/src/ipc.c **** /**
  70:rt-thread/src/ipc.c ****  * This function will suspend a thread to a specified list. IPC object or some
  71:rt-thread/src/ipc.c ****  * double-queue object (mailbox etc.) contains this kind of list.
  72:rt-thread/src/ipc.c ****  *
  73:rt-thread/src/ipc.c ****  * @param list the IPC suspended thread list
  74:rt-thread/src/ipc.c ****  * @param thread the thread object to be suspended
  75:rt-thread/src/ipc.c ****  * @param flag the IPC object flag,
  76:rt-thread/src/ipc.c ****  *        which shall be RT_IPC_FLAG_FIFO/RT_IPC_FLAG_PRIO.
  77:rt-thread/src/ipc.c ****  *
  78:rt-thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
  79:rt-thread/src/ipc.c ****  */
  80:rt-thread/src/ipc.c **** rt_inline rt_err_t rt_ipc_list_suspend(rt_list_t        *list,
  81:rt-thread/src/ipc.c ****                                        struct rt_thread *thread,
  82:rt-thread/src/ipc.c ****                                        rt_uint8_t        flag)
  83:rt-thread/src/ipc.c **** {
  84:rt-thread/src/ipc.c ****     /* suspend thread */
  85:rt-thread/src/ipc.c ****     rt_thread_suspend(thread);
  86:rt-thread/src/ipc.c **** 
  87:rt-thread/src/ipc.c ****     switch (flag)
  88:rt-thread/src/ipc.c ****     {
ARM GAS  /tmp/ccOtHhPO.s 			page 3


  89:rt-thread/src/ipc.c ****     case RT_IPC_FLAG_FIFO:
  90:rt-thread/src/ipc.c ****         rt_list_insert_before(list, &(thread->tlist));
  91:rt-thread/src/ipc.c ****         break;
  92:rt-thread/src/ipc.c **** 
  93:rt-thread/src/ipc.c ****     case RT_IPC_FLAG_PRIO:
  94:rt-thread/src/ipc.c ****         {
  95:rt-thread/src/ipc.c ****             struct rt_list_node *n;
  96:rt-thread/src/ipc.c ****             struct rt_thread *sthread;
  97:rt-thread/src/ipc.c **** 
  98:rt-thread/src/ipc.c ****             /* find a suitable position */
  99:rt-thread/src/ipc.c ****             for (n = list->next; n != list; n = n->next)
 100:rt-thread/src/ipc.c ****             {
 101:rt-thread/src/ipc.c ****                 sthread = rt_list_entry(n, struct rt_thread, tlist);
 102:rt-thread/src/ipc.c **** 
 103:rt-thread/src/ipc.c ****                 /* find out */
 104:rt-thread/src/ipc.c ****                 if (thread->current_priority < sthread->current_priority)
 105:rt-thread/src/ipc.c ****                 {
 106:rt-thread/src/ipc.c ****                     /* insert this thread before the sthread */
 107:rt-thread/src/ipc.c ****                     rt_list_insert_before(&(sthread->tlist), &(thread->tlist));
 108:rt-thread/src/ipc.c ****                     break;
 109:rt-thread/src/ipc.c ****                 }
 110:rt-thread/src/ipc.c ****             }
 111:rt-thread/src/ipc.c **** 
 112:rt-thread/src/ipc.c ****             /*
 113:rt-thread/src/ipc.c ****              * not found a suitable position,
 114:rt-thread/src/ipc.c ****              * append to the end of suspend_thread list
 115:rt-thread/src/ipc.c ****              */
 116:rt-thread/src/ipc.c ****             if (n == list)
 117:rt-thread/src/ipc.c ****                 rt_list_insert_before(list, &(thread->tlist));
 118:rt-thread/src/ipc.c ****         }
 119:rt-thread/src/ipc.c ****         break;
 120:rt-thread/src/ipc.c ****     }
 121:rt-thread/src/ipc.c **** 
 122:rt-thread/src/ipc.c ****     return RT_EOK;
 123:rt-thread/src/ipc.c **** }
 124:rt-thread/src/ipc.c **** 
 125:rt-thread/src/ipc.c **** /**
 126:rt-thread/src/ipc.c ****  * This function will resume the first thread in the list of a IPC object:
 127:rt-thread/src/ipc.c ****  * - remove the thread from suspend queue of IPC object
 128:rt-thread/src/ipc.c ****  * - put the thread into system ready queue
 129:rt-thread/src/ipc.c ****  *
 130:rt-thread/src/ipc.c ****  * @param list the thread list
 131:rt-thread/src/ipc.c ****  *
 132:rt-thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 133:rt-thread/src/ipc.c ****  */
 134:rt-thread/src/ipc.c **** rt_inline rt_err_t rt_ipc_list_resume(rt_list_t *list)
 135:rt-thread/src/ipc.c **** {
 136:rt-thread/src/ipc.c ****     struct rt_thread *thread;
 137:rt-thread/src/ipc.c **** 
 138:rt-thread/src/ipc.c ****     /* get thread entry */
 139:rt-thread/src/ipc.c ****     thread = rt_list_entry(list->next, struct rt_thread, tlist);
 140:rt-thread/src/ipc.c **** 
 141:rt-thread/src/ipc.c ****     RT_DEBUG_LOG(RT_DEBUG_IPC, ("resume thread:%s\n", thread->name));
 142:rt-thread/src/ipc.c **** 
 143:rt-thread/src/ipc.c ****     /* resume it */
 144:rt-thread/src/ipc.c ****     rt_thread_resume(thread);
 145:rt-thread/src/ipc.c **** 
ARM GAS  /tmp/ccOtHhPO.s 			page 4


 146:rt-thread/src/ipc.c ****     return RT_EOK;
 147:rt-thread/src/ipc.c **** }
 148:rt-thread/src/ipc.c **** 
 149:rt-thread/src/ipc.c **** /**
 150:rt-thread/src/ipc.c ****  * This function will resume all suspended threads in a list, including
 151:rt-thread/src/ipc.c ****  * suspend list of IPC object and private list of mailbox etc.
 152:rt-thread/src/ipc.c ****  *
 153:rt-thread/src/ipc.c ****  * @param list of the threads to resume
 154:rt-thread/src/ipc.c ****  *
 155:rt-thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 156:rt-thread/src/ipc.c ****  */
 157:rt-thread/src/ipc.c **** rt_inline rt_err_t rt_ipc_list_resume_all(rt_list_t *list)
 158:rt-thread/src/ipc.c **** {
 159:rt-thread/src/ipc.c ****     struct rt_thread *thread;
 160:rt-thread/src/ipc.c ****     register rt_ubase_t temp;
 161:rt-thread/src/ipc.c **** 
 162:rt-thread/src/ipc.c ****     /* wakeup all suspended threads */
 163:rt-thread/src/ipc.c ****     while (!rt_list_isempty(list))
 164:rt-thread/src/ipc.c ****     {
 165:rt-thread/src/ipc.c ****         /* disable interrupt */
 166:rt-thread/src/ipc.c ****         temp = rt_hw_interrupt_disable();
 167:rt-thread/src/ipc.c **** 
 168:rt-thread/src/ipc.c ****         /* get next suspended thread */
 169:rt-thread/src/ipc.c ****         thread = rt_list_entry(list->next, struct rt_thread, tlist);
 170:rt-thread/src/ipc.c ****         /* set error code to RT_ERROR */
 171:rt-thread/src/ipc.c ****         thread->error = -RT_ERROR;
 172:rt-thread/src/ipc.c **** 
 173:rt-thread/src/ipc.c ****         /*
 174:rt-thread/src/ipc.c ****          * resume thread
 175:rt-thread/src/ipc.c ****          * In rt_thread_resume function, it will remove current thread from
 176:rt-thread/src/ipc.c ****          * suspended list
 177:rt-thread/src/ipc.c ****          */
 178:rt-thread/src/ipc.c ****         rt_thread_resume(thread);
 179:rt-thread/src/ipc.c **** 
 180:rt-thread/src/ipc.c ****         /* enable interrupt */
 181:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
 182:rt-thread/src/ipc.c ****     }
 183:rt-thread/src/ipc.c **** 
 184:rt-thread/src/ipc.c ****     return RT_EOK;
 185:rt-thread/src/ipc.c **** }
 186:rt-thread/src/ipc.c **** 
 187:rt-thread/src/ipc.c **** #ifdef RT_USING_SEMAPHORE
 188:rt-thread/src/ipc.c **** /**
 189:rt-thread/src/ipc.c ****  * This function will initialize a semaphore and put it under control of
 190:rt-thread/src/ipc.c ****  * resource management.
 191:rt-thread/src/ipc.c ****  *
 192:rt-thread/src/ipc.c ****  * @param sem the semaphore object
 193:rt-thread/src/ipc.c ****  * @param name the name of semaphore
 194:rt-thread/src/ipc.c ****  * @param value the initial value of semaphore
 195:rt-thread/src/ipc.c ****  * @param flag the flag of semaphore
 196:rt-thread/src/ipc.c ****  *
 197:rt-thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 198:rt-thread/src/ipc.c ****  */
 199:rt-thread/src/ipc.c **** rt_err_t rt_sem_init(rt_sem_t    sem,
 200:rt-thread/src/ipc.c ****                      const char *name,
 201:rt-thread/src/ipc.c ****                      rt_uint32_t value,
 202:rt-thread/src/ipc.c ****                      rt_uint8_t  flag)
ARM GAS  /tmp/ccOtHhPO.s 			page 5


 203:rt-thread/src/ipc.c **** {
  28              		.loc 1 203 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              	.LVL0:
  33 0000 70B5     		push	{r4, r5, r6, lr}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 16
  36              		.cfi_offset 4, -16
  37              		.cfi_offset 5, -12
  38              		.cfi_offset 6, -8
  39              		.cfi_offset 14, -4
  40 0002 0446     		mov	r4, r0
  41 0004 1646     		mov	r6, r2
  42 0006 1D46     		mov	r5, r3
 204:rt-thread/src/ipc.c ****     RT_ASSERT(sem != RT_NULL);
 205:rt-thread/src/ipc.c ****     RT_ASSERT(value < 0x10000U);
 206:rt-thread/src/ipc.c **** 
 207:rt-thread/src/ipc.c ****     /* initialize object */
 208:rt-thread/src/ipc.c ****     rt_object_init(&(sem->parent.parent), RT_Object_Class_Semaphore, name);
  43              		.loc 1 208 0
  44 0008 0A46     		mov	r2, r1
  45              	.LVL1:
  46 000a 0221     		movs	r1, #2
  47              	.LVL2:
  48 000c FFF7FEFF 		bl	rt_object_init
  49              	.LVL3:
  50              	.LBB71:
  51              	.LBB72:
  64:rt-thread/src/ipc.c **** 
  52              		.loc 1 64 0
  53 0010 04F11403 		add	r3, r4, #20
  54              	.LVL4:
  55              	.LBB73:
  56              	.LBB74:
  57              		.file 2 "rt-thread/include/rtservice.h"
   1:rt-thread/include/rtservice.h **** /*
   2:rt-thread/include/rtservice.h ****  * Copyright (c) 2006-2018, RT-Thread Development Team
   3:rt-thread/include/rtservice.h ****  *
   4:rt-thread/include/rtservice.h ****  * SPDX-License-Identifier: Apache-2.0
   5:rt-thread/include/rtservice.h ****  *
   6:rt-thread/include/rtservice.h ****  * Change Logs:
   7:rt-thread/include/rtservice.h ****  * Date           Author       Notes
   8:rt-thread/include/rtservice.h ****  * 2006-03-16     Bernard      the first version
   9:rt-thread/include/rtservice.h ****  * 2006-09-07     Bernard      move the kservice APIs to rtthread.h
  10:rt-thread/include/rtservice.h ****  * 2007-06-27     Bernard      fix the rt_list_remove bug
  11:rt-thread/include/rtservice.h ****  * 2012-03-22     Bernard      rename kservice.h to rtservice.h
  12:rt-thread/include/rtservice.h ****  * 2017-11-15     JasonJia     Modify rt_slist_foreach to rt_slist_for_each_entry.
  13:rt-thread/include/rtservice.h ****  *                             Make code cleanup.
  14:rt-thread/include/rtservice.h ****  */
  15:rt-thread/include/rtservice.h **** 
  16:rt-thread/include/rtservice.h **** #ifndef __RT_SERVICE_H__
  17:rt-thread/include/rtservice.h **** #define __RT_SERVICE_H__
  18:rt-thread/include/rtservice.h **** 
  19:rt-thread/include/rtservice.h **** #ifdef __cplusplus
  20:rt-thread/include/rtservice.h **** extern "C" {
ARM GAS  /tmp/ccOtHhPO.s 			page 6


  21:rt-thread/include/rtservice.h **** #endif
  22:rt-thread/include/rtservice.h **** 
  23:rt-thread/include/rtservice.h **** /**
  24:rt-thread/include/rtservice.h ****  * @addtogroup KernelService
  25:rt-thread/include/rtservice.h ****  */
  26:rt-thread/include/rtservice.h **** 
  27:rt-thread/include/rtservice.h **** /**@{*/
  28:rt-thread/include/rtservice.h **** 
  29:rt-thread/include/rtservice.h **** /**
  30:rt-thread/include/rtservice.h ****  * rt_container_of - return the member address of ptr, if the type of ptr is the
  31:rt-thread/include/rtservice.h ****  * struct type.
  32:rt-thread/include/rtservice.h ****  */
  33:rt-thread/include/rtservice.h **** #define rt_container_of(ptr, type, member) \
  34:rt-thread/include/rtservice.h ****     ((type *)((char *)(ptr) - (unsigned long)(&((type *)0)->member)))
  35:rt-thread/include/rtservice.h **** 
  36:rt-thread/include/rtservice.h **** 
  37:rt-thread/include/rtservice.h **** /**
  38:rt-thread/include/rtservice.h ****  * @brief initialize a list object
  39:rt-thread/include/rtservice.h ****  */
  40:rt-thread/include/rtservice.h **** #define RT_LIST_OBJECT_INIT(object) { &(object), &(object) }
  41:rt-thread/include/rtservice.h **** 
  42:rt-thread/include/rtservice.h **** /**
  43:rt-thread/include/rtservice.h ****  * @brief initialize a list
  44:rt-thread/include/rtservice.h ****  *
  45:rt-thread/include/rtservice.h ****  * @param l list to be initialized
  46:rt-thread/include/rtservice.h ****  */
  47:rt-thread/include/rtservice.h **** rt_inline void rt_list_init(rt_list_t *l)
  48:rt-thread/include/rtservice.h **** {
  49:rt-thread/include/rtservice.h ****     l->next = l->prev = l;
  58              		.loc 2 49 0
  59 0014 A361     		str	r3, [r4, #24]
  60 0016 6361     		str	r3, [r4, #20]
  61              	.LVL5:
  62              	.LBE74:
  63              	.LBE73:
  64              	.LBE72:
  65              	.LBE71:
 209:rt-thread/src/ipc.c **** 
 210:rt-thread/src/ipc.c ****     /* initialize ipc object */
 211:rt-thread/src/ipc.c ****     rt_ipc_object_init(&(sem->parent));
 212:rt-thread/src/ipc.c **** 
 213:rt-thread/src/ipc.c ****     /* set initial value */
 214:rt-thread/src/ipc.c ****     sem->value = (rt_uint16_t)value;
  66              		.loc 1 214 0
  67 0018 A683     		strh	r6, [r4, #28]	@ movhi
 215:rt-thread/src/ipc.c **** 
 216:rt-thread/src/ipc.c ****     /* set parent */
 217:rt-thread/src/ipc.c ****     sem->parent.parent.flag = flag;
  68              		.loc 1 217 0
  69 001a 6572     		strb	r5, [r4, #9]
 218:rt-thread/src/ipc.c **** 
 219:rt-thread/src/ipc.c ****     return RT_EOK;
 220:rt-thread/src/ipc.c **** }
  70              		.loc 1 220 0
  71 001c 0020     		movs	r0, #0
  72 001e 70BD     		pop	{r4, r5, r6, pc}
  73              		.cfi_endproc
ARM GAS  /tmp/ccOtHhPO.s 			page 7


  74              	.LFE19:
  76              		.section	.text.rt_sem_detach,"ax",%progbits
  77              		.align	1
  78              		.global	rt_sem_detach
  79              		.syntax unified
  80              		.thumb
  81              		.thumb_func
  82              		.fpu fpv4-sp-d16
  84              	rt_sem_detach:
  85              	.LFB20:
 221:rt-thread/src/ipc.c **** RTM_EXPORT(rt_sem_init);
 222:rt-thread/src/ipc.c **** 
 223:rt-thread/src/ipc.c **** /**
 224:rt-thread/src/ipc.c ****  * This function will detach a semaphore from resource management
 225:rt-thread/src/ipc.c ****  *
 226:rt-thread/src/ipc.c ****  * @param sem the semaphore object
 227:rt-thread/src/ipc.c ****  *
 228:rt-thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 229:rt-thread/src/ipc.c ****  *
 230:rt-thread/src/ipc.c ****  * @see rt_sem_delete
 231:rt-thread/src/ipc.c ****  */
 232:rt-thread/src/ipc.c **** rt_err_t rt_sem_detach(rt_sem_t sem)
 233:rt-thread/src/ipc.c **** {
  86              		.loc 1 233 0
  87              		.cfi_startproc
  88              		@ args = 0, pretend = 0, frame = 0
  89              		@ frame_needed = 0, uses_anonymous_args = 0
  90              	.LVL6:
  91 0000 70B5     		push	{r4, r5, r6, lr}
  92              	.LCFI1:
  93              		.cfi_def_cfa_offset 16
  94              		.cfi_offset 4, -16
  95              		.cfi_offset 5, -12
  96              		.cfi_offset 6, -8
  97              		.cfi_offset 14, -4
  98 0002 0646     		mov	r6, r0
 234:rt-thread/src/ipc.c ****     /* parameter check */
 235:rt-thread/src/ipc.c ****     RT_ASSERT(sem != RT_NULL);
 236:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&sem->parent.parent) == RT_Object_Class_Semaphore);
 237:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&sem->parent.parent));
 238:rt-thread/src/ipc.c **** 
 239:rt-thread/src/ipc.c ****     /* wakeup all suspended threads */
 240:rt-thread/src/ipc.c ****     rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
  99              		.loc 1 240 0
 100 0004 00F11404 		add	r4, r0, #20
 101              	.LVL7:
 102 0008 0CE0     		b	.L4
 103              	.LVL8:
 104              	.L5:
 105              	.LBB79:
 106              	.LBB80:
 166:rt-thread/src/ipc.c **** 
 107              		.loc 1 166 0
 108 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 109              	.LVL9:
 110 000e 0546     		mov	r5, r0
 111              	.LVL10:
ARM GAS  /tmp/ccOtHhPO.s 			page 8


 169:rt-thread/src/ipc.c ****         /* set error code to RT_ERROR */
 112              		.loc 1 169 0
 113 0010 2068     		ldr	r0, [r4]
 114              	.LVL11:
 171:rt-thread/src/ipc.c **** 
 115              		.loc 1 171 0
 116 0012 4FF0FF33 		mov	r3, #-1
 117 0016 C361     		str	r3, [r0, #28]
 178:rt-thread/src/ipc.c **** 
 118              		.loc 1 178 0
 119 0018 1438     		subs	r0, r0, #20
 120              	.LVL12:
 121 001a FFF7FEFF 		bl	rt_thread_resume
 122              	.LVL13:
 181:rt-thread/src/ipc.c ****     }
 123              		.loc 1 181 0
 124 001e 2846     		mov	r0, r5
 125 0020 FFF7FEFF 		bl	rt_hw_interrupt_enable
 126              	.LVL14:
 127              	.L4:
 128              	.LBB81:
 129              	.LBB82:
  50:rt-thread/include/rtservice.h **** }
  51:rt-thread/include/rtservice.h **** 
  52:rt-thread/include/rtservice.h **** /**
  53:rt-thread/include/rtservice.h ****  * @brief insert a node after a list
  54:rt-thread/include/rtservice.h ****  *
  55:rt-thread/include/rtservice.h ****  * @param l list to insert it
  56:rt-thread/include/rtservice.h ****  * @param n new node to be inserted
  57:rt-thread/include/rtservice.h ****  */
  58:rt-thread/include/rtservice.h **** rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
  59:rt-thread/include/rtservice.h **** {
  60:rt-thread/include/rtservice.h ****     l->next->prev = n;
  61:rt-thread/include/rtservice.h ****     n->next = l->next;
  62:rt-thread/include/rtservice.h **** 
  63:rt-thread/include/rtservice.h ****     l->next = n;
  64:rt-thread/include/rtservice.h ****     n->prev = l;
  65:rt-thread/include/rtservice.h **** }
  66:rt-thread/include/rtservice.h **** 
  67:rt-thread/include/rtservice.h **** /**
  68:rt-thread/include/rtservice.h ****  * @brief insert a node before a list
  69:rt-thread/include/rtservice.h ****  *
  70:rt-thread/include/rtservice.h ****  * @param n new node to be inserted
  71:rt-thread/include/rtservice.h ****  * @param l list to insert it
  72:rt-thread/include/rtservice.h ****  */
  73:rt-thread/include/rtservice.h **** rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
  74:rt-thread/include/rtservice.h **** {
  75:rt-thread/include/rtservice.h ****     l->prev->next = n;
  76:rt-thread/include/rtservice.h ****     n->prev = l->prev;
  77:rt-thread/include/rtservice.h **** 
  78:rt-thread/include/rtservice.h ****     l->prev = n;
  79:rt-thread/include/rtservice.h ****     n->next = l;
  80:rt-thread/include/rtservice.h **** }
  81:rt-thread/include/rtservice.h **** 
  82:rt-thread/include/rtservice.h **** /**
  83:rt-thread/include/rtservice.h ****  * @brief remove node from list.
  84:rt-thread/include/rtservice.h ****  * @param n the node to remove from the list.
ARM GAS  /tmp/ccOtHhPO.s 			page 9


  85:rt-thread/include/rtservice.h ****  */
  86:rt-thread/include/rtservice.h **** rt_inline void rt_list_remove(rt_list_t *n)
  87:rt-thread/include/rtservice.h **** {
  88:rt-thread/include/rtservice.h ****     n->next->prev = n->prev;
  89:rt-thread/include/rtservice.h ****     n->prev->next = n->next;
  90:rt-thread/include/rtservice.h **** 
  91:rt-thread/include/rtservice.h ****     n->next = n->prev = n;
  92:rt-thread/include/rtservice.h **** }
  93:rt-thread/include/rtservice.h **** 
  94:rt-thread/include/rtservice.h **** /**
  95:rt-thread/include/rtservice.h ****  * @brief tests whether a list is empty
  96:rt-thread/include/rtservice.h ****  * @param l the list to test.
  97:rt-thread/include/rtservice.h ****  */
  98:rt-thread/include/rtservice.h **** rt_inline int rt_list_isempty(const rt_list_t *l)
  99:rt-thread/include/rtservice.h **** {
 100:rt-thread/include/rtservice.h ****     return l->next == l;
 130              		.loc 2 100 0
 131 0024 2368     		ldr	r3, [r4]
 132              	.LVL15:
 133              	.LBE82:
 134              	.LBE81:
 163:rt-thread/src/ipc.c ****     {
 135              		.loc 1 163 0
 136 0026 9C42     		cmp	r4, r3
 137 0028 EFD1     		bne	.L5
 138              	.LVL16:
 139              	.LBE80:
 140              	.LBE79:
 241:rt-thread/src/ipc.c **** 
 242:rt-thread/src/ipc.c ****     /* detach semaphore object */
 243:rt-thread/src/ipc.c ****     rt_object_detach(&(sem->parent.parent));
 141              		.loc 1 243 0
 142 002a 3046     		mov	r0, r6
 143 002c FFF7FEFF 		bl	rt_object_detach
 144              	.LVL17:
 244:rt-thread/src/ipc.c **** 
 245:rt-thread/src/ipc.c ****     return RT_EOK;
 246:rt-thread/src/ipc.c **** }
 145              		.loc 1 246 0
 146 0030 0020     		movs	r0, #0
 147 0032 70BD     		pop	{r4, r5, r6, pc}
 148              		.cfi_endproc
 149              	.LFE20:
 151              		.section	.text.rt_sem_create,"ax",%progbits
 152              		.align	1
 153              		.global	rt_sem_create
 154              		.syntax unified
 155              		.thumb
 156              		.thumb_func
 157              		.fpu fpv4-sp-d16
 159              	rt_sem_create:
 160              	.LFB21:
 247:rt-thread/src/ipc.c **** RTM_EXPORT(rt_sem_detach);
 248:rt-thread/src/ipc.c **** 
 249:rt-thread/src/ipc.c **** #ifdef RT_USING_HEAP
 250:rt-thread/src/ipc.c **** /**
 251:rt-thread/src/ipc.c ****  * This function will create a semaphore from system resource
ARM GAS  /tmp/ccOtHhPO.s 			page 10


 252:rt-thread/src/ipc.c ****  *
 253:rt-thread/src/ipc.c ****  * @param name the name of semaphore
 254:rt-thread/src/ipc.c ****  * @param value the initial value of semaphore
 255:rt-thread/src/ipc.c ****  * @param flag the flag of semaphore
 256:rt-thread/src/ipc.c ****  *
 257:rt-thread/src/ipc.c ****  * @return the created semaphore, RT_NULL on error happen
 258:rt-thread/src/ipc.c ****  *
 259:rt-thread/src/ipc.c ****  * @see rt_sem_init
 260:rt-thread/src/ipc.c ****  */
 261:rt-thread/src/ipc.c **** rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag)
 262:rt-thread/src/ipc.c **** {
 161              		.loc 1 262 0
 162              		.cfi_startproc
 163              		@ args = 0, pretend = 0, frame = 0
 164              		@ frame_needed = 0, uses_anonymous_args = 0
 165              	.LVL18:
 166 0000 38B5     		push	{r3, r4, r5, lr}
 167              	.LCFI2:
 168              		.cfi_def_cfa_offset 16
 169              		.cfi_offset 3, -16
 170              		.cfi_offset 4, -12
 171              		.cfi_offset 5, -8
 172              		.cfi_offset 14, -4
 173 0002 0D46     		mov	r5, r1
 174 0004 1446     		mov	r4, r2
 263:rt-thread/src/ipc.c ****     rt_sem_t sem;
 264:rt-thread/src/ipc.c **** 
 265:rt-thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 266:rt-thread/src/ipc.c ****     RT_ASSERT(value < 0x10000U);
 267:rt-thread/src/ipc.c **** 
 268:rt-thread/src/ipc.c ****     /* allocate object */
 269:rt-thread/src/ipc.c ****     sem = (rt_sem_t)rt_object_allocate(RT_Object_Class_Semaphore, name);
 175              		.loc 1 269 0
 176 0006 0146     		mov	r1, r0
 177              	.LVL19:
 178 0008 0220     		movs	r0, #2
 179              	.LVL20:
 180 000a FFF7FEFF 		bl	rt_object_allocate
 181              	.LVL21:
 270:rt-thread/src/ipc.c ****     if (sem == RT_NULL)
 182              		.loc 1 270 0
 183 000e 0346     		mov	r3, r0
 184 0010 28B1     		cbz	r0, .L7
 185              	.LVL22:
 186              	.LBB83:
 187              	.LBB84:
  64:rt-thread/src/ipc.c **** 
 188              		.loc 1 64 0
 189 0012 00F11402 		add	r2, r0, #20
 190              	.LVL23:
 191              	.LBB85:
 192              	.LBB86:
  49:rt-thread/include/rtservice.h **** }
 193              		.loc 2 49 0
 194 0016 8261     		str	r2, [r0, #24]
 195 0018 4261     		str	r2, [r0, #20]
 196              	.LVL24:
ARM GAS  /tmp/ccOtHhPO.s 			page 11


 197              	.LBE86:
 198              	.LBE85:
 199              	.LBE84:
 200              	.LBE83:
 271:rt-thread/src/ipc.c ****         return sem;
 272:rt-thread/src/ipc.c **** 
 273:rt-thread/src/ipc.c ****     /* initialize ipc object */
 274:rt-thread/src/ipc.c ****     rt_ipc_object_init(&(sem->parent));
 275:rt-thread/src/ipc.c **** 
 276:rt-thread/src/ipc.c ****     /* set initial value */
 277:rt-thread/src/ipc.c ****     sem->value = value;
 201              		.loc 1 277 0
 202 001a 8583     		strh	r5, [r0, #28]	@ movhi
 278:rt-thread/src/ipc.c **** 
 279:rt-thread/src/ipc.c ****     /* set parent */
 280:rt-thread/src/ipc.c ****     sem->parent.parent.flag = flag;
 203              		.loc 1 280 0
 204 001c 4472     		strb	r4, [r0, #9]
 205              	.L7:
 281:rt-thread/src/ipc.c **** 
 282:rt-thread/src/ipc.c ****     return sem;
 283:rt-thread/src/ipc.c **** }
 206              		.loc 1 283 0
 207 001e 1846     		mov	r0, r3
 208              	.LVL25:
 209 0020 38BD     		pop	{r3, r4, r5, pc}
 210              		.cfi_endproc
 211              	.LFE21:
 213              		.section	.text.rt_sem_delete,"ax",%progbits
 214              		.align	1
 215              		.global	rt_sem_delete
 216              		.syntax unified
 217              		.thumb
 218              		.thumb_func
 219              		.fpu fpv4-sp-d16
 221              	rt_sem_delete:
 222              	.LFB22:
 284:rt-thread/src/ipc.c **** RTM_EXPORT(rt_sem_create);
 285:rt-thread/src/ipc.c **** 
 286:rt-thread/src/ipc.c **** /**
 287:rt-thread/src/ipc.c ****  * This function will delete a semaphore object and release the memory
 288:rt-thread/src/ipc.c ****  *
 289:rt-thread/src/ipc.c ****  * @param sem the semaphore object
 290:rt-thread/src/ipc.c ****  *
 291:rt-thread/src/ipc.c ****  * @return the error code
 292:rt-thread/src/ipc.c ****  *
 293:rt-thread/src/ipc.c ****  * @see rt_sem_detach
 294:rt-thread/src/ipc.c ****  */
 295:rt-thread/src/ipc.c **** rt_err_t rt_sem_delete(rt_sem_t sem)
 296:rt-thread/src/ipc.c **** {
 223              		.loc 1 296 0
 224              		.cfi_startproc
 225              		@ args = 0, pretend = 0, frame = 0
 226              		@ frame_needed = 0, uses_anonymous_args = 0
 227              	.LVL26:
 228 0000 70B5     		push	{r4, r5, r6, lr}
 229              	.LCFI3:
ARM GAS  /tmp/ccOtHhPO.s 			page 12


 230              		.cfi_def_cfa_offset 16
 231              		.cfi_offset 4, -16
 232              		.cfi_offset 5, -12
 233              		.cfi_offset 6, -8
 234              		.cfi_offset 14, -4
 235 0002 0646     		mov	r6, r0
 297:rt-thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 298:rt-thread/src/ipc.c **** 
 299:rt-thread/src/ipc.c ****     /* parameter check */
 300:rt-thread/src/ipc.c ****     RT_ASSERT(sem != RT_NULL);
 301:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&sem->parent.parent) == RT_Object_Class_Semaphore);
 302:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&sem->parent.parent) == RT_FALSE);
 303:rt-thread/src/ipc.c **** 
 304:rt-thread/src/ipc.c ****     /* wakeup all suspended threads */
 305:rt-thread/src/ipc.c ****     rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
 236              		.loc 1 305 0
 237 0004 00F11404 		add	r4, r0, #20
 238              	.LVL27:
 239 0008 0CE0     		b	.L11
 240              	.LVL28:
 241              	.L12:
 242              	.LBB91:
 243              	.LBB92:
 166:rt-thread/src/ipc.c **** 
 244              		.loc 1 166 0
 245 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 246              	.LVL29:
 247 000e 0546     		mov	r5, r0
 248              	.LVL30:
 169:rt-thread/src/ipc.c ****         /* set error code to RT_ERROR */
 249              		.loc 1 169 0
 250 0010 2068     		ldr	r0, [r4]
 251              	.LVL31:
 171:rt-thread/src/ipc.c **** 
 252              		.loc 1 171 0
 253 0012 4FF0FF33 		mov	r3, #-1
 254 0016 C361     		str	r3, [r0, #28]
 178:rt-thread/src/ipc.c **** 
 255              		.loc 1 178 0
 256 0018 1438     		subs	r0, r0, #20
 257              	.LVL32:
 258 001a FFF7FEFF 		bl	rt_thread_resume
 259              	.LVL33:
 181:rt-thread/src/ipc.c ****     }
 260              		.loc 1 181 0
 261 001e 2846     		mov	r0, r5
 262 0020 FFF7FEFF 		bl	rt_hw_interrupt_enable
 263              	.LVL34:
 264              	.L11:
 265              	.LBB93:
 266              	.LBB94:
 267              		.loc 2 100 0
 268 0024 2368     		ldr	r3, [r4]
 269              	.LVL35:
 270              	.LBE94:
 271              	.LBE93:
 163:rt-thread/src/ipc.c ****     {
ARM GAS  /tmp/ccOtHhPO.s 			page 13


 272              		.loc 1 163 0
 273 0026 9C42     		cmp	r4, r3
 274 0028 EFD1     		bne	.L12
 275              	.LVL36:
 276              	.LBE92:
 277              	.LBE91:
 306:rt-thread/src/ipc.c **** 
 307:rt-thread/src/ipc.c ****     /* delete semaphore object */
 308:rt-thread/src/ipc.c ****     rt_object_delete(&(sem->parent.parent));
 278              		.loc 1 308 0
 279 002a 3046     		mov	r0, r6
 280 002c FFF7FEFF 		bl	rt_object_delete
 281              	.LVL37:
 309:rt-thread/src/ipc.c **** 
 310:rt-thread/src/ipc.c ****     return RT_EOK;
 311:rt-thread/src/ipc.c **** }
 282              		.loc 1 311 0
 283 0030 0020     		movs	r0, #0
 284 0032 70BD     		pop	{r4, r5, r6, pc}
 285              		.cfi_endproc
 286              	.LFE22:
 288              		.section	.text.rt_sem_take,"ax",%progbits
 289              		.align	1
 290              		.global	rt_sem_take
 291              		.syntax unified
 292              		.thumb
 293              		.thumb_func
 294              		.fpu fpv4-sp-d16
 296              	rt_sem_take:
 297              	.LFB23:
 312:rt-thread/src/ipc.c **** RTM_EXPORT(rt_sem_delete);
 313:rt-thread/src/ipc.c **** #endif
 314:rt-thread/src/ipc.c **** 
 315:rt-thread/src/ipc.c **** /**
 316:rt-thread/src/ipc.c ****  * This function will take a semaphore, if the semaphore is unavailable, the
 317:rt-thread/src/ipc.c ****  * thread shall wait for a specified time.
 318:rt-thread/src/ipc.c ****  *
 319:rt-thread/src/ipc.c ****  * @param sem the semaphore object
 320:rt-thread/src/ipc.c ****  * @param time the waiting time
 321:rt-thread/src/ipc.c ****  *
 322:rt-thread/src/ipc.c ****  * @return the error code
 323:rt-thread/src/ipc.c ****  */
 324:rt-thread/src/ipc.c **** rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time)
 325:rt-thread/src/ipc.c **** {
 298              		.loc 1 325 0
 299              		.cfi_startproc
 300              		@ args = 0, pretend = 0, frame = 8
 301              		@ frame_needed = 0, uses_anonymous_args = 0
 302              	.LVL38:
 303 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 304              	.LCFI4:
 305              		.cfi_def_cfa_offset 24
 306              		.cfi_offset 4, -24
 307              		.cfi_offset 5, -20
 308              		.cfi_offset 6, -16
 309              		.cfi_offset 7, -12
 310              		.cfi_offset 8, -8
ARM GAS  /tmp/ccOtHhPO.s 			page 14


 311              		.cfi_offset 14, -4
 312 0004 82B0     		sub	sp, sp, #8
 313              	.LCFI5:
 314              		.cfi_def_cfa_offset 32
 315 0006 0546     		mov	r5, r0
 316 0008 0191     		str	r1, [sp, #4]
 326:rt-thread/src/ipc.c ****     register rt_base_t temp;
 327:rt-thread/src/ipc.c ****     struct rt_thread *thread;
 328:rt-thread/src/ipc.c **** 
 329:rt-thread/src/ipc.c ****     /* parameter check */
 330:rt-thread/src/ipc.c ****     RT_ASSERT(sem != RT_NULL);
 331:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&sem->parent.parent) == RT_Object_Class_Semaphore);
 332:rt-thread/src/ipc.c **** 
 333:rt-thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(sem->parent.parent)));
 317              		.loc 1 333 0
 318 000a 364B     		ldr	r3, .L33
 319 000c 1B68     		ldr	r3, [r3]
 320 000e 03B1     		cbz	r3, .L15
 321              		.loc 1 333 0 is_stmt 0 discriminator 1
 322 0010 9847     		blx	r3
 323              	.LVL39:
 324              	.L15:
 334:rt-thread/src/ipc.c **** 
 335:rt-thread/src/ipc.c ****     /* disable interrupt */
 336:rt-thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
 325              		.loc 1 336 0 is_stmt 1
 326 0012 FFF7FEFF 		bl	rt_hw_interrupt_disable
 327              	.LVL40:
 328 0016 0746     		mov	r7, r0
 329              	.LVL41:
 337:rt-thread/src/ipc.c **** 
 338:rt-thread/src/ipc.c ****     RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s take sem:%s, which value is: %d\n",
 339:rt-thread/src/ipc.c ****                                 rt_thread_self()->name,
 340:rt-thread/src/ipc.c ****                                 ((struct rt_object *)sem)->name,
 341:rt-thread/src/ipc.c ****                                 sem->value));
 342:rt-thread/src/ipc.c **** 
 343:rt-thread/src/ipc.c ****     if (sem->value > 0)
 330              		.loc 1 343 0
 331 0018 AB8B     		ldrh	r3, [r5, #28]
 332 001a 83BB     		cbnz	r3, .L30
 344:rt-thread/src/ipc.c ****     {
 345:rt-thread/src/ipc.c ****         /* semaphore is available */
 346:rt-thread/src/ipc.c ****         sem->value --;
 347:rt-thread/src/ipc.c **** 
 348:rt-thread/src/ipc.c ****         /* enable interrupt */
 349:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
 350:rt-thread/src/ipc.c ****     }
 351:rt-thread/src/ipc.c ****     else
 352:rt-thread/src/ipc.c ****     {
 353:rt-thread/src/ipc.c ****         /* no waiting, return with timeout */
 354:rt-thread/src/ipc.c ****         if (time == 0)
 333              		.loc 1 354 0
 334 001c 019B     		ldr	r3, [sp, #4]
 335 001e 9BB3     		cbz	r3, .L31
 355:rt-thread/src/ipc.c ****         {
 356:rt-thread/src/ipc.c ****             rt_hw_interrupt_enable(temp);
 357:rt-thread/src/ipc.c **** 
ARM GAS  /tmp/ccOtHhPO.s 			page 15


 358:rt-thread/src/ipc.c ****             return -RT_ETIMEOUT;
 359:rt-thread/src/ipc.c ****         }
 360:rt-thread/src/ipc.c ****         else
 361:rt-thread/src/ipc.c ****         {
 362:rt-thread/src/ipc.c ****             /* current context checking */
 363:rt-thread/src/ipc.c ****             RT_DEBUG_IN_THREAD_CONTEXT;
 364:rt-thread/src/ipc.c **** 
 365:rt-thread/src/ipc.c ****             /* semaphore is unavailable, push to suspend list */
 366:rt-thread/src/ipc.c ****             /* get current thread */
 367:rt-thread/src/ipc.c ****             thread = rt_thread_self();
 336              		.loc 1 367 0
 337 0020 FFF7FEFF 		bl	rt_thread_self
 338              	.LVL42:
 339 0024 0446     		mov	r4, r0
 340              	.LVL43:
 368:rt-thread/src/ipc.c **** 
 369:rt-thread/src/ipc.c ****             /* reset thread error number */
 370:rt-thread/src/ipc.c ****             thread->error = RT_EOK;
 341              		.loc 1 370 0
 342 0026 0023     		movs	r3, #0
 343 0028 0363     		str	r3, [r0, #48]
 371:rt-thread/src/ipc.c **** 
 372:rt-thread/src/ipc.c ****             RT_DEBUG_LOG(RT_DEBUG_IPC, ("sem take: suspend thread - %s\n",
 373:rt-thread/src/ipc.c ****                                         thread->name));
 374:rt-thread/src/ipc.c **** 
 375:rt-thread/src/ipc.c ****             /* suspend thread */
 376:rt-thread/src/ipc.c ****             rt_ipc_list_suspend(&(sem->parent.suspend_thread),
 344              		.loc 1 376 0
 345 002a 05F11406 		add	r6, r5, #20
 346 002e 95F80980 		ldrb	r8, [r5, #9]	@ zero_extendqisi2
 347              	.LVL44:
 348              	.LBB104:
 349              	.LBB105:
  85:rt-thread/src/ipc.c **** 
 350              		.loc 1 85 0
 351 0032 FFF7FEFF 		bl	rt_thread_suspend
 352              	.LVL45:
  87:rt-thread/src/ipc.c ****     {
 353              		.loc 1 87 0
 354 0036 B8F1000F 		cmp	r8, #0
 355 003a 2AD0     		beq	.L21
 356 003c B8F1010F 		cmp	r8, #1
 357 0040 30D0     		beq	.L22
 358              	.L20:
 359              	.LVL46:
 360              	.LBE105:
 361              	.LBE104:
 377:rt-thread/src/ipc.c ****                                 thread,
 378:rt-thread/src/ipc.c ****                                 sem->parent.parent.flag);
 379:rt-thread/src/ipc.c **** 
 380:rt-thread/src/ipc.c ****             /* has waiting time, start thread timer */
 381:rt-thread/src/ipc.c ****             if (time > 0)
 362              		.loc 1 381 0
 363 0042 019B     		ldr	r3, [sp, #4]
 364 0044 002B     		cmp	r3, #0
 365 0046 09DD     		ble	.L27
 382:rt-thread/src/ipc.c ****             {
ARM GAS  /tmp/ccOtHhPO.s 			page 16


 383:rt-thread/src/ipc.c ****                 RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
 384:rt-thread/src/ipc.c ****                                             thread->name));
 385:rt-thread/src/ipc.c **** 
 386:rt-thread/src/ipc.c ****                 /* reset the timeout of thread timer and start it */
 387:rt-thread/src/ipc.c ****                 rt_timer_control(&(thread->thread_timer),
 366              		.loc 1 387 0
 367 0048 04F14C06 		add	r6, r4, #76
 368 004c 01AA     		add	r2, sp, #4
 369 004e 0021     		movs	r1, #0
 370 0050 3046     		mov	r0, r6
 371 0052 FFF7FEFF 		bl	rt_timer_control
 372              	.LVL47:
 388:rt-thread/src/ipc.c ****                                  RT_TIMER_CTRL_SET_TIME,
 389:rt-thread/src/ipc.c ****                                  &time);
 390:rt-thread/src/ipc.c ****                 rt_timer_start(&(thread->thread_timer));
 373              		.loc 1 390 0
 374 0056 3046     		mov	r0, r6
 375 0058 FFF7FEFF 		bl	rt_timer_start
 376              	.LVL48:
 377              	.L27:
 391:rt-thread/src/ipc.c ****             }
 392:rt-thread/src/ipc.c **** 
 393:rt-thread/src/ipc.c ****             /* enable interrupt */
 394:rt-thread/src/ipc.c ****             rt_hw_interrupt_enable(temp);
 378              		.loc 1 394 0
 379 005c 3846     		mov	r0, r7
 380 005e FFF7FEFF 		bl	rt_hw_interrupt_enable
 381              	.LVL49:
 395:rt-thread/src/ipc.c **** 
 396:rt-thread/src/ipc.c ****             /* do schedule */
 397:rt-thread/src/ipc.c ****             rt_schedule();
 382              		.loc 1 397 0
 383 0062 FFF7FEFF 		bl	rt_schedule
 384              	.LVL50:
 398:rt-thread/src/ipc.c **** 
 399:rt-thread/src/ipc.c ****             if (thread->error != RT_EOK)
 385              		.loc 1 399 0
 386 0066 206B     		ldr	r0, [r4, #48]
 387 0068 30B9     		cbnz	r0, .L14
 388              	.LVL51:
 389              	.L17:
 400:rt-thread/src/ipc.c ****             {
 401:rt-thread/src/ipc.c ****                 return thread->error;
 402:rt-thread/src/ipc.c ****             }
 403:rt-thread/src/ipc.c ****         }
 404:rt-thread/src/ipc.c ****     }
 405:rt-thread/src/ipc.c **** 
 406:rt-thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(sem->parent.parent)));
 390              		.loc 1 406 0
 391 006a 1F4B     		ldr	r3, .L33+4
 392 006c 1B68     		ldr	r3, [r3]
 393 006e 002B     		cmp	r3, #0
 394 0070 36D0     		beq	.L28
 395              		.loc 1 406 0 is_stmt 0 discriminator 1
 396 0072 2846     		mov	r0, r5
 397 0074 9847     		blx	r3
 398              	.LVL52:
ARM GAS  /tmp/ccOtHhPO.s 			page 17


 407:rt-thread/src/ipc.c **** 
 408:rt-thread/src/ipc.c ****     return RT_EOK;
 399              		.loc 1 408 0 is_stmt 1 discriminator 1
 400 0076 0020     		movs	r0, #0
 401              	.L14:
 409:rt-thread/src/ipc.c **** }
 402              		.loc 1 409 0
 403 0078 02B0     		add	sp, sp, #8
 404              	.LCFI6:
 405              		.cfi_remember_state
 406              		.cfi_def_cfa_offset 24
 407              		@ sp needed
 408 007a BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 409              	.LVL53:
 410              	.L30:
 411              	.LCFI7:
 412              		.cfi_restore_state
 346:rt-thread/src/ipc.c **** 
 413              		.loc 1 346 0
 414 007e 013B     		subs	r3, r3, #1
 415 0080 AB83     		strh	r3, [r5, #28]	@ movhi
 349:rt-thread/src/ipc.c ****     }
 416              		.loc 1 349 0
 417 0082 FFF7FEFF 		bl	rt_hw_interrupt_enable
 418              	.LVL54:
 419 0086 F0E7     		b	.L17
 420              	.LVL55:
 421              	.L31:
 356:rt-thread/src/ipc.c **** 
 422              		.loc 1 356 0
 423 0088 FFF7FEFF 		bl	rt_hw_interrupt_enable
 424              	.LVL56:
 358:rt-thread/src/ipc.c ****         }
 425              		.loc 1 358 0
 426 008c 6FF00100 		mvn	r0, #1
 427 0090 F2E7     		b	.L14
 428              	.LVL57:
 429              	.L21:
 430              	.LBB114:
 431              	.LBB113:
  90:rt-thread/src/ipc.c ****         break;
 432              		.loc 1 90 0
 433 0092 04F11403 		add	r3, r4, #20
 434              	.LVL58:
 435              	.LBB106:
 436              	.LBB107:
  75:rt-thread/include/rtservice.h ****     n->prev = l->prev;
 437              		.loc 2 75 0
 438 0096 7268     		ldr	r2, [r6, #4]
 439 0098 1360     		str	r3, [r2]
  76:rt-thread/include/rtservice.h **** 
 440              		.loc 2 76 0
 441 009a 7268     		ldr	r2, [r6, #4]
 442 009c A261     		str	r2, [r4, #24]
  78:rt-thread/include/rtservice.h ****     n->next = l;
 443              		.loc 2 78 0
 444 009e 7360     		str	r3, [r6, #4]
ARM GAS  /tmp/ccOtHhPO.s 			page 18


  79:rt-thread/include/rtservice.h **** }
 445              		.loc 2 79 0
 446 00a0 6661     		str	r6, [r4, #20]
 447 00a2 CEE7     		b	.L20
 448              	.LVL59:
 449              	.L22:
 450              	.LBE107:
 451              	.LBE106:
 452              	.LBB108:
  99:rt-thread/src/ipc.c ****             {
 453              		.loc 1 99 0
 454 00a4 6B69     		ldr	r3, [r5, #20]
 455              	.LVL60:
 456              	.L23:
 457 00a6 9E42     		cmp	r6, r3
 458 00a8 0FD0     		beq	.L25
 459              	.LVL61:
 104:rt-thread/src/ipc.c ****                 {
 460              		.loc 1 104 0
 461 00aa 94F83510 		ldrb	r1, [r4, #53]	@ zero_extendqisi2
 462 00ae 93F82120 		ldrb	r2, [r3, #33]	@ zero_extendqisi2
 463 00b2 9142     		cmp	r1, r2
 464 00b4 01D3     		bcc	.L32
  99:rt-thread/src/ipc.c ****             {
 465              		.loc 1 99 0
 466 00b6 1B68     		ldr	r3, [r3]
 467              	.LVL62:
 468 00b8 F5E7     		b	.L23
 469              	.LVL63:
 470              	.L32:
 107:rt-thread/src/ipc.c ****                     break;
 471              		.loc 1 107 0
 472 00ba 04F11402 		add	r2, r4, #20
 473              	.LVL64:
 474              	.LBB109:
 475              	.LBB110:
  75:rt-thread/include/rtservice.h ****     n->prev = l->prev;
 476              		.loc 2 75 0
 477 00be 5968     		ldr	r1, [r3, #4]
 478 00c0 0A60     		str	r2, [r1]
  76:rt-thread/include/rtservice.h **** 
 479              		.loc 2 76 0
 480 00c2 5968     		ldr	r1, [r3, #4]
 481 00c4 A161     		str	r1, [r4, #24]
  78:rt-thread/include/rtservice.h ****     n->next = l;
 482              		.loc 2 78 0
 483 00c6 5A60     		str	r2, [r3, #4]
  79:rt-thread/include/rtservice.h **** }
 484              		.loc 2 79 0
 485 00c8 6361     		str	r3, [r4, #20]
 486              	.LVL65:
 487              	.L25:
 488              	.LBE110:
 489              	.LBE109:
 116:rt-thread/src/ipc.c ****                 rt_list_insert_before(list, &(thread->tlist));
 490              		.loc 1 116 0
 491 00ca 9E42     		cmp	r6, r3
ARM GAS  /tmp/ccOtHhPO.s 			page 19


 492 00cc B9D1     		bne	.L20
 117:rt-thread/src/ipc.c ****         }
 493              		.loc 1 117 0
 494 00ce 04F11403 		add	r3, r4, #20
 495              	.LVL66:
 496              	.LBB111:
 497              	.LBB112:
  75:rt-thread/include/rtservice.h ****     n->prev = l->prev;
 498              		.loc 2 75 0
 499 00d2 7268     		ldr	r2, [r6, #4]
 500 00d4 1360     		str	r3, [r2]
  76:rt-thread/include/rtservice.h **** 
 501              		.loc 2 76 0
 502 00d6 7268     		ldr	r2, [r6, #4]
 503 00d8 A261     		str	r2, [r4, #24]
  78:rt-thread/include/rtservice.h ****     n->next = l;
 504              		.loc 2 78 0
 505 00da 7360     		str	r3, [r6, #4]
  79:rt-thread/include/rtservice.h **** }
 506              		.loc 2 79 0
 507 00dc 6661     		str	r6, [r4, #20]
 508 00de B0E7     		b	.L20
 509              	.LVL67:
 510              	.L28:
 511              	.LBE112:
 512              	.LBE111:
 513              	.LBE108:
 514              	.LBE113:
 515              	.LBE114:
 408:rt-thread/src/ipc.c **** }
 516              		.loc 1 408 0
 517 00e0 0020     		movs	r0, #0
 518 00e2 C9E7     		b	.L14
 519              	.L34:
 520              		.align	2
 521              	.L33:
 522 00e4 00000000 		.word	rt_object_trytake_hook
 523 00e8 00000000 		.word	rt_object_take_hook
 524              		.cfi_endproc
 525              	.LFE23:
 527              		.section	.text.rt_sem_trytake,"ax",%progbits
 528              		.align	1
 529              		.global	rt_sem_trytake
 530              		.syntax unified
 531              		.thumb
 532              		.thumb_func
 533              		.fpu fpv4-sp-d16
 535              	rt_sem_trytake:
 536              	.LFB24:
 410:rt-thread/src/ipc.c **** RTM_EXPORT(rt_sem_take);
 411:rt-thread/src/ipc.c **** 
 412:rt-thread/src/ipc.c **** /**
 413:rt-thread/src/ipc.c ****  * This function will try to take a semaphore and immediately return
 414:rt-thread/src/ipc.c ****  *
 415:rt-thread/src/ipc.c ****  * @param sem the semaphore object
 416:rt-thread/src/ipc.c ****  *
 417:rt-thread/src/ipc.c ****  * @return the error code
ARM GAS  /tmp/ccOtHhPO.s 			page 20


 418:rt-thread/src/ipc.c ****  */
 419:rt-thread/src/ipc.c **** rt_err_t rt_sem_trytake(rt_sem_t sem)
 420:rt-thread/src/ipc.c **** {
 537              		.loc 1 420 0
 538              		.cfi_startproc
 539              		@ args = 0, pretend = 0, frame = 0
 540              		@ frame_needed = 0, uses_anonymous_args = 0
 541              	.LVL68:
 542 0000 08B5     		push	{r3, lr}
 543              	.LCFI8:
 544              		.cfi_def_cfa_offset 8
 545              		.cfi_offset 3, -8
 546              		.cfi_offset 14, -4
 421:rt-thread/src/ipc.c ****     return rt_sem_take(sem, 0);
 547              		.loc 1 421 0
 548 0002 0021     		movs	r1, #0
 549 0004 FFF7FEFF 		bl	rt_sem_take
 550              	.LVL69:
 422:rt-thread/src/ipc.c **** }
 551              		.loc 1 422 0
 552 0008 08BD     		pop	{r3, pc}
 553              		.cfi_endproc
 554              	.LFE24:
 556              		.section	.text.rt_sem_release,"ax",%progbits
 557              		.align	1
 558              		.global	rt_sem_release
 559              		.syntax unified
 560              		.thumb
 561              		.thumb_func
 562              		.fpu fpv4-sp-d16
 564              	rt_sem_release:
 565              	.LFB25:
 423:rt-thread/src/ipc.c **** RTM_EXPORT(rt_sem_trytake);
 424:rt-thread/src/ipc.c **** 
 425:rt-thread/src/ipc.c **** /**
 426:rt-thread/src/ipc.c ****  * This function will release a semaphore, if there are threads suspended on
 427:rt-thread/src/ipc.c ****  * semaphore, it will be waked up.
 428:rt-thread/src/ipc.c ****  *
 429:rt-thread/src/ipc.c ****  * @param sem the semaphore object
 430:rt-thread/src/ipc.c ****  *
 431:rt-thread/src/ipc.c ****  * @return the error code
 432:rt-thread/src/ipc.c ****  */
 433:rt-thread/src/ipc.c **** rt_err_t rt_sem_release(rt_sem_t sem)
 434:rt-thread/src/ipc.c **** {
 566              		.loc 1 434 0
 567              		.cfi_startproc
 568              		@ args = 0, pretend = 0, frame = 0
 569              		@ frame_needed = 0, uses_anonymous_args = 0
 570              	.LVL70:
 571 0000 38B5     		push	{r3, r4, r5, lr}
 572              	.LCFI9:
 573              		.cfi_def_cfa_offset 16
 574              		.cfi_offset 3, -16
 575              		.cfi_offset 4, -12
 576              		.cfi_offset 5, -8
 577              		.cfi_offset 14, -4
 578 0002 0446     		mov	r4, r0
ARM GAS  /tmp/ccOtHhPO.s 			page 21


 435:rt-thread/src/ipc.c ****     register rt_base_t temp;
 436:rt-thread/src/ipc.c ****     register rt_bool_t need_schedule;
 437:rt-thread/src/ipc.c **** 
 438:rt-thread/src/ipc.c ****     /* parameter check */
 439:rt-thread/src/ipc.c ****     RT_ASSERT(sem != RT_NULL);
 440:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&sem->parent.parent) == RT_Object_Class_Semaphore);
 441:rt-thread/src/ipc.c **** 
 442:rt-thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(sem->parent.parent)));
 579              		.loc 1 442 0
 580 0004 0E4B     		ldr	r3, .L44
 581 0006 1B68     		ldr	r3, [r3]
 582 0008 03B1     		cbz	r3, .L38
 583              		.loc 1 442 0 is_stmt 0 discriminator 1
 584 000a 9847     		blx	r3
 585              	.LVL71:
 586              	.L38:
 443:rt-thread/src/ipc.c **** 
 444:rt-thread/src/ipc.c ****     need_schedule = RT_FALSE;
 445:rt-thread/src/ipc.c **** 
 446:rt-thread/src/ipc.c ****     /* disable interrupt */
 447:rt-thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
 587              		.loc 1 447 0 is_stmt 1
 588 000c FFF7FEFF 		bl	rt_hw_interrupt_disable
 589              	.LVL72:
 590 0010 0546     		mov	r5, r0
 591              	.LVL73:
 448:rt-thread/src/ipc.c **** 
 449:rt-thread/src/ipc.c ****     RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s releases sem:%s, which value is: %d\n",
 450:rt-thread/src/ipc.c ****                                 rt_thread_self()->name,
 451:rt-thread/src/ipc.c ****                                 ((struct rt_object *)sem)->name,
 452:rt-thread/src/ipc.c ****                                 sem->value));
 453:rt-thread/src/ipc.c **** 
 454:rt-thread/src/ipc.c ****     if (!rt_list_isempty(&sem->parent.suspend_thread))
 592              		.loc 1 454 0
 593 0012 04F11403 		add	r3, r4, #20
 594              	.LBB115:
 595              	.LBB116:
 596              		.loc 2 100 0
 597 0016 6069     		ldr	r0, [r4, #20]
 598              	.LVL74:
 599              	.LBE116:
 600              	.LBE115:
 601              		.loc 1 454 0
 602 0018 8342     		cmp	r3, r0
 603 001a 09D0     		beq	.L39
 604              	.LVL75:
 605              	.LBB117:
 606              	.LBB118:
 144:rt-thread/src/ipc.c **** 
 607              		.loc 1 144 0
 608 001c 1438     		subs	r0, r0, #20
 609              	.LVL76:
 610 001e FFF7FEFF 		bl	rt_thread_resume
 611              	.LVL77:
 612              	.LBE118:
 613              	.LBE117:
 455:rt-thread/src/ipc.c ****     {
ARM GAS  /tmp/ccOtHhPO.s 			page 22


 456:rt-thread/src/ipc.c ****         /* resume the suspended thread */
 457:rt-thread/src/ipc.c ****         rt_ipc_list_resume(&(sem->parent.suspend_thread));
 458:rt-thread/src/ipc.c ****         need_schedule = RT_TRUE;
 614              		.loc 1 458 0
 615 0022 0124     		movs	r4, #1
 616              	.LVL78:
 617              	.L40:
 459:rt-thread/src/ipc.c ****     }
 460:rt-thread/src/ipc.c ****     else
 461:rt-thread/src/ipc.c ****         sem->value ++; /* increase value */
 462:rt-thread/src/ipc.c **** 
 463:rt-thread/src/ipc.c ****     /* enable interrupt */
 464:rt-thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
 618              		.loc 1 464 0
 619 0024 2846     		mov	r0, r5
 620 0026 FFF7FEFF 		bl	rt_hw_interrupt_enable
 621              	.LVL79:
 465:rt-thread/src/ipc.c **** 
 466:rt-thread/src/ipc.c ****     /* resume a thread, re-schedule */
 467:rt-thread/src/ipc.c ****     if (need_schedule == RT_TRUE)
 622              		.loc 1 467 0
 623 002a 34B9     		cbnz	r4, .L43
 624              	.L41:
 468:rt-thread/src/ipc.c ****         rt_schedule();
 469:rt-thread/src/ipc.c **** 
 470:rt-thread/src/ipc.c ****     return RT_EOK;
 471:rt-thread/src/ipc.c **** }
 625              		.loc 1 471 0
 626 002c 0020     		movs	r0, #0
 627 002e 38BD     		pop	{r3, r4, r5, pc}
 628              	.LVL80:
 629              	.L39:
 461:rt-thread/src/ipc.c **** 
 630              		.loc 1 461 0
 631 0030 A38B     		ldrh	r3, [r4, #28]
 632 0032 0133     		adds	r3, r3, #1
 633 0034 A383     		strh	r3, [r4, #28]	@ movhi
 444:rt-thread/src/ipc.c **** 
 634              		.loc 1 444 0
 635 0036 0024     		movs	r4, #0
 636              	.LVL81:
 637 0038 F4E7     		b	.L40
 638              	.LVL82:
 639              	.L43:
 468:rt-thread/src/ipc.c ****         rt_schedule();
 640              		.loc 1 468 0
 641 003a FFF7FEFF 		bl	rt_schedule
 642              	.LVL83:
 643 003e F5E7     		b	.L41
 644              	.L45:
 645              		.align	2
 646              	.L44:
 647 0040 00000000 		.word	rt_object_put_hook
 648              		.cfi_endproc
 649              	.LFE25:
 651              		.section	.text.rt_sem_control,"ax",%progbits
 652              		.align	1
ARM GAS  /tmp/ccOtHhPO.s 			page 23


 653              		.global	rt_sem_control
 654              		.syntax unified
 655              		.thumb
 656              		.thumb_func
 657              		.fpu fpv4-sp-d16
 659              	rt_sem_control:
 660              	.LFB26:
 472:rt-thread/src/ipc.c **** RTM_EXPORT(rt_sem_release);
 473:rt-thread/src/ipc.c **** 
 474:rt-thread/src/ipc.c **** /**
 475:rt-thread/src/ipc.c ****  * This function can get or set some extra attributions of a semaphore object.
 476:rt-thread/src/ipc.c ****  *
 477:rt-thread/src/ipc.c ****  * @param sem the semaphore object
 478:rt-thread/src/ipc.c ****  * @param cmd the execution command
 479:rt-thread/src/ipc.c ****  * @param arg the execution argument
 480:rt-thread/src/ipc.c ****  *
 481:rt-thread/src/ipc.c ****  * @return the error code
 482:rt-thread/src/ipc.c ****  */
 483:rt-thread/src/ipc.c **** rt_err_t rt_sem_control(rt_sem_t sem, int cmd, void *arg)
 484:rt-thread/src/ipc.c **** {
 661              		.loc 1 484 0
 662              		.cfi_startproc
 663              		@ args = 0, pretend = 0, frame = 0
 664              		@ frame_needed = 0, uses_anonymous_args = 0
 665              	.LVL84:
 485:rt-thread/src/ipc.c ****     rt_ubase_t level;
 486:rt-thread/src/ipc.c **** 
 487:rt-thread/src/ipc.c ****     /* parameter check */
 488:rt-thread/src/ipc.c ****     RT_ASSERT(sem != RT_NULL);
 489:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&sem->parent.parent) == RT_Object_Class_Semaphore);
 490:rt-thread/src/ipc.c **** 
 491:rt-thread/src/ipc.c ****     if (cmd == RT_IPC_CMD_RESET)
 666              		.loc 1 491 0
 667 0000 0129     		cmp	r1, #1
 668 0002 22D1     		bne	.L50
 484:rt-thread/src/ipc.c ****     rt_ubase_t level;
 669              		.loc 1 484 0
 670 0004 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 671              	.LCFI10:
 672              		.cfi_def_cfa_offset 24
 673              		.cfi_offset 4, -24
 674              		.cfi_offset 5, -20
 675              		.cfi_offset 6, -16
 676              		.cfi_offset 7, -12
 677              		.cfi_offset 8, -8
 678              		.cfi_offset 14, -4
 679 0008 1746     		mov	r7, r2
 680 000a 0646     		mov	r6, r0
 681              	.LVL85:
 682              	.LBB124:
 492:rt-thread/src/ipc.c ****     {
 493:rt-thread/src/ipc.c ****         rt_ubase_t value;
 494:rt-thread/src/ipc.c **** 
 495:rt-thread/src/ipc.c ****         /* get value */
 496:rt-thread/src/ipc.c ****         value = (rt_ubase_t)arg;
 497:rt-thread/src/ipc.c ****         /* disable interrupt */
 498:rt-thread/src/ipc.c ****         level = rt_hw_interrupt_disable();
ARM GAS  /tmp/ccOtHhPO.s 			page 24


 683              		.loc 1 498 0
 684 000c FFF7FEFF 		bl	rt_hw_interrupt_disable
 685              	.LVL86:
 686 0010 8046     		mov	r8, r0
 687              	.LVL87:
 499:rt-thread/src/ipc.c **** 
 500:rt-thread/src/ipc.c ****         /* resume all waiting thread */
 501:rt-thread/src/ipc.c ****         rt_ipc_list_resume_all(&sem->parent.suspend_thread);
 688              		.loc 1 501 0
 689 0012 06F11404 		add	r4, r6, #20
 690              	.LVL88:
 691 0016 0CE0     		b	.L48
 692              	.LVL89:
 693              	.L49:
 694              	.LBB125:
 695              	.LBB126:
 166:rt-thread/src/ipc.c **** 
 696              		.loc 1 166 0
 697 0018 FFF7FEFF 		bl	rt_hw_interrupt_disable
 698              	.LVL90:
 699 001c 0546     		mov	r5, r0
 700              	.LVL91:
 169:rt-thread/src/ipc.c ****         /* set error code to RT_ERROR */
 701              		.loc 1 169 0
 702 001e 2068     		ldr	r0, [r4]
 703              	.LVL92:
 171:rt-thread/src/ipc.c **** 
 704              		.loc 1 171 0
 705 0020 4FF0FF33 		mov	r3, #-1
 706 0024 C361     		str	r3, [r0, #28]
 178:rt-thread/src/ipc.c **** 
 707              		.loc 1 178 0
 708 0026 1438     		subs	r0, r0, #20
 709              	.LVL93:
 710 0028 FFF7FEFF 		bl	rt_thread_resume
 711              	.LVL94:
 181:rt-thread/src/ipc.c ****     }
 712              		.loc 1 181 0
 713 002c 2846     		mov	r0, r5
 714 002e FFF7FEFF 		bl	rt_hw_interrupt_enable
 715              	.LVL95:
 716              	.L48:
 717              	.LBB127:
 718              	.LBB128:
 719              		.loc 2 100 0
 720 0032 2368     		ldr	r3, [r4]
 721              	.LVL96:
 722              	.LBE128:
 723              	.LBE127:
 163:rt-thread/src/ipc.c ****     {
 724              		.loc 1 163 0
 725 0034 9C42     		cmp	r4, r3
 726 0036 EFD1     		bne	.L49
 727              	.LVL97:
 728              	.LBE126:
 729              	.LBE125:
 502:rt-thread/src/ipc.c **** 
ARM GAS  /tmp/ccOtHhPO.s 			page 25


 503:rt-thread/src/ipc.c ****         /* set new value */
 504:rt-thread/src/ipc.c ****         sem->value = (rt_uint16_t)value;
 730              		.loc 1 504 0
 731 0038 B783     		strh	r7, [r6, #28]	@ movhi
 505:rt-thread/src/ipc.c **** 
 506:rt-thread/src/ipc.c ****         /* enable interrupt */
 507:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(level);
 732              		.loc 1 507 0
 733 003a 4046     		mov	r0, r8
 734 003c FFF7FEFF 		bl	rt_hw_interrupt_enable
 735              	.LVL98:
 508:rt-thread/src/ipc.c **** 
 509:rt-thread/src/ipc.c ****         rt_schedule();
 736              		.loc 1 509 0
 737 0040 FFF7FEFF 		bl	rt_schedule
 738              	.LVL99:
 510:rt-thread/src/ipc.c **** 
 511:rt-thread/src/ipc.c ****         return RT_EOK;
 739              		.loc 1 511 0
 740 0044 0020     		movs	r0, #0
 741 0046 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 742              	.LVL100:
 743              	.L50:
 744              	.LCFI11:
 745              		.cfi_def_cfa_offset 0
 746              		.cfi_restore 4
 747              		.cfi_restore 5
 748              		.cfi_restore 6
 749              		.cfi_restore 7
 750              		.cfi_restore 8
 751              		.cfi_restore 14
 752              	.LBE124:
 512:rt-thread/src/ipc.c ****     }
 513:rt-thread/src/ipc.c **** 
 514:rt-thread/src/ipc.c ****     return -RT_ERROR;
 753              		.loc 1 514 0
 754 004a 4FF0FF30 		mov	r0, #-1
 755              	.LVL101:
 756 004e 7047     		bx	lr
 757              		.cfi_endproc
 758              	.LFE26:
 760              		.section	.text.rt_mutex_init,"ax",%progbits
 761              		.align	1
 762              		.global	rt_mutex_init
 763              		.syntax unified
 764              		.thumb
 765              		.thumb_func
 766              		.fpu fpv4-sp-d16
 768              	rt_mutex_init:
 769              	.LFB27:
 515:rt-thread/src/ipc.c **** }
 516:rt-thread/src/ipc.c **** RTM_EXPORT(rt_sem_control);
 517:rt-thread/src/ipc.c **** #endif /* end of RT_USING_SEMAPHORE */
 518:rt-thread/src/ipc.c **** 
 519:rt-thread/src/ipc.c **** #ifdef RT_USING_MUTEX
 520:rt-thread/src/ipc.c **** /**
 521:rt-thread/src/ipc.c ****  * This function will initialize a mutex and put it under control of resource
ARM GAS  /tmp/ccOtHhPO.s 			page 26


 522:rt-thread/src/ipc.c ****  * management.
 523:rt-thread/src/ipc.c ****  *
 524:rt-thread/src/ipc.c ****  * @param mutex the mutex object
 525:rt-thread/src/ipc.c ****  * @param name the name of mutex
 526:rt-thread/src/ipc.c ****  * @param flag the flag of mutex
 527:rt-thread/src/ipc.c ****  *
 528:rt-thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 529:rt-thread/src/ipc.c ****  */
 530:rt-thread/src/ipc.c **** rt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag)
 531:rt-thread/src/ipc.c **** {
 770              		.loc 1 531 0
 771              		.cfi_startproc
 772              		@ args = 0, pretend = 0, frame = 0
 773              		@ frame_needed = 0, uses_anonymous_args = 0
 774              	.LVL102:
 775 0000 38B5     		push	{r3, r4, r5, lr}
 776              	.LCFI12:
 777              		.cfi_def_cfa_offset 16
 778              		.cfi_offset 3, -16
 779              		.cfi_offset 4, -12
 780              		.cfi_offset 5, -8
 781              		.cfi_offset 14, -4
 782 0002 0446     		mov	r4, r0
 783 0004 1546     		mov	r5, r2
 532:rt-thread/src/ipc.c ****     /* parameter check */
 533:rt-thread/src/ipc.c ****     RT_ASSERT(mutex != RT_NULL);
 534:rt-thread/src/ipc.c **** 
 535:rt-thread/src/ipc.c ****     /* initialize object */
 536:rt-thread/src/ipc.c ****     rt_object_init(&(mutex->parent.parent), RT_Object_Class_Mutex, name);
 784              		.loc 1 536 0
 785 0006 0A46     		mov	r2, r1
 786              	.LVL103:
 787 0008 0321     		movs	r1, #3
 788              	.LVL104:
 789 000a FFF7FEFF 		bl	rt_object_init
 790              	.LVL105:
 791              	.LBB129:
 792              	.LBB130:
  64:rt-thread/src/ipc.c **** 
 793              		.loc 1 64 0
 794 000e 04F11403 		add	r3, r4, #20
 795              	.LVL106:
 796              	.LBB131:
 797              	.LBB132:
  49:rt-thread/include/rtservice.h **** }
 798              		.loc 2 49 0
 799 0012 A361     		str	r3, [r4, #24]
 800 0014 6361     		str	r3, [r4, #20]
 801              	.LVL107:
 802              	.LBE132:
 803              	.LBE131:
 804              	.LBE130:
 805              	.LBE129:
 537:rt-thread/src/ipc.c **** 
 538:rt-thread/src/ipc.c ****     /* initialize ipc object */
 539:rt-thread/src/ipc.c ****     rt_ipc_object_init(&(mutex->parent));
 540:rt-thread/src/ipc.c **** 
ARM GAS  /tmp/ccOtHhPO.s 			page 27


 541:rt-thread/src/ipc.c ****     mutex->value = 1;
 806              		.loc 1 541 0
 807 0016 0123     		movs	r3, #1
 808 0018 A383     		strh	r3, [r4, #28]	@ movhi
 542:rt-thread/src/ipc.c ****     mutex->owner = RT_NULL;
 809              		.loc 1 542 0
 810 001a 0020     		movs	r0, #0
 811 001c 2062     		str	r0, [r4, #32]
 543:rt-thread/src/ipc.c ****     mutex->original_priority = 0xFF;
 812              		.loc 1 543 0
 813 001e FF23     		movs	r3, #255
 814 0020 A377     		strb	r3, [r4, #30]
 544:rt-thread/src/ipc.c ****     mutex->hold  = 0;
 815              		.loc 1 544 0
 816 0022 E077     		strb	r0, [r4, #31]
 545:rt-thread/src/ipc.c **** 
 546:rt-thread/src/ipc.c ****     /* set flag */
 547:rt-thread/src/ipc.c ****     mutex->parent.parent.flag = flag;
 817              		.loc 1 547 0
 818 0024 6572     		strb	r5, [r4, #9]
 548:rt-thread/src/ipc.c **** 
 549:rt-thread/src/ipc.c ****     return RT_EOK;
 550:rt-thread/src/ipc.c **** }
 819              		.loc 1 550 0
 820 0026 38BD     		pop	{r3, r4, r5, pc}
 821              		.cfi_endproc
 822              	.LFE27:
 824              		.section	.text.rt_mutex_detach,"ax",%progbits
 825              		.align	1
 826              		.global	rt_mutex_detach
 827              		.syntax unified
 828              		.thumb
 829              		.thumb_func
 830              		.fpu fpv4-sp-d16
 832              	rt_mutex_detach:
 833              	.LFB28:
 551:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mutex_init);
 552:rt-thread/src/ipc.c **** 
 553:rt-thread/src/ipc.c **** /**
 554:rt-thread/src/ipc.c ****  * This function will detach a mutex from resource management
 555:rt-thread/src/ipc.c ****  *
 556:rt-thread/src/ipc.c ****  * @param mutex the mutex object
 557:rt-thread/src/ipc.c ****  *
 558:rt-thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 559:rt-thread/src/ipc.c ****  *
 560:rt-thread/src/ipc.c ****  * @see rt_mutex_delete
 561:rt-thread/src/ipc.c ****  */
 562:rt-thread/src/ipc.c **** rt_err_t rt_mutex_detach(rt_mutex_t mutex)
 563:rt-thread/src/ipc.c **** {
 834              		.loc 1 563 0
 835              		.cfi_startproc
 836              		@ args = 0, pretend = 0, frame = 0
 837              		@ frame_needed = 0, uses_anonymous_args = 0
 838              	.LVL108:
 839 0000 70B5     		push	{r4, r5, r6, lr}
 840              	.LCFI13:
 841              		.cfi_def_cfa_offset 16
ARM GAS  /tmp/ccOtHhPO.s 			page 28


 842              		.cfi_offset 4, -16
 843              		.cfi_offset 5, -12
 844              		.cfi_offset 6, -8
 845              		.cfi_offset 14, -4
 846 0002 0646     		mov	r6, r0
 564:rt-thread/src/ipc.c ****     /* parameter check */
 565:rt-thread/src/ipc.c ****     RT_ASSERT(mutex != RT_NULL);
 566:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mutex->parent.parent) == RT_Object_Class_Mutex);
 567:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&mutex->parent.parent));
 568:rt-thread/src/ipc.c **** 
 569:rt-thread/src/ipc.c ****     /* wakeup all suspended threads */
 570:rt-thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mutex->parent.suspend_thread));
 847              		.loc 1 570 0
 848 0004 00F11404 		add	r4, r0, #20
 849              	.LVL109:
 850 0008 0CE0     		b	.L58
 851              	.LVL110:
 852              	.L59:
 853              	.LBB137:
 854              	.LBB138:
 166:rt-thread/src/ipc.c **** 
 855              		.loc 1 166 0
 856 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 857              	.LVL111:
 858 000e 0546     		mov	r5, r0
 859              	.LVL112:
 169:rt-thread/src/ipc.c ****         /* set error code to RT_ERROR */
 860              		.loc 1 169 0
 861 0010 2068     		ldr	r0, [r4]
 862              	.LVL113:
 171:rt-thread/src/ipc.c **** 
 863              		.loc 1 171 0
 864 0012 4FF0FF33 		mov	r3, #-1
 865 0016 C361     		str	r3, [r0, #28]
 178:rt-thread/src/ipc.c **** 
 866              		.loc 1 178 0
 867 0018 1438     		subs	r0, r0, #20
 868              	.LVL114:
 869 001a FFF7FEFF 		bl	rt_thread_resume
 870              	.LVL115:
 181:rt-thread/src/ipc.c ****     }
 871              		.loc 1 181 0
 872 001e 2846     		mov	r0, r5
 873 0020 FFF7FEFF 		bl	rt_hw_interrupt_enable
 874              	.LVL116:
 875              	.L58:
 876              	.LBB139:
 877              	.LBB140:
 878              		.loc 2 100 0
 879 0024 2368     		ldr	r3, [r4]
 880              	.LVL117:
 881              	.LBE140:
 882              	.LBE139:
 163:rt-thread/src/ipc.c ****     {
 883              		.loc 1 163 0
 884 0026 9C42     		cmp	r4, r3
 885 0028 EFD1     		bne	.L59
ARM GAS  /tmp/ccOtHhPO.s 			page 29


 886              	.LVL118:
 887              	.LBE138:
 888              	.LBE137:
 571:rt-thread/src/ipc.c **** 
 572:rt-thread/src/ipc.c ****     /* detach semaphore object */
 573:rt-thread/src/ipc.c ****     rt_object_detach(&(mutex->parent.parent));
 889              		.loc 1 573 0
 890 002a 3046     		mov	r0, r6
 891 002c FFF7FEFF 		bl	rt_object_detach
 892              	.LVL119:
 574:rt-thread/src/ipc.c **** 
 575:rt-thread/src/ipc.c ****     return RT_EOK;
 576:rt-thread/src/ipc.c **** }
 893              		.loc 1 576 0
 894 0030 0020     		movs	r0, #0
 895 0032 70BD     		pop	{r4, r5, r6, pc}
 896              		.cfi_endproc
 897              	.LFE28:
 899              		.section	.text.rt_mutex_create,"ax",%progbits
 900              		.align	1
 901              		.global	rt_mutex_create
 902              		.syntax unified
 903              		.thumb
 904              		.thumb_func
 905              		.fpu fpv4-sp-d16
 907              	rt_mutex_create:
 908              	.LFB29:
 577:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mutex_detach);
 578:rt-thread/src/ipc.c **** 
 579:rt-thread/src/ipc.c **** #ifdef RT_USING_HEAP
 580:rt-thread/src/ipc.c **** /**
 581:rt-thread/src/ipc.c ****  * This function will create a mutex from system resource
 582:rt-thread/src/ipc.c ****  *
 583:rt-thread/src/ipc.c ****  * @param name the name of mutex
 584:rt-thread/src/ipc.c ****  * @param flag the flag of mutex
 585:rt-thread/src/ipc.c ****  *
 586:rt-thread/src/ipc.c ****  * @return the created mutex, RT_NULL on error happen
 587:rt-thread/src/ipc.c ****  *
 588:rt-thread/src/ipc.c ****  * @see rt_mutex_init
 589:rt-thread/src/ipc.c ****  */
 590:rt-thread/src/ipc.c **** rt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag)
 591:rt-thread/src/ipc.c **** {
 909              		.loc 1 591 0
 910              		.cfi_startproc
 911              		@ args = 0, pretend = 0, frame = 0
 912              		@ frame_needed = 0, uses_anonymous_args = 0
 913              	.LVL120:
 914 0000 10B5     		push	{r4, lr}
 915              	.LCFI14:
 916              		.cfi_def_cfa_offset 8
 917              		.cfi_offset 4, -8
 918              		.cfi_offset 14, -4
 919 0002 0C46     		mov	r4, r1
 592:rt-thread/src/ipc.c ****     struct rt_mutex *mutex;
 593:rt-thread/src/ipc.c **** 
 594:rt-thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 595:rt-thread/src/ipc.c **** 
ARM GAS  /tmp/ccOtHhPO.s 			page 30


 596:rt-thread/src/ipc.c ****     /* allocate object */
 597:rt-thread/src/ipc.c ****     mutex = (rt_mutex_t)rt_object_allocate(RT_Object_Class_Mutex, name);
 920              		.loc 1 597 0
 921 0004 0146     		mov	r1, r0
 922              	.LVL121:
 923 0006 0320     		movs	r0, #3
 924              	.LVL122:
 925 0008 FFF7FEFF 		bl	rt_object_allocate
 926              	.LVL123:
 598:rt-thread/src/ipc.c ****     if (mutex == RT_NULL)
 927              		.loc 1 598 0
 928 000c 0346     		mov	r3, r0
 929 000e 58B1     		cbz	r0, .L61
 930              	.LVL124:
 931              	.LBB141:
 932              	.LBB142:
  64:rt-thread/src/ipc.c **** 
 933              		.loc 1 64 0
 934 0010 00F11402 		add	r2, r0, #20
 935              	.LVL125:
 936              	.LBB143:
 937              	.LBB144:
  49:rt-thread/include/rtservice.h **** }
 938              		.loc 2 49 0
 939 0014 8261     		str	r2, [r0, #24]
 940 0016 4261     		str	r2, [r0, #20]
 941              	.LVL126:
 942              	.LBE144:
 943              	.LBE143:
 944              	.LBE142:
 945              	.LBE141:
 599:rt-thread/src/ipc.c ****         return mutex;
 600:rt-thread/src/ipc.c **** 
 601:rt-thread/src/ipc.c ****     /* initialize ipc object */
 602:rt-thread/src/ipc.c ****     rt_ipc_object_init(&(mutex->parent));
 603:rt-thread/src/ipc.c **** 
 604:rt-thread/src/ipc.c ****     mutex->value              = 1;
 946              		.loc 1 604 0
 947 0018 0122     		movs	r2, #1
 948 001a 8283     		strh	r2, [r0, #28]	@ movhi
 605:rt-thread/src/ipc.c ****     mutex->owner              = RT_NULL;
 949              		.loc 1 605 0
 950 001c 0022     		movs	r2, #0
 951 001e 0262     		str	r2, [r0, #32]
 606:rt-thread/src/ipc.c ****     mutex->original_priority  = 0xFF;
 952              		.loc 1 606 0
 953 0020 FF21     		movs	r1, #255
 954 0022 8177     		strb	r1, [r0, #30]
 607:rt-thread/src/ipc.c ****     mutex->hold               = 0;
 955              		.loc 1 607 0
 956 0024 C277     		strb	r2, [r0, #31]
 608:rt-thread/src/ipc.c **** 
 609:rt-thread/src/ipc.c ****     /* set flag */
 610:rt-thread/src/ipc.c ****     mutex->parent.parent.flag = flag;
 957              		.loc 1 610 0
 958 0026 4472     		strb	r4, [r0, #9]
 959              	.L61:
ARM GAS  /tmp/ccOtHhPO.s 			page 31


 611:rt-thread/src/ipc.c **** 
 612:rt-thread/src/ipc.c ****     return mutex;
 613:rt-thread/src/ipc.c **** }
 960              		.loc 1 613 0
 961 0028 1846     		mov	r0, r3
 962              	.LVL127:
 963 002a 10BD     		pop	{r4, pc}
 964              		.cfi_endproc
 965              	.LFE29:
 967              		.section	.text.rt_mutex_delete,"ax",%progbits
 968              		.align	1
 969              		.global	rt_mutex_delete
 970              		.syntax unified
 971              		.thumb
 972              		.thumb_func
 973              		.fpu fpv4-sp-d16
 975              	rt_mutex_delete:
 976              	.LFB30:
 614:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mutex_create);
 615:rt-thread/src/ipc.c **** 
 616:rt-thread/src/ipc.c **** /**
 617:rt-thread/src/ipc.c ****  * This function will delete a mutex object and release the memory
 618:rt-thread/src/ipc.c ****  *
 619:rt-thread/src/ipc.c ****  * @param mutex the mutex object
 620:rt-thread/src/ipc.c ****  *
 621:rt-thread/src/ipc.c ****  * @return the error code
 622:rt-thread/src/ipc.c ****  *
 623:rt-thread/src/ipc.c ****  * @see rt_mutex_detach
 624:rt-thread/src/ipc.c ****  */
 625:rt-thread/src/ipc.c **** rt_err_t rt_mutex_delete(rt_mutex_t mutex)
 626:rt-thread/src/ipc.c **** {
 977              		.loc 1 626 0
 978              		.cfi_startproc
 979              		@ args = 0, pretend = 0, frame = 0
 980              		@ frame_needed = 0, uses_anonymous_args = 0
 981              	.LVL128:
 982 0000 70B5     		push	{r4, r5, r6, lr}
 983              	.LCFI15:
 984              		.cfi_def_cfa_offset 16
 985              		.cfi_offset 4, -16
 986              		.cfi_offset 5, -12
 987              		.cfi_offset 6, -8
 988              		.cfi_offset 14, -4
 989 0002 0646     		mov	r6, r0
 627:rt-thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 628:rt-thread/src/ipc.c **** 
 629:rt-thread/src/ipc.c ****     /* parameter check */
 630:rt-thread/src/ipc.c ****     RT_ASSERT(mutex != RT_NULL);
 631:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mutex->parent.parent) == RT_Object_Class_Mutex);
 632:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&mutex->parent.parent) == RT_FALSE);
 633:rt-thread/src/ipc.c **** 
 634:rt-thread/src/ipc.c ****     /* wakeup all suspended threads */
 635:rt-thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mutex->parent.suspend_thread));
 990              		.loc 1 635 0
 991 0004 00F11404 		add	r4, r0, #20
 992              	.LVL129:
 993 0008 0CE0     		b	.L65
ARM GAS  /tmp/ccOtHhPO.s 			page 32


 994              	.LVL130:
 995              	.L66:
 996              	.LBB149:
 997              	.LBB150:
 166:rt-thread/src/ipc.c **** 
 998              		.loc 1 166 0
 999 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 1000              	.LVL131:
 1001 000e 0546     		mov	r5, r0
 1002              	.LVL132:
 169:rt-thread/src/ipc.c ****         /* set error code to RT_ERROR */
 1003              		.loc 1 169 0
 1004 0010 2068     		ldr	r0, [r4]
 1005              	.LVL133:
 171:rt-thread/src/ipc.c **** 
 1006              		.loc 1 171 0
 1007 0012 4FF0FF33 		mov	r3, #-1
 1008 0016 C361     		str	r3, [r0, #28]
 178:rt-thread/src/ipc.c **** 
 1009              		.loc 1 178 0
 1010 0018 1438     		subs	r0, r0, #20
 1011              	.LVL134:
 1012 001a FFF7FEFF 		bl	rt_thread_resume
 1013              	.LVL135:
 181:rt-thread/src/ipc.c ****     }
 1014              		.loc 1 181 0
 1015 001e 2846     		mov	r0, r5
 1016 0020 FFF7FEFF 		bl	rt_hw_interrupt_enable
 1017              	.LVL136:
 1018              	.L65:
 1019              	.LBB151:
 1020              	.LBB152:
 1021              		.loc 2 100 0
 1022 0024 2368     		ldr	r3, [r4]
 1023              	.LVL137:
 1024              	.LBE152:
 1025              	.LBE151:
 163:rt-thread/src/ipc.c ****     {
 1026              		.loc 1 163 0
 1027 0026 9C42     		cmp	r4, r3
 1028 0028 EFD1     		bne	.L66
 1029              	.LVL138:
 1030              	.LBE150:
 1031              	.LBE149:
 636:rt-thread/src/ipc.c **** 
 637:rt-thread/src/ipc.c ****     /* delete mutex object */
 638:rt-thread/src/ipc.c ****     rt_object_delete(&(mutex->parent.parent));
 1032              		.loc 1 638 0
 1033 002a 3046     		mov	r0, r6
 1034 002c FFF7FEFF 		bl	rt_object_delete
 1035              	.LVL139:
 639:rt-thread/src/ipc.c **** 
 640:rt-thread/src/ipc.c ****     return RT_EOK;
 641:rt-thread/src/ipc.c **** }
 1036              		.loc 1 641 0
 1037 0030 0020     		movs	r0, #0
 1038 0032 70BD     		pop	{r4, r5, r6, pc}
ARM GAS  /tmp/ccOtHhPO.s 			page 33


 1039              		.cfi_endproc
 1040              	.LFE30:
 1042              		.section	.text.rt_mutex_take,"ax",%progbits
 1043              		.align	1
 1044              		.global	rt_mutex_take
 1045              		.syntax unified
 1046              		.thumb
 1047              		.thumb_func
 1048              		.fpu fpv4-sp-d16
 1050              	rt_mutex_take:
 1051              	.LFB31:
 642:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mutex_delete);
 643:rt-thread/src/ipc.c **** #endif
 644:rt-thread/src/ipc.c **** 
 645:rt-thread/src/ipc.c **** /**
 646:rt-thread/src/ipc.c ****  * This function will take a mutex, if the mutex is unavailable, the
 647:rt-thread/src/ipc.c ****  * thread shall wait for a specified time.
 648:rt-thread/src/ipc.c ****  *
 649:rt-thread/src/ipc.c ****  * @param mutex the mutex object
 650:rt-thread/src/ipc.c ****  * @param time the waiting time
 651:rt-thread/src/ipc.c ****  *
 652:rt-thread/src/ipc.c ****  * @return the error code
 653:rt-thread/src/ipc.c ****  */
 654:rt-thread/src/ipc.c **** rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time)
 655:rt-thread/src/ipc.c **** {
 1052              		.loc 1 655 0
 1053              		.cfi_startproc
 1054              		@ args = 0, pretend = 0, frame = 8
 1055              		@ frame_needed = 0, uses_anonymous_args = 0
 1056              	.LVL140:
 1057 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1058              	.LCFI16:
 1059              		.cfi_def_cfa_offset 24
 1060              		.cfi_offset 4, -24
 1061              		.cfi_offset 5, -20
 1062              		.cfi_offset 6, -16
 1063              		.cfi_offset 7, -12
 1064              		.cfi_offset 8, -8
 1065              		.cfi_offset 14, -4
 1066 0004 82B0     		sub	sp, sp, #8
 1067              	.LCFI17:
 1068              		.cfi_def_cfa_offset 32
 1069 0006 0646     		mov	r6, r0
 1070 0008 0191     		str	r1, [sp, #4]
 656:rt-thread/src/ipc.c ****     register rt_base_t temp;
 657:rt-thread/src/ipc.c ****     struct rt_thread *thread;
 658:rt-thread/src/ipc.c **** 
 659:rt-thread/src/ipc.c ****     /* this function must not be used in interrupt even if time = 0 */
 660:rt-thread/src/ipc.c ****     RT_DEBUG_IN_THREAD_CONTEXT;
 661:rt-thread/src/ipc.c **** 
 662:rt-thread/src/ipc.c ****     /* parameter check */
 663:rt-thread/src/ipc.c ****     RT_ASSERT(mutex != RT_NULL);
 664:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mutex->parent.parent) == RT_Object_Class_Mutex);
 665:rt-thread/src/ipc.c **** 
 666:rt-thread/src/ipc.c ****     /* get current thread */
 667:rt-thread/src/ipc.c ****     thread = rt_thread_self();
 1071              		.loc 1 667 0
ARM GAS  /tmp/ccOtHhPO.s 			page 34


 1072 000a FFF7FEFF 		bl	rt_thread_self
 1073              	.LVL141:
 1074 000e 0446     		mov	r4, r0
 1075              	.LVL142:
 668:rt-thread/src/ipc.c **** 
 669:rt-thread/src/ipc.c ****     /* disable interrupt */
 670:rt-thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
 1076              		.loc 1 670 0
 1077 0010 FFF7FEFF 		bl	rt_hw_interrupt_disable
 1078              	.LVL143:
 1079 0014 8046     		mov	r8, r0
 1080              	.LVL144:
 671:rt-thread/src/ipc.c **** 
 672:rt-thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mutex->parent.parent)));
 1081              		.loc 1 672 0
 1082 0016 464B     		ldr	r3, .L91
 1083 0018 1B68     		ldr	r3, [r3]
 1084 001a 0BB1     		cbz	r3, .L69
 1085              		.loc 1 672 0 is_stmt 0 discriminator 1
 1086 001c 3046     		mov	r0, r6
 1087              	.LVL145:
 1088 001e 9847     		blx	r3
 1089              	.LVL146:
 1090              	.L69:
 673:rt-thread/src/ipc.c **** 
 674:rt-thread/src/ipc.c ****     RT_DEBUG_LOG(RT_DEBUG_IPC,
 675:rt-thread/src/ipc.c ****                  ("mutex_take: current thread %s, mutex value: %d, hold: %d\n",
 676:rt-thread/src/ipc.c ****                   thread->name, mutex->value, mutex->hold));
 677:rt-thread/src/ipc.c **** 
 678:rt-thread/src/ipc.c ****     /* reset thread error */
 679:rt-thread/src/ipc.c ****     thread->error = RT_EOK;
 1091              		.loc 1 679 0 is_stmt 1
 1092 0020 0023     		movs	r3, #0
 1093 0022 2363     		str	r3, [r4, #48]
 680:rt-thread/src/ipc.c **** 
 681:rt-thread/src/ipc.c ****     if (mutex->owner == thread)
 1094              		.loc 1 681 0
 1095 0024 336A     		ldr	r3, [r6, #32]
 1096 0026 9C42     		cmp	r4, r3
 1097 0028 47D1     		bne	.L70
 682:rt-thread/src/ipc.c ****     {
 683:rt-thread/src/ipc.c ****         /* it's the same thread */
 684:rt-thread/src/ipc.c ****         mutex->hold ++;
 1098              		.loc 1 684 0
 1099 002a F37F     		ldrb	r3, [r6, #31]	@ zero_extendqisi2
 1100 002c 0133     		adds	r3, r3, #1
 1101 002e F377     		strb	r3, [r6, #31]
 1102 0030 08E0     		b	.L71
 1103              	.L87:
 685:rt-thread/src/ipc.c ****     }
 686:rt-thread/src/ipc.c ****     else
 687:rt-thread/src/ipc.c ****     {
 688:rt-thread/src/ipc.c **** __again:
 689:rt-thread/src/ipc.c ****         /* The value of mutex is 1 in initial status. Therefore, if the
 690:rt-thread/src/ipc.c ****          * value is great than 0, it indicates the mutex is avaible.
 691:rt-thread/src/ipc.c ****          */
 692:rt-thread/src/ipc.c ****         if (mutex->value > 0)
ARM GAS  /tmp/ccOtHhPO.s 			page 35


 693:rt-thread/src/ipc.c ****         {
 694:rt-thread/src/ipc.c ****             /* mutex is available */
 695:rt-thread/src/ipc.c ****             mutex->value --;
 1104              		.loc 1 695 0
 1105 0032 013B     		subs	r3, r3, #1
 1106 0034 B383     		strh	r3, [r6, #28]	@ movhi
 696:rt-thread/src/ipc.c **** 
 697:rt-thread/src/ipc.c ****             /* set mutex owner and original priority */
 698:rt-thread/src/ipc.c ****             mutex->owner             = thread;
 1107              		.loc 1 698 0
 1108 0036 3462     		str	r4, [r6, #32]
 699:rt-thread/src/ipc.c ****             mutex->original_priority = thread->current_priority;
 1109              		.loc 1 699 0
 1110 0038 94F83530 		ldrb	r3, [r4, #53]	@ zero_extendqisi2
 1111 003c B377     		strb	r3, [r6, #30]
 700:rt-thread/src/ipc.c ****             mutex->hold ++;
 1112              		.loc 1 700 0
 1113 003e F37F     		ldrb	r3, [r6, #31]	@ zero_extendqisi2
 1114 0040 0133     		adds	r3, r3, #1
 1115 0042 F377     		strb	r3, [r6, #31]
 1116              	.L71:
 701:rt-thread/src/ipc.c ****         }
 702:rt-thread/src/ipc.c ****         else
 703:rt-thread/src/ipc.c ****         {
 704:rt-thread/src/ipc.c ****             /* no waiting, return with timeout */
 705:rt-thread/src/ipc.c ****             if (time == 0)
 706:rt-thread/src/ipc.c ****             {
 707:rt-thread/src/ipc.c ****                 /* set error as timeout */
 708:rt-thread/src/ipc.c ****                 thread->error = -RT_ETIMEOUT;
 709:rt-thread/src/ipc.c **** 
 710:rt-thread/src/ipc.c ****                 /* enable interrupt */
 711:rt-thread/src/ipc.c ****                 rt_hw_interrupt_enable(temp);
 712:rt-thread/src/ipc.c **** 
 713:rt-thread/src/ipc.c ****                 return -RT_ETIMEOUT;
 714:rt-thread/src/ipc.c ****             }
 715:rt-thread/src/ipc.c ****             else
 716:rt-thread/src/ipc.c ****             {
 717:rt-thread/src/ipc.c ****                 /* mutex is unavailable, push to suspend list */
 718:rt-thread/src/ipc.c ****                 RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_take: suspend thread: %s\n",
 719:rt-thread/src/ipc.c ****                                             thread->name));
 720:rt-thread/src/ipc.c **** 
 721:rt-thread/src/ipc.c ****                 /* change the owner thread priority of mutex */
 722:rt-thread/src/ipc.c ****                 if (thread->current_priority < mutex->owner->current_priority)
 723:rt-thread/src/ipc.c ****                 {
 724:rt-thread/src/ipc.c ****                     /* change the owner thread priority */
 725:rt-thread/src/ipc.c ****                     rt_thread_control(mutex->owner,
 726:rt-thread/src/ipc.c ****                                       RT_THREAD_CTRL_CHANGE_PRIORITY,
 727:rt-thread/src/ipc.c ****                                       &thread->current_priority);
 728:rt-thread/src/ipc.c ****                 }
 729:rt-thread/src/ipc.c **** 
 730:rt-thread/src/ipc.c ****                 /* suspend current thread */
 731:rt-thread/src/ipc.c ****                 rt_ipc_list_suspend(&(mutex->parent.suspend_thread),
 732:rt-thread/src/ipc.c ****                                     thread,
 733:rt-thread/src/ipc.c ****                                     mutex->parent.parent.flag);
 734:rt-thread/src/ipc.c **** 
 735:rt-thread/src/ipc.c ****                 /* has waiting time, start thread timer */
 736:rt-thread/src/ipc.c ****                 if (time > 0)
ARM GAS  /tmp/ccOtHhPO.s 			page 36


 737:rt-thread/src/ipc.c ****                 {
 738:rt-thread/src/ipc.c ****                     RT_DEBUG_LOG(RT_DEBUG_IPC,
 739:rt-thread/src/ipc.c ****                                  ("mutex_take: start the timer of thread:%s\n",
 740:rt-thread/src/ipc.c ****                                   thread->name));
 741:rt-thread/src/ipc.c **** 
 742:rt-thread/src/ipc.c ****                     /* reset the timeout of thread timer and start it */
 743:rt-thread/src/ipc.c ****                     rt_timer_control(&(thread->thread_timer),
 744:rt-thread/src/ipc.c ****                                      RT_TIMER_CTRL_SET_TIME,
 745:rt-thread/src/ipc.c ****                                      &time);
 746:rt-thread/src/ipc.c ****                     rt_timer_start(&(thread->thread_timer));
 747:rt-thread/src/ipc.c ****                 }
 748:rt-thread/src/ipc.c **** 
 749:rt-thread/src/ipc.c ****                 /* enable interrupt */
 750:rt-thread/src/ipc.c ****                 rt_hw_interrupt_enable(temp);
 751:rt-thread/src/ipc.c **** 
 752:rt-thread/src/ipc.c ****                 /* do schedule */
 753:rt-thread/src/ipc.c ****                 rt_schedule();
 754:rt-thread/src/ipc.c **** 
 755:rt-thread/src/ipc.c ****                 if (thread->error != RT_EOK)
 756:rt-thread/src/ipc.c ****                 {
 757:rt-thread/src/ipc.c ****                     /* interrupt by signal, try it again */
 758:rt-thread/src/ipc.c ****                     if (thread->error == -RT_EINTR) goto __again;
 759:rt-thread/src/ipc.c **** 
 760:rt-thread/src/ipc.c ****                     /* return error */
 761:rt-thread/src/ipc.c ****                     return thread->error;
 762:rt-thread/src/ipc.c ****                 }
 763:rt-thread/src/ipc.c ****                 else
 764:rt-thread/src/ipc.c ****                 {
 765:rt-thread/src/ipc.c ****                     /* the mutex is taken successfully. */
 766:rt-thread/src/ipc.c ****                     /* disable interrupt */
 767:rt-thread/src/ipc.c ****                     temp = rt_hw_interrupt_disable();
 768:rt-thread/src/ipc.c ****                 }
 769:rt-thread/src/ipc.c ****             }
 770:rt-thread/src/ipc.c ****         }
 771:rt-thread/src/ipc.c ****     }
 772:rt-thread/src/ipc.c **** 
 773:rt-thread/src/ipc.c ****     /* enable interrupt */
 774:rt-thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
 1117              		.loc 1 774 0
 1118 0044 4046     		mov	r0, r8
 1119 0046 FFF7FEFF 		bl	rt_hw_interrupt_enable
 1120              	.LVL147:
 775:rt-thread/src/ipc.c **** 
 776:rt-thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mutex->parent.parent)));
 1121              		.loc 1 776 0
 1122 004a 3A4B     		ldr	r3, .L91+4
 1123 004c 1B68     		ldr	r3, [r3]
 1124 004e 002B     		cmp	r3, #0
 1125 0050 6CD0     		beq	.L85
 1126              		.loc 1 776 0 is_stmt 0 discriminator 1
 1127 0052 3046     		mov	r0, r6
 1128 0054 9847     		blx	r3
 1129              	.LVL148:
 777:rt-thread/src/ipc.c **** 
 778:rt-thread/src/ipc.c ****     return RT_EOK;
 1130              		.loc 1 778 0 is_stmt 1 discriminator 1
 1131 0056 0020     		movs	r0, #0
ARM GAS  /tmp/ccOtHhPO.s 			page 37


 1132              	.L68:
 779:rt-thread/src/ipc.c **** }
 1133              		.loc 1 779 0
 1134 0058 02B0     		add	sp, sp, #8
 1135              	.LCFI18:
 1136              		.cfi_remember_state
 1137              		.cfi_def_cfa_offset 24
 1138              		@ sp needed
 1139 005a BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1140              	.LVL149:
 1141              	.L88:
 1142              	.LCFI19:
 1143              		.cfi_restore_state
 708:rt-thread/src/ipc.c **** 
 1144              		.loc 1 708 0
 1145 005e 6FF00105 		mvn	r5, #1
 1146 0062 2563     		str	r5, [r4, #48]
 711:rt-thread/src/ipc.c **** 
 1147              		.loc 1 711 0
 1148 0064 4046     		mov	r0, r8
 1149 0066 FFF7FEFF 		bl	rt_hw_interrupt_enable
 1150              	.LVL150:
 713:rt-thread/src/ipc.c ****             }
 1151              		.loc 1 713 0
 1152 006a 2846     		mov	r0, r5
 1153 006c F4E7     		b	.L68
 1154              	.L89:
 725:rt-thread/src/ipc.c ****                                       RT_THREAD_CTRL_CHANGE_PRIORITY,
 1155              		.loc 1 725 0
 1156 006e 04F13502 		add	r2, r4, #53
 1157 0072 0221     		movs	r1, #2
 1158 0074 FFF7FEFF 		bl	rt_thread_control
 1159              	.LVL151:
 1160 0078 2CE0     		b	.L75
 1161              	.LVL152:
 1162              	.L77:
 1163              	.LBB162:
 1164              	.LBB163:
  90:rt-thread/src/ipc.c ****         break;
 1165              		.loc 1 90 0
 1166 007a 04F11403 		add	r3, r4, #20
 1167              	.LVL153:
 1168              	.LBB164:
 1169              	.LBB165:
  75:rt-thread/include/rtservice.h ****     n->prev = l->prev;
 1170              		.loc 2 75 0
 1171 007e 6A68     		ldr	r2, [r5, #4]
 1172 0080 1360     		str	r3, [r2]
  76:rt-thread/include/rtservice.h **** 
 1173              		.loc 2 76 0
 1174 0082 6A68     		ldr	r2, [r5, #4]
 1175 0084 A261     		str	r2, [r4, #24]
  78:rt-thread/include/rtservice.h ****     n->next = l;
 1176              		.loc 2 78 0
 1177 0086 6B60     		str	r3, [r5, #4]
  79:rt-thread/include/rtservice.h **** }
 1178              		.loc 2 79 0
ARM GAS  /tmp/ccOtHhPO.s 			page 38


 1179 0088 6561     		str	r5, [r4, #20]
 1180              	.LVL154:
 1181              	.L76:
 1182              	.LBE165:
 1183              	.LBE164:
 1184              	.LBE163:
 1185              	.LBE162:
 736:rt-thread/src/ipc.c ****                 {
 1186              		.loc 1 736 0
 1187 008a 019B     		ldr	r3, [sp, #4]
 1188 008c 002B     		cmp	r3, #0
 1189 008e 09DD     		ble	.L83
 743:rt-thread/src/ipc.c ****                                      RT_TIMER_CTRL_SET_TIME,
 1190              		.loc 1 743 0
 1191 0090 04F14C05 		add	r5, r4, #76
 1192 0094 01AA     		add	r2, sp, #4
 1193 0096 0021     		movs	r1, #0
 1194 0098 2846     		mov	r0, r5
 1195 009a FFF7FEFF 		bl	rt_timer_control
 1196              	.LVL155:
 746:rt-thread/src/ipc.c ****                 }
 1197              		.loc 1 746 0
 1198 009e 2846     		mov	r0, r5
 1199 00a0 FFF7FEFF 		bl	rt_timer_start
 1200              	.LVL156:
 1201              	.L83:
 750:rt-thread/src/ipc.c **** 
 1202              		.loc 1 750 0
 1203 00a4 4046     		mov	r0, r8
 1204 00a6 FFF7FEFF 		bl	rt_hw_interrupt_enable
 1205              	.LVL157:
 753:rt-thread/src/ipc.c **** 
 1206              		.loc 1 753 0
 1207 00aa FFF7FEFF 		bl	rt_schedule
 1208              	.LVL158:
 755:rt-thread/src/ipc.c ****                 {
 1209              		.loc 1 755 0
 1210 00ae 206B     		ldr	r0, [r4, #48]
 1211 00b0 0028     		cmp	r0, #0
 1212 00b2 37D0     		beq	.L84
 758:rt-thread/src/ipc.c **** 
 1213              		.loc 1 758 0
 1214 00b4 10F1090F 		cmn	r0, #9
 1215 00b8 CED1     		bne	.L68
 1216              	.L70:
 692:rt-thread/src/ipc.c ****         {
 1217              		.loc 1 692 0
 1218 00ba B38B     		ldrh	r3, [r6, #28]
 1219 00bc 002B     		cmp	r3, #0
 1220 00be B8D1     		bne	.L87
 705:rt-thread/src/ipc.c ****             {
 1221              		.loc 1 705 0
 1222 00c0 019B     		ldr	r3, [sp, #4]
 1223 00c2 002B     		cmp	r3, #0
 1224 00c4 CBD0     		beq	.L88
 722:rt-thread/src/ipc.c ****                 {
 1225              		.loc 1 722 0
ARM GAS  /tmp/ccOtHhPO.s 			page 39


 1226 00c6 94F83520 		ldrb	r2, [r4, #53]	@ zero_extendqisi2
 1227 00ca 306A     		ldr	r0, [r6, #32]
 1228 00cc 90F83530 		ldrb	r3, [r0, #53]	@ zero_extendqisi2
 1229 00d0 9A42     		cmp	r2, r3
 1230 00d2 CCD3     		bcc	.L89
 1231              	.L75:
 731:rt-thread/src/ipc.c ****                                     thread,
 1232              		.loc 1 731 0
 1233 00d4 06F11405 		add	r5, r6, #20
 1234 00d8 777A     		ldrb	r7, [r6, #9]	@ zero_extendqisi2
 1235              	.LVL159:
 1236              	.LBB172:
 1237              	.LBB171:
  85:rt-thread/src/ipc.c **** 
 1238              		.loc 1 85 0
 1239 00da 2046     		mov	r0, r4
 1240 00dc FFF7FEFF 		bl	rt_thread_suspend
 1241              	.LVL160:
  87:rt-thread/src/ipc.c ****     {
 1242              		.loc 1 87 0
 1243 00e0 002F     		cmp	r7, #0
 1244 00e2 CAD0     		beq	.L77
 1245 00e4 012F     		cmp	r7, #1
 1246 00e6 D0D1     		bne	.L76
 1247              	.LBB166:
  99:rt-thread/src/ipc.c ****             {
 1248              		.loc 1 99 0
 1249 00e8 7369     		ldr	r3, [r6, #20]
 1250              	.LVL161:
 1251              	.L79:
 1252 00ea 9D42     		cmp	r5, r3
 1253 00ec 0FD0     		beq	.L81
 1254              	.LVL162:
 104:rt-thread/src/ipc.c ****                 {
 1255              		.loc 1 104 0
 1256 00ee 94F83510 		ldrb	r1, [r4, #53]	@ zero_extendqisi2
 1257 00f2 93F82120 		ldrb	r2, [r3, #33]	@ zero_extendqisi2
 1258 00f6 9142     		cmp	r1, r2
 1259 00f8 01D3     		bcc	.L90
  99:rt-thread/src/ipc.c ****             {
 1260              		.loc 1 99 0
 1261 00fa 1B68     		ldr	r3, [r3]
 1262              	.LVL163:
 1263 00fc F5E7     		b	.L79
 1264              	.LVL164:
 1265              	.L90:
 107:rt-thread/src/ipc.c ****                     break;
 1266              		.loc 1 107 0
 1267 00fe 04F11402 		add	r2, r4, #20
 1268              	.LVL165:
 1269              	.LBB167:
 1270              	.LBB168:
  75:rt-thread/include/rtservice.h ****     n->prev = l->prev;
 1271              		.loc 2 75 0
 1272 0102 5968     		ldr	r1, [r3, #4]
 1273 0104 0A60     		str	r2, [r1]
  76:rt-thread/include/rtservice.h **** 
ARM GAS  /tmp/ccOtHhPO.s 			page 40


 1274              		.loc 2 76 0
 1275 0106 5968     		ldr	r1, [r3, #4]
 1276 0108 A161     		str	r1, [r4, #24]
  78:rt-thread/include/rtservice.h ****     n->next = l;
 1277              		.loc 2 78 0
 1278 010a 5A60     		str	r2, [r3, #4]
  79:rt-thread/include/rtservice.h **** }
 1279              		.loc 2 79 0
 1280 010c 6361     		str	r3, [r4, #20]
 1281              	.LVL166:
 1282              	.L81:
 1283              	.LBE168:
 1284              	.LBE167:
 116:rt-thread/src/ipc.c ****                 rt_list_insert_before(list, &(thread->tlist));
 1285              		.loc 1 116 0
 1286 010e 9D42     		cmp	r5, r3
 1287 0110 BBD1     		bne	.L76
 117:rt-thread/src/ipc.c ****         }
 1288              		.loc 1 117 0
 1289 0112 04F11403 		add	r3, r4, #20
 1290              	.LVL167:
 1291              	.LBB169:
 1292              	.LBB170:
  75:rt-thread/include/rtservice.h ****     n->prev = l->prev;
 1293              		.loc 2 75 0
 1294 0116 6A68     		ldr	r2, [r5, #4]
 1295 0118 1360     		str	r3, [r2]
  76:rt-thread/include/rtservice.h **** 
 1296              		.loc 2 76 0
 1297 011a 6A68     		ldr	r2, [r5, #4]
 1298 011c A261     		str	r2, [r4, #24]
  78:rt-thread/include/rtservice.h ****     n->next = l;
 1299              		.loc 2 78 0
 1300 011e 6B60     		str	r3, [r5, #4]
  79:rt-thread/include/rtservice.h **** }
 1301              		.loc 2 79 0
 1302 0120 6561     		str	r5, [r4, #20]
 1303 0122 B2E7     		b	.L76
 1304              	.LVL168:
 1305              	.L84:
 1306              	.LBE170:
 1307              	.LBE169:
 1308              	.LBE166:
 1309              	.LBE171:
 1310              	.LBE172:
 767:rt-thread/src/ipc.c ****                 }
 1311              		.loc 1 767 0
 1312 0124 FFF7FEFF 		bl	rt_hw_interrupt_disable
 1313              	.LVL169:
 1314 0128 8046     		mov	r8, r0
 1315              	.LVL170:
 1316 012a 8BE7     		b	.L71
 1317              	.LVL171:
 1318              	.L85:
 778:rt-thread/src/ipc.c **** }
 1319              		.loc 1 778 0
 1320 012c 0020     		movs	r0, #0
ARM GAS  /tmp/ccOtHhPO.s 			page 41


 1321 012e 93E7     		b	.L68
 1322              	.L92:
 1323              		.align	2
 1324              	.L91:
 1325 0130 00000000 		.word	rt_object_trytake_hook
 1326 0134 00000000 		.word	rt_object_take_hook
 1327              		.cfi_endproc
 1328              	.LFE31:
 1330              		.section	.text.rt_mutex_release,"ax",%progbits
 1331              		.align	1
 1332              		.global	rt_mutex_release
 1333              		.syntax unified
 1334              		.thumb
 1335              		.thumb_func
 1336              		.fpu fpv4-sp-d16
 1338              	rt_mutex_release:
 1339              	.LFB32:
 780:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mutex_take);
 781:rt-thread/src/ipc.c **** 
 782:rt-thread/src/ipc.c **** /**
 783:rt-thread/src/ipc.c ****  * This function will release a mutex, if there are threads suspended on mutex,
 784:rt-thread/src/ipc.c ****  * it will be waked up.
 785:rt-thread/src/ipc.c ****  *
 786:rt-thread/src/ipc.c ****  * @param mutex the mutex object
 787:rt-thread/src/ipc.c ****  *
 788:rt-thread/src/ipc.c ****  * @return the error code
 789:rt-thread/src/ipc.c ****  */
 790:rt-thread/src/ipc.c **** rt_err_t rt_mutex_release(rt_mutex_t mutex)
 791:rt-thread/src/ipc.c **** {
 1340              		.loc 1 791 0
 1341              		.cfi_startproc
 1342              		@ args = 0, pretend = 0, frame = 0
 1343              		@ frame_needed = 0, uses_anonymous_args = 0
 1344              	.LVL172:
 1345 0000 70B5     		push	{r4, r5, r6, lr}
 1346              	.LCFI20:
 1347              		.cfi_def_cfa_offset 16
 1348              		.cfi_offset 4, -16
 1349              		.cfi_offset 5, -12
 1350              		.cfi_offset 6, -8
 1351              		.cfi_offset 14, -4
 1352 0002 0446     		mov	r4, r0
 1353              	.LVL173:
 792:rt-thread/src/ipc.c ****     register rt_base_t temp;
 793:rt-thread/src/ipc.c ****     struct rt_thread *thread;
 794:rt-thread/src/ipc.c ****     rt_bool_t need_schedule;
 795:rt-thread/src/ipc.c **** 
 796:rt-thread/src/ipc.c ****     /* parameter check */
 797:rt-thread/src/ipc.c ****     RT_ASSERT(mutex != RT_NULL);
 798:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mutex->parent.parent) == RT_Object_Class_Mutex);
 799:rt-thread/src/ipc.c **** 
 800:rt-thread/src/ipc.c ****     need_schedule = RT_FALSE;
 801:rt-thread/src/ipc.c **** 
 802:rt-thread/src/ipc.c ****     /* only thread could release mutex because we need test the ownership */
 803:rt-thread/src/ipc.c ****     RT_DEBUG_IN_THREAD_CONTEXT;
 804:rt-thread/src/ipc.c **** 
 805:rt-thread/src/ipc.c ****     /* get current thread */
ARM GAS  /tmp/ccOtHhPO.s 			page 42


 806:rt-thread/src/ipc.c ****     thread = rt_thread_self();
 1354              		.loc 1 806 0
 1355 0004 FFF7FEFF 		bl	rt_thread_self
 1356              	.LVL174:
 1357 0008 0646     		mov	r6, r0
 1358              	.LVL175:
 807:rt-thread/src/ipc.c **** 
 808:rt-thread/src/ipc.c ****     /* disable interrupt */
 809:rt-thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
 1359              		.loc 1 809 0
 1360 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 1361              	.LVL176:
 1362 000e 0546     		mov	r5, r0
 1363              	.LVL177:
 810:rt-thread/src/ipc.c **** 
 811:rt-thread/src/ipc.c ****     RT_DEBUG_LOG(RT_DEBUG_IPC,
 812:rt-thread/src/ipc.c ****                  ("mutex_release:current thread %s, mutex value: %d, hold: %d\n",
 813:rt-thread/src/ipc.c ****                   thread->name, mutex->value, mutex->hold));
 814:rt-thread/src/ipc.c **** 
 815:rt-thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mutex->parent.parent)));
 1364              		.loc 1 815 0
 1365 0010 224B     		ldr	r3, .L105
 1366 0012 1B68     		ldr	r3, [r3]
 1367 0014 0BB1     		cbz	r3, .L94
 1368              		.loc 1 815 0 is_stmt 0 discriminator 1
 1369 0016 2046     		mov	r0, r4
 1370              	.LVL178:
 1371 0018 9847     		blx	r3
 1372              	.LVL179:
 1373              	.L94:
 816:rt-thread/src/ipc.c **** 
 817:rt-thread/src/ipc.c ****     /* mutex only can be released by owner */
 818:rt-thread/src/ipc.c ****     if (thread != mutex->owner)
 1374              		.loc 1 818 0 is_stmt 1
 1375 001a 206A     		ldr	r0, [r4, #32]
 1376 001c 8642     		cmp	r6, r0
 1377 001e 20D1     		bne	.L103
 819:rt-thread/src/ipc.c ****     {
 820:rt-thread/src/ipc.c ****         thread->error = -RT_ERROR;
 821:rt-thread/src/ipc.c **** 
 822:rt-thread/src/ipc.c ****         /* enable interrupt */
 823:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
 824:rt-thread/src/ipc.c **** 
 825:rt-thread/src/ipc.c ****         return -RT_ERROR;
 826:rt-thread/src/ipc.c ****     }
 827:rt-thread/src/ipc.c **** 
 828:rt-thread/src/ipc.c ****     /* decrease hold */
 829:rt-thread/src/ipc.c ****     mutex->hold --;
 1378              		.loc 1 829 0
 1379 0020 E37F     		ldrb	r3, [r4, #31]	@ zero_extendqisi2
 1380 0022 013B     		subs	r3, r3, #1
 1381 0024 DBB2     		uxtb	r3, r3
 1382 0026 E377     		strb	r3, [r4, #31]
 830:rt-thread/src/ipc.c ****     /* if no hold */
 831:rt-thread/src/ipc.c ****     if (mutex->hold == 0)
 1383              		.loc 1 831 0
 1384 0028 63BB     		cbnz	r3, .L100
ARM GAS  /tmp/ccOtHhPO.s 			page 43


 832:rt-thread/src/ipc.c ****     {
 833:rt-thread/src/ipc.c ****         /* change the owner thread to original priority */
 834:rt-thread/src/ipc.c ****         if (mutex->original_priority != mutex->owner->current_priority)
 1385              		.loc 1 834 0
 1386 002a A27F     		ldrb	r2, [r4, #30]	@ zero_extendqisi2
 1387 002c 90F83530 		ldrb	r3, [r0, #53]	@ zero_extendqisi2
 1388 0030 9A42     		cmp	r2, r3
 1389 0032 04D0     		beq	.L98
 835:rt-thread/src/ipc.c ****         {
 836:rt-thread/src/ipc.c ****             rt_thread_control(mutex->owner,
 1390              		.loc 1 836 0
 1391 0034 04F11E02 		add	r2, r4, #30
 1392 0038 0221     		movs	r1, #2
 1393 003a FFF7FEFF 		bl	rt_thread_control
 1394              	.LVL180:
 1395              	.L98:
 837:rt-thread/src/ipc.c ****                               RT_THREAD_CTRL_CHANGE_PRIORITY,
 838:rt-thread/src/ipc.c ****                               &(mutex->original_priority));
 839:rt-thread/src/ipc.c ****         }
 840:rt-thread/src/ipc.c **** 
 841:rt-thread/src/ipc.c ****         /* wakeup suspended thread */
 842:rt-thread/src/ipc.c ****         if (!rt_list_isempty(&mutex->parent.suspend_thread))
 1396              		.loc 1 842 0
 1397 003e 04F11403 		add	r3, r4, #20
 1398              	.LBB173:
 1399              	.LBB174:
 1400              		.loc 2 100 0
 1401 0042 6269     		ldr	r2, [r4, #20]
 1402              	.LBE174:
 1403              	.LBE173:
 1404              		.loc 1 842 0
 1405 0044 9342     		cmp	r3, r2
 1406 0046 14D0     		beq	.L99
 843:rt-thread/src/ipc.c ****         {
 844:rt-thread/src/ipc.c ****             /* get suspended thread */
 845:rt-thread/src/ipc.c ****             thread = rt_list_entry(mutex->parent.suspend_thread.next,
 1407              		.loc 1 845 0
 1408 0048 A2F11400 		sub	r0, r2, #20
 1409              	.LVL181:
 846:rt-thread/src/ipc.c ****                                    struct rt_thread,
 847:rt-thread/src/ipc.c ****                                    tlist);
 848:rt-thread/src/ipc.c **** 
 849:rt-thread/src/ipc.c ****             RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_release: resume thread: %s\n",
 850:rt-thread/src/ipc.c ****                                         thread->name));
 851:rt-thread/src/ipc.c **** 
 852:rt-thread/src/ipc.c ****             /* set new owner and priority */
 853:rt-thread/src/ipc.c ****             mutex->owner             = thread;
 1410              		.loc 1 853 0
 1411 004c 2062     		str	r0, [r4, #32]
 854:rt-thread/src/ipc.c ****             mutex->original_priority = thread->current_priority;
 1412              		.loc 1 854 0
 1413 004e 92F82130 		ldrb	r3, [r2, #33]	@ zero_extendqisi2
 1414 0052 A377     		strb	r3, [r4, #30]
 855:rt-thread/src/ipc.c ****             mutex->hold ++;
 1415              		.loc 1 855 0
 1416 0054 E37F     		ldrb	r3, [r4, #31]	@ zero_extendqisi2
 1417 0056 0133     		adds	r3, r3, #1
ARM GAS  /tmp/ccOtHhPO.s 			page 44


 1418 0058 E377     		strb	r3, [r4, #31]
 1419              	.LVL182:
 1420              	.LBB175:
 1421              	.LBB176:
 144:rt-thread/src/ipc.c **** 
 1422              		.loc 1 144 0
 1423 005a FFF7FEFF 		bl	rt_thread_resume
 1424              	.LVL183:
 1425              	.LBE176:
 1426              	.LBE175:
 856:rt-thread/src/ipc.c **** 
 857:rt-thread/src/ipc.c ****             /* resume thread */
 858:rt-thread/src/ipc.c ****             rt_ipc_list_resume(&(mutex->parent.suspend_thread));
 859:rt-thread/src/ipc.c **** 
 860:rt-thread/src/ipc.c ****             need_schedule = RT_TRUE;
 1427              		.loc 1 860 0
 1428 005e 0124     		movs	r4, #1
 1429              	.LVL184:
 1430 0060 11E0     		b	.L97
 1431              	.LVL185:
 1432              	.L103:
 820:rt-thread/src/ipc.c **** 
 1433              		.loc 1 820 0
 1434 0062 4FF0FF34 		mov	r4, #-1
 1435              	.LVL186:
 1436 0066 3463     		str	r4, [r6, #48]
 823:rt-thread/src/ipc.c **** 
 1437              		.loc 1 823 0
 1438 0068 2846     		mov	r0, r5
 1439 006a FFF7FEFF 		bl	rt_hw_interrupt_enable
 1440              	.LVL187:
 825:rt-thread/src/ipc.c ****     }
 1441              		.loc 1 825 0
 1442 006e 2046     		mov	r0, r4
 1443 0070 70BD     		pop	{r4, r5, r6, pc}
 1444              	.LVL188:
 1445              	.L99:
 861:rt-thread/src/ipc.c ****         }
 862:rt-thread/src/ipc.c ****         else
 863:rt-thread/src/ipc.c ****         {
 864:rt-thread/src/ipc.c ****             /* increase value */
 865:rt-thread/src/ipc.c ****             mutex->value ++;
 1446              		.loc 1 865 0
 1447 0072 A38B     		ldrh	r3, [r4, #28]
 1448 0074 0133     		adds	r3, r3, #1
 1449 0076 A383     		strh	r3, [r4, #28]	@ movhi
 866:rt-thread/src/ipc.c **** 
 867:rt-thread/src/ipc.c ****             /* clear owner */
 868:rt-thread/src/ipc.c ****             mutex->owner             = RT_NULL;
 1450              		.loc 1 868 0
 1451 0078 0023     		movs	r3, #0
 1452 007a 2362     		str	r3, [r4, #32]
 869:rt-thread/src/ipc.c ****             mutex->original_priority = 0xff;
 1453              		.loc 1 869 0
 1454 007c FF22     		movs	r2, #255
 1455 007e A277     		strb	r2, [r4, #30]
 800:rt-thread/src/ipc.c **** 
ARM GAS  /tmp/ccOtHhPO.s 			page 45


 1456              		.loc 1 800 0
 1457 0080 1C46     		mov	r4, r3
 1458              	.LVL189:
 1459 0082 00E0     		b	.L97
 1460              	.LVL190:
 1461              	.L100:
 1462 0084 0024     		movs	r4, #0
 1463              	.LVL191:
 1464              	.L97:
 870:rt-thread/src/ipc.c ****         }
 871:rt-thread/src/ipc.c ****     }
 872:rt-thread/src/ipc.c **** 
 873:rt-thread/src/ipc.c ****     /* enable interrupt */
 874:rt-thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
 1465              		.loc 1 874 0
 1466 0086 2846     		mov	r0, r5
 1467 0088 FFF7FEFF 		bl	rt_hw_interrupt_enable
 1468              	.LVL192:
 875:rt-thread/src/ipc.c **** 
 876:rt-thread/src/ipc.c ****     /* perform a schedule */
 877:rt-thread/src/ipc.c ****     if (need_schedule == RT_TRUE)
 1469              		.loc 1 877 0
 1470 008c 0CB9     		cbnz	r4, .L104
 878:rt-thread/src/ipc.c ****         rt_schedule();
 879:rt-thread/src/ipc.c **** 
 880:rt-thread/src/ipc.c ****     return RT_EOK;
 1471              		.loc 1 880 0
 1472 008e 0020     		movs	r0, #0
 881:rt-thread/src/ipc.c **** }
 1473              		.loc 1 881 0
 1474 0090 70BD     		pop	{r4, r5, r6, pc}
 1475              	.LVL193:
 1476              	.L104:
 878:rt-thread/src/ipc.c ****         rt_schedule();
 1477              		.loc 1 878 0
 1478 0092 FFF7FEFF 		bl	rt_schedule
 1479              	.LVL194:
 880:rt-thread/src/ipc.c **** }
 1480              		.loc 1 880 0
 1481 0096 0020     		movs	r0, #0
 1482 0098 70BD     		pop	{r4, r5, r6, pc}
 1483              	.LVL195:
 1484              	.L106:
 1485 009a 00BF     		.align	2
 1486              	.L105:
 1487 009c 00000000 		.word	rt_object_put_hook
 1488              		.cfi_endproc
 1489              	.LFE32:
 1491              		.section	.text.rt_mutex_control,"ax",%progbits
 1492              		.align	1
 1493              		.global	rt_mutex_control
 1494              		.syntax unified
 1495              		.thumb
 1496              		.thumb_func
 1497              		.fpu fpv4-sp-d16
 1499              	rt_mutex_control:
 1500              	.LFB33:
ARM GAS  /tmp/ccOtHhPO.s 			page 46


 882:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mutex_release);
 883:rt-thread/src/ipc.c **** 
 884:rt-thread/src/ipc.c **** /**
 885:rt-thread/src/ipc.c ****  * This function can get or set some extra attributions of a mutex object.
 886:rt-thread/src/ipc.c ****  *
 887:rt-thread/src/ipc.c ****  * @param mutex the mutex object
 888:rt-thread/src/ipc.c ****  * @param cmd the execution command
 889:rt-thread/src/ipc.c ****  * @param arg the execution argument
 890:rt-thread/src/ipc.c ****  *
 891:rt-thread/src/ipc.c ****  * @return the error code
 892:rt-thread/src/ipc.c ****  */
 893:rt-thread/src/ipc.c **** rt_err_t rt_mutex_control(rt_mutex_t mutex, int cmd, void *arg)
 894:rt-thread/src/ipc.c **** {
 1501              		.loc 1 894 0
 1502              		.cfi_startproc
 1503              		@ args = 0, pretend = 0, frame = 0
 1504              		@ frame_needed = 0, uses_anonymous_args = 0
 1505              		@ link register save eliminated.
 1506              	.LVL196:
 895:rt-thread/src/ipc.c ****     /* parameter check */
 896:rt-thread/src/ipc.c ****     RT_ASSERT(mutex != RT_NULL);
 897:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mutex->parent.parent) == RT_Object_Class_Mutex);
 898:rt-thread/src/ipc.c **** 
 899:rt-thread/src/ipc.c ****     return -RT_ERROR;
 900:rt-thread/src/ipc.c **** }
 1507              		.loc 1 900 0
 1508 0000 4FF0FF30 		mov	r0, #-1
 1509              	.LVL197:
 1510 0004 7047     		bx	lr
 1511              		.cfi_endproc
 1512              	.LFE33:
 1514              		.section	.text.rt_event_init,"ax",%progbits
 1515              		.align	1
 1516              		.global	rt_event_init
 1517              		.syntax unified
 1518              		.thumb
 1519              		.thumb_func
 1520              		.fpu fpv4-sp-d16
 1522              	rt_event_init:
 1523              	.LFB34:
 901:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mutex_control);
 902:rt-thread/src/ipc.c **** #endif /* end of RT_USING_MUTEX */
 903:rt-thread/src/ipc.c **** 
 904:rt-thread/src/ipc.c **** #ifdef RT_USING_EVENT
 905:rt-thread/src/ipc.c **** /**
 906:rt-thread/src/ipc.c ****  * This function will initialize an event and put it under control of resource
 907:rt-thread/src/ipc.c ****  * management.
 908:rt-thread/src/ipc.c ****  *
 909:rt-thread/src/ipc.c ****  * @param event the event object
 910:rt-thread/src/ipc.c ****  * @param name the name of event
 911:rt-thread/src/ipc.c ****  * @param flag the flag of event
 912:rt-thread/src/ipc.c ****  *
 913:rt-thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 914:rt-thread/src/ipc.c ****  */
 915:rt-thread/src/ipc.c **** rt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag)
 916:rt-thread/src/ipc.c **** {
 1524              		.loc 1 916 0
ARM GAS  /tmp/ccOtHhPO.s 			page 47


 1525              		.cfi_startproc
 1526              		@ args = 0, pretend = 0, frame = 0
 1527              		@ frame_needed = 0, uses_anonymous_args = 0
 1528              	.LVL198:
 1529 0000 38B5     		push	{r3, r4, r5, lr}
 1530              	.LCFI21:
 1531              		.cfi_def_cfa_offset 16
 1532              		.cfi_offset 3, -16
 1533              		.cfi_offset 4, -12
 1534              		.cfi_offset 5, -8
 1535              		.cfi_offset 14, -4
 1536 0002 0446     		mov	r4, r0
 1537 0004 1546     		mov	r5, r2
 917:rt-thread/src/ipc.c ****     /* parameter check */
 918:rt-thread/src/ipc.c ****     RT_ASSERT(event != RT_NULL);
 919:rt-thread/src/ipc.c **** 
 920:rt-thread/src/ipc.c ****     /* initialize object */
 921:rt-thread/src/ipc.c ****     rt_object_init(&(event->parent.parent), RT_Object_Class_Event, name);
 1538              		.loc 1 921 0
 1539 0006 0A46     		mov	r2, r1
 1540              	.LVL199:
 1541 0008 0421     		movs	r1, #4
 1542              	.LVL200:
 1543 000a FFF7FEFF 		bl	rt_object_init
 1544              	.LVL201:
 922:rt-thread/src/ipc.c **** 
 923:rt-thread/src/ipc.c ****     /* set parent flag */
 924:rt-thread/src/ipc.c ****     event->parent.parent.flag = flag;
 1545              		.loc 1 924 0
 1546 000e 6572     		strb	r5, [r4, #9]
 1547              	.LVL202:
 1548              	.LBB177:
 1549              	.LBB178:
  64:rt-thread/src/ipc.c **** 
 1550              		.loc 1 64 0
 1551 0010 04F11403 		add	r3, r4, #20
 1552              	.LVL203:
 1553              	.LBB179:
 1554              	.LBB180:
  49:rt-thread/include/rtservice.h **** }
 1555              		.loc 2 49 0
 1556 0014 A361     		str	r3, [r4, #24]
 1557 0016 6361     		str	r3, [r4, #20]
 1558              	.LVL204:
 1559              	.LBE180:
 1560              	.LBE179:
 1561              	.LBE178:
 1562              	.LBE177:
 925:rt-thread/src/ipc.c **** 
 926:rt-thread/src/ipc.c ****     /* initialize ipc object */
 927:rt-thread/src/ipc.c ****     rt_ipc_object_init(&(event->parent));
 928:rt-thread/src/ipc.c **** 
 929:rt-thread/src/ipc.c ****     /* initialize event */
 930:rt-thread/src/ipc.c ****     event->set = 0;
 1563              		.loc 1 930 0
 1564 0018 0020     		movs	r0, #0
 1565 001a E061     		str	r0, [r4, #28]
ARM GAS  /tmp/ccOtHhPO.s 			page 48


 931:rt-thread/src/ipc.c **** 
 932:rt-thread/src/ipc.c ****     return RT_EOK;
 933:rt-thread/src/ipc.c **** }
 1566              		.loc 1 933 0
 1567 001c 38BD     		pop	{r3, r4, r5, pc}
 1568              		.cfi_endproc
 1569              	.LFE34:
 1571              		.section	.text.rt_event_detach,"ax",%progbits
 1572              		.align	1
 1573              		.global	rt_event_detach
 1574              		.syntax unified
 1575              		.thumb
 1576              		.thumb_func
 1577              		.fpu fpv4-sp-d16
 1579              	rt_event_detach:
 1580              	.LFB35:
 934:rt-thread/src/ipc.c **** RTM_EXPORT(rt_event_init);
 935:rt-thread/src/ipc.c **** 
 936:rt-thread/src/ipc.c **** /**
 937:rt-thread/src/ipc.c ****  * This function will detach an event object from resource management
 938:rt-thread/src/ipc.c ****  *
 939:rt-thread/src/ipc.c ****  * @param event the event object
 940:rt-thread/src/ipc.c ****  *
 941:rt-thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 942:rt-thread/src/ipc.c ****  */
 943:rt-thread/src/ipc.c **** rt_err_t rt_event_detach(rt_event_t event)
 944:rt-thread/src/ipc.c **** {
 1581              		.loc 1 944 0
 1582              		.cfi_startproc
 1583              		@ args = 0, pretend = 0, frame = 0
 1584              		@ frame_needed = 0, uses_anonymous_args = 0
 1585              	.LVL205:
 1586 0000 70B5     		push	{r4, r5, r6, lr}
 1587              	.LCFI22:
 1588              		.cfi_def_cfa_offset 16
 1589              		.cfi_offset 4, -16
 1590              		.cfi_offset 5, -12
 1591              		.cfi_offset 6, -8
 1592              		.cfi_offset 14, -4
 1593 0002 0646     		mov	r6, r0
 945:rt-thread/src/ipc.c ****     /* parameter check */
 946:rt-thread/src/ipc.c ****     RT_ASSERT(event != RT_NULL);
 947:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&event->parent.parent) == RT_Object_Class_Event);
 948:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&event->parent.parent));
 949:rt-thread/src/ipc.c **** 
 950:rt-thread/src/ipc.c ****     /* resume all suspended thread */
 951:rt-thread/src/ipc.c ****     rt_ipc_list_resume_all(&(event->parent.suspend_thread));
 1594              		.loc 1 951 0
 1595 0004 00F11404 		add	r4, r0, #20
 1596              	.LVL206:
 1597 0008 0CE0     		b	.L111
 1598              	.LVL207:
 1599              	.L112:
 1600              	.LBB185:
 1601              	.LBB186:
 166:rt-thread/src/ipc.c **** 
 1602              		.loc 1 166 0
ARM GAS  /tmp/ccOtHhPO.s 			page 49


 1603 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 1604              	.LVL208:
 1605 000e 0546     		mov	r5, r0
 1606              	.LVL209:
 169:rt-thread/src/ipc.c ****         /* set error code to RT_ERROR */
 1607              		.loc 1 169 0
 1608 0010 2068     		ldr	r0, [r4]
 1609              	.LVL210:
 171:rt-thread/src/ipc.c **** 
 1610              		.loc 1 171 0
 1611 0012 4FF0FF33 		mov	r3, #-1
 1612 0016 C361     		str	r3, [r0, #28]
 178:rt-thread/src/ipc.c **** 
 1613              		.loc 1 178 0
 1614 0018 1438     		subs	r0, r0, #20
 1615              	.LVL211:
 1616 001a FFF7FEFF 		bl	rt_thread_resume
 1617              	.LVL212:
 181:rt-thread/src/ipc.c ****     }
 1618              		.loc 1 181 0
 1619 001e 2846     		mov	r0, r5
 1620 0020 FFF7FEFF 		bl	rt_hw_interrupt_enable
 1621              	.LVL213:
 1622              	.L111:
 1623              	.LBB187:
 1624              	.LBB188:
 1625              		.loc 2 100 0
 1626 0024 2368     		ldr	r3, [r4]
 1627              	.LVL214:
 1628              	.LBE188:
 1629              	.LBE187:
 163:rt-thread/src/ipc.c ****     {
 1630              		.loc 1 163 0
 1631 0026 9C42     		cmp	r4, r3
 1632 0028 EFD1     		bne	.L112
 1633              	.LVL215:
 1634              	.LBE186:
 1635              	.LBE185:
 952:rt-thread/src/ipc.c **** 
 953:rt-thread/src/ipc.c ****     /* detach event object */
 954:rt-thread/src/ipc.c ****     rt_object_detach(&(event->parent.parent));
 1636              		.loc 1 954 0
 1637 002a 3046     		mov	r0, r6
 1638 002c FFF7FEFF 		bl	rt_object_detach
 1639              	.LVL216:
 955:rt-thread/src/ipc.c **** 
 956:rt-thread/src/ipc.c ****     return RT_EOK;
 957:rt-thread/src/ipc.c **** }
 1640              		.loc 1 957 0
 1641 0030 0020     		movs	r0, #0
 1642 0032 70BD     		pop	{r4, r5, r6, pc}
 1643              		.cfi_endproc
 1644              	.LFE35:
 1646              		.section	.text.rt_event_create,"ax",%progbits
 1647              		.align	1
 1648              		.global	rt_event_create
 1649              		.syntax unified
ARM GAS  /tmp/ccOtHhPO.s 			page 50


 1650              		.thumb
 1651              		.thumb_func
 1652              		.fpu fpv4-sp-d16
 1654              	rt_event_create:
 1655              	.LFB36:
 958:rt-thread/src/ipc.c **** RTM_EXPORT(rt_event_detach);
 959:rt-thread/src/ipc.c **** 
 960:rt-thread/src/ipc.c **** #ifdef RT_USING_HEAP
 961:rt-thread/src/ipc.c **** /**
 962:rt-thread/src/ipc.c ****  * This function will create an event object from system resource
 963:rt-thread/src/ipc.c ****  *
 964:rt-thread/src/ipc.c ****  * @param name the name of event
 965:rt-thread/src/ipc.c ****  * @param flag the flag of event
 966:rt-thread/src/ipc.c ****  *
 967:rt-thread/src/ipc.c ****  * @return the created event, RT_NULL on error happen
 968:rt-thread/src/ipc.c ****  */
 969:rt-thread/src/ipc.c **** rt_event_t rt_event_create(const char *name, rt_uint8_t flag)
 970:rt-thread/src/ipc.c **** {
 1656              		.loc 1 970 0
 1657              		.cfi_startproc
 1658              		@ args = 0, pretend = 0, frame = 0
 1659              		@ frame_needed = 0, uses_anonymous_args = 0
 1660              	.LVL217:
 1661 0000 10B5     		push	{r4, lr}
 1662              	.LCFI23:
 1663              		.cfi_def_cfa_offset 8
 1664              		.cfi_offset 4, -8
 1665              		.cfi_offset 14, -4
 1666 0002 0C46     		mov	r4, r1
 971:rt-thread/src/ipc.c ****     rt_event_t event;
 972:rt-thread/src/ipc.c **** 
 973:rt-thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 974:rt-thread/src/ipc.c **** 
 975:rt-thread/src/ipc.c ****     /* allocate object */
 976:rt-thread/src/ipc.c ****     event = (rt_event_t)rt_object_allocate(RT_Object_Class_Event, name);
 1667              		.loc 1 976 0
 1668 0004 0146     		mov	r1, r0
 1669              	.LVL218:
 1670 0006 0420     		movs	r0, #4
 1671              	.LVL219:
 1672 0008 FFF7FEFF 		bl	rt_object_allocate
 1673              	.LVL220:
 977:rt-thread/src/ipc.c ****     if (event == RT_NULL)
 1674              		.loc 1 977 0
 1675 000c 0346     		mov	r3, r0
 1676 000e 30B1     		cbz	r0, .L114
 978:rt-thread/src/ipc.c ****         return event;
 979:rt-thread/src/ipc.c **** 
 980:rt-thread/src/ipc.c ****     /* set parent */
 981:rt-thread/src/ipc.c ****     event->parent.parent.flag = flag;
 1677              		.loc 1 981 0
 1678 0010 4472     		strb	r4, [r0, #9]
 1679              	.LVL221:
 1680              	.LBB189:
 1681              	.LBB190:
  64:rt-thread/src/ipc.c **** 
 1682              		.loc 1 64 0
ARM GAS  /tmp/ccOtHhPO.s 			page 51


 1683 0012 00F11402 		add	r2, r0, #20
 1684              	.LVL222:
 1685              	.LBB191:
 1686              	.LBB192:
  49:rt-thread/include/rtservice.h **** }
 1687              		.loc 2 49 0
 1688 0016 8261     		str	r2, [r0, #24]
 1689 0018 4261     		str	r2, [r0, #20]
 1690              	.LVL223:
 1691              	.LBE192:
 1692              	.LBE191:
 1693              	.LBE190:
 1694              	.LBE189:
 982:rt-thread/src/ipc.c **** 
 983:rt-thread/src/ipc.c ****     /* initialize ipc object */
 984:rt-thread/src/ipc.c ****     rt_ipc_object_init(&(event->parent));
 985:rt-thread/src/ipc.c **** 
 986:rt-thread/src/ipc.c ****     /* initialize event */
 987:rt-thread/src/ipc.c ****     event->set = 0;
 1695              		.loc 1 987 0
 1696 001a 0022     		movs	r2, #0
 1697 001c C261     		str	r2, [r0, #28]
 1698              	.L114:
 988:rt-thread/src/ipc.c **** 
 989:rt-thread/src/ipc.c ****     return event;
 990:rt-thread/src/ipc.c **** }
 1699              		.loc 1 990 0
 1700 001e 1846     		mov	r0, r3
 1701              	.LVL224:
 1702 0020 10BD     		pop	{r4, pc}
 1703              		.cfi_endproc
 1704              	.LFE36:
 1706              		.section	.text.rt_event_delete,"ax",%progbits
 1707              		.align	1
 1708              		.global	rt_event_delete
 1709              		.syntax unified
 1710              		.thumb
 1711              		.thumb_func
 1712              		.fpu fpv4-sp-d16
 1714              	rt_event_delete:
 1715              	.LFB37:
 991:rt-thread/src/ipc.c **** RTM_EXPORT(rt_event_create);
 992:rt-thread/src/ipc.c **** 
 993:rt-thread/src/ipc.c **** /**
 994:rt-thread/src/ipc.c ****  * This function will delete an event object and release the memory
 995:rt-thread/src/ipc.c ****  *
 996:rt-thread/src/ipc.c ****  * @param event the event object
 997:rt-thread/src/ipc.c ****  *
 998:rt-thread/src/ipc.c ****  * @return the error code
 999:rt-thread/src/ipc.c ****  */
1000:rt-thread/src/ipc.c **** rt_err_t rt_event_delete(rt_event_t event)
1001:rt-thread/src/ipc.c **** {
 1716              		.loc 1 1001 0
 1717              		.cfi_startproc
 1718              		@ args = 0, pretend = 0, frame = 0
 1719              		@ frame_needed = 0, uses_anonymous_args = 0
 1720              	.LVL225:
ARM GAS  /tmp/ccOtHhPO.s 			page 52


 1721 0000 70B5     		push	{r4, r5, r6, lr}
 1722              	.LCFI24:
 1723              		.cfi_def_cfa_offset 16
 1724              		.cfi_offset 4, -16
 1725              		.cfi_offset 5, -12
 1726              		.cfi_offset 6, -8
 1727              		.cfi_offset 14, -4
 1728 0002 0646     		mov	r6, r0
1002:rt-thread/src/ipc.c ****     /* parameter check */
1003:rt-thread/src/ipc.c ****     RT_ASSERT(event != RT_NULL);
1004:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&event->parent.parent) == RT_Object_Class_Event);
1005:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&event->parent.parent) == RT_FALSE);
1006:rt-thread/src/ipc.c **** 
1007:rt-thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
1008:rt-thread/src/ipc.c **** 
1009:rt-thread/src/ipc.c ****     /* resume all suspended thread */
1010:rt-thread/src/ipc.c ****     rt_ipc_list_resume_all(&(event->parent.suspend_thread));
 1729              		.loc 1 1010 0
 1730 0004 00F11404 		add	r4, r0, #20
 1731              	.LVL226:
 1732 0008 0CE0     		b	.L118
 1733              	.LVL227:
 1734              	.L119:
 1735              	.LBB197:
 1736              	.LBB198:
 166:rt-thread/src/ipc.c **** 
 1737              		.loc 1 166 0
 1738 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 1739              	.LVL228:
 1740 000e 0546     		mov	r5, r0
 1741              	.LVL229:
 169:rt-thread/src/ipc.c ****         /* set error code to RT_ERROR */
 1742              		.loc 1 169 0
 1743 0010 2068     		ldr	r0, [r4]
 1744              	.LVL230:
 171:rt-thread/src/ipc.c **** 
 1745              		.loc 1 171 0
 1746 0012 4FF0FF33 		mov	r3, #-1
 1747 0016 C361     		str	r3, [r0, #28]
 178:rt-thread/src/ipc.c **** 
 1748              		.loc 1 178 0
 1749 0018 1438     		subs	r0, r0, #20
 1750              	.LVL231:
 1751 001a FFF7FEFF 		bl	rt_thread_resume
 1752              	.LVL232:
 181:rt-thread/src/ipc.c ****     }
 1753              		.loc 1 181 0
 1754 001e 2846     		mov	r0, r5
 1755 0020 FFF7FEFF 		bl	rt_hw_interrupt_enable
 1756              	.LVL233:
 1757              	.L118:
 1758              	.LBB199:
 1759              	.LBB200:
 1760              		.loc 2 100 0
 1761 0024 2368     		ldr	r3, [r4]
 1762              	.LVL234:
 1763              	.LBE200:
ARM GAS  /tmp/ccOtHhPO.s 			page 53


 1764              	.LBE199:
 163:rt-thread/src/ipc.c ****     {
 1765              		.loc 1 163 0
 1766 0026 9C42     		cmp	r4, r3
 1767 0028 EFD1     		bne	.L119
 1768              	.LVL235:
 1769              	.LBE198:
 1770              	.LBE197:
1011:rt-thread/src/ipc.c **** 
1012:rt-thread/src/ipc.c ****     /* delete event object */
1013:rt-thread/src/ipc.c ****     rt_object_delete(&(event->parent.parent));
 1771              		.loc 1 1013 0
 1772 002a 3046     		mov	r0, r6
 1773 002c FFF7FEFF 		bl	rt_object_delete
 1774              	.LVL236:
1014:rt-thread/src/ipc.c **** 
1015:rt-thread/src/ipc.c ****     return RT_EOK;
1016:rt-thread/src/ipc.c **** }
 1775              		.loc 1 1016 0
 1776 0030 0020     		movs	r0, #0
 1777 0032 70BD     		pop	{r4, r5, r6, pc}
 1778              		.cfi_endproc
 1779              	.LFE37:
 1781              		.section	.text.rt_event_send,"ax",%progbits
 1782              		.align	1
 1783              		.global	rt_event_send
 1784              		.syntax unified
 1785              		.thumb
 1786              		.thumb_func
 1787              		.fpu fpv4-sp-d16
 1789              	rt_event_send:
 1790              	.LFB38:
1017:rt-thread/src/ipc.c **** RTM_EXPORT(rt_event_delete);
1018:rt-thread/src/ipc.c **** #endif
1019:rt-thread/src/ipc.c **** 
1020:rt-thread/src/ipc.c **** /**
1021:rt-thread/src/ipc.c ****  * This function will send an event to the event object, if there are threads
1022:rt-thread/src/ipc.c ****  * suspended on event object, it will be waked up.
1023:rt-thread/src/ipc.c ****  *
1024:rt-thread/src/ipc.c ****  * @param event the event object
1025:rt-thread/src/ipc.c ****  * @param set the event set
1026:rt-thread/src/ipc.c ****  *
1027:rt-thread/src/ipc.c ****  * @return the error code
1028:rt-thread/src/ipc.c ****  */
1029:rt-thread/src/ipc.c **** rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set)
1030:rt-thread/src/ipc.c **** {
 1791              		.loc 1 1030 0
 1792              		.cfi_startproc
 1793              		@ args = 0, pretend = 0, frame = 0
 1794              		@ frame_needed = 0, uses_anonymous_args = 0
 1795              	.LVL237:
1031:rt-thread/src/ipc.c ****     struct rt_list_node *n;
1032:rt-thread/src/ipc.c ****     struct rt_thread *thread;
1033:rt-thread/src/ipc.c ****     register rt_ubase_t level;
1034:rt-thread/src/ipc.c ****     register rt_base_t status;
1035:rt-thread/src/ipc.c ****     rt_bool_t need_schedule;
1036:rt-thread/src/ipc.c **** 
ARM GAS  /tmp/ccOtHhPO.s 			page 54


1037:rt-thread/src/ipc.c ****     /* parameter check */
1038:rt-thread/src/ipc.c ****     RT_ASSERT(event != RT_NULL);
1039:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&event->parent.parent) == RT_Object_Class_Event);
1040:rt-thread/src/ipc.c **** 
1041:rt-thread/src/ipc.c ****     if (set == 0)
 1796              		.loc 1 1041 0
 1797 0000 0029     		cmp	r1, #0
 1798 0002 54D0     		beq	.L131
1030:rt-thread/src/ipc.c ****     struct rt_list_node *n;
 1799              		.loc 1 1030 0
 1800 0004 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1801              	.LCFI25:
 1802              		.cfi_def_cfa_offset 24
 1803              		.cfi_offset 4, -24
 1804              		.cfi_offset 5, -20
 1805              		.cfi_offset 6, -16
 1806              		.cfi_offset 7, -12
 1807              		.cfi_offset 8, -8
 1808              		.cfi_offset 14, -4
 1809 0008 0D46     		mov	r5, r1
 1810 000a 0446     		mov	r4, r0
 1811              	.LVL238:
1042:rt-thread/src/ipc.c ****         return -RT_ERROR;
1043:rt-thread/src/ipc.c **** 
1044:rt-thread/src/ipc.c ****     need_schedule = RT_FALSE;
1045:rt-thread/src/ipc.c **** 
1046:rt-thread/src/ipc.c ****     /* disable interrupt */
1047:rt-thread/src/ipc.c ****     level = rt_hw_interrupt_disable();
 1812              		.loc 1 1047 0
 1813 000c FFF7FEFF 		bl	rt_hw_interrupt_disable
 1814              	.LVL239:
 1815 0010 8046     		mov	r8, r0
 1816              	.LVL240:
1048:rt-thread/src/ipc.c **** 
1049:rt-thread/src/ipc.c ****     /* set event */
1050:rt-thread/src/ipc.c ****     event->set |= set;
 1817              		.loc 1 1050 0
 1818 0012 E369     		ldr	r3, [r4, #28]
 1819 0014 2B43     		orrs	r3, r3, r5
 1820 0016 E361     		str	r3, [r4, #28]
1051:rt-thread/src/ipc.c **** 
1052:rt-thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(event->parent.parent)));
 1821              		.loc 1 1052 0
 1822 0018 264B     		ldr	r3, .L143
 1823 001a 1B68     		ldr	r3, [r3]
 1824 001c 0BB1     		cbz	r3, .L123
 1825              		.loc 1 1052 0 is_stmt 0 discriminator 1
 1826 001e 2046     		mov	r0, r4
 1827              	.LVL241:
 1828 0020 9847     		blx	r3
 1829              	.LVL242:
 1830              	.L123:
1053:rt-thread/src/ipc.c **** 
1054:rt-thread/src/ipc.c ****     if (!rt_list_isempty(&event->parent.suspend_thread))
 1831              		.loc 1 1054 0 is_stmt 1
 1832 0022 04F11406 		add	r6, r4, #20
 1833              	.LVL243:
ARM GAS  /tmp/ccOtHhPO.s 			page 55


 1834              	.LBB201:
 1835              	.LBB202:
 1836              		.loc 2 100 0
 1837 0026 6369     		ldr	r3, [r4, #20]
 1838              	.LVL244:
 1839              	.LBE202:
 1840              	.LBE201:
 1841              		.loc 1 1054 0
 1842 0028 9E42     		cmp	r6, r3
 1843 002a 01D0     		beq	.L141
 1844 002c 0027     		movs	r7, #0
 1845 002e 1EE0     		b	.L124
 1846              	.L141:
1044:rt-thread/src/ipc.c **** 
 1847              		.loc 1 1044 0
 1848 0030 0027     		movs	r7, #0
 1849              	.LVL245:
 1850              	.L125:
1055:rt-thread/src/ipc.c ****     {
1056:rt-thread/src/ipc.c ****         /* search thread list to resume thread */
1057:rt-thread/src/ipc.c ****         n = event->parent.suspend_thread.next;
1058:rt-thread/src/ipc.c ****         while (n != &(event->parent.suspend_thread))
1059:rt-thread/src/ipc.c ****         {
1060:rt-thread/src/ipc.c ****             /* get thread */
1061:rt-thread/src/ipc.c ****             thread = rt_list_entry(n, struct rt_thread, tlist);
1062:rt-thread/src/ipc.c **** 
1063:rt-thread/src/ipc.c ****             status = -RT_ERROR;
1064:rt-thread/src/ipc.c ****             if (thread->event_info & RT_EVENT_FLAG_AND)
1065:rt-thread/src/ipc.c ****             {
1066:rt-thread/src/ipc.c ****                 if ((thread->event_set & event->set) == thread->event_set)
1067:rt-thread/src/ipc.c ****                 {
1068:rt-thread/src/ipc.c ****                     /* received an AND event */
1069:rt-thread/src/ipc.c ****                     status = RT_EOK;
1070:rt-thread/src/ipc.c ****                 }
1071:rt-thread/src/ipc.c ****             }
1072:rt-thread/src/ipc.c ****             else if (thread->event_info & RT_EVENT_FLAG_OR)
1073:rt-thread/src/ipc.c ****             {
1074:rt-thread/src/ipc.c ****                 if (thread->event_set & event->set)
1075:rt-thread/src/ipc.c ****                 {
1076:rt-thread/src/ipc.c ****                     /* save the received event set */
1077:rt-thread/src/ipc.c ****                     thread->event_set = thread->event_set & event->set;
1078:rt-thread/src/ipc.c **** 
1079:rt-thread/src/ipc.c ****                     /* received an OR event */
1080:rt-thread/src/ipc.c ****                     status = RT_EOK;
1081:rt-thread/src/ipc.c ****                 }
1082:rt-thread/src/ipc.c ****             }
1083:rt-thread/src/ipc.c **** 
1084:rt-thread/src/ipc.c ****             /* move node to the next */
1085:rt-thread/src/ipc.c ****             n = n->next;
1086:rt-thread/src/ipc.c **** 
1087:rt-thread/src/ipc.c ****             /* condition is satisfied, resume thread */
1088:rt-thread/src/ipc.c ****             if (status == RT_EOK)
1089:rt-thread/src/ipc.c ****             {
1090:rt-thread/src/ipc.c ****                 /* clear event */
1091:rt-thread/src/ipc.c ****                 if (thread->event_info & RT_EVENT_FLAG_CLEAR)
1092:rt-thread/src/ipc.c ****                     event->set &= ~thread->event_set;
1093:rt-thread/src/ipc.c **** 
ARM GAS  /tmp/ccOtHhPO.s 			page 56


1094:rt-thread/src/ipc.c ****                 /* resume thread, and thread list breaks out */
1095:rt-thread/src/ipc.c ****                 rt_thread_resume(thread);
1096:rt-thread/src/ipc.c **** 
1097:rt-thread/src/ipc.c ****                 /* need do a scheduling */
1098:rt-thread/src/ipc.c ****                 need_schedule = RT_TRUE;
1099:rt-thread/src/ipc.c ****             }
1100:rt-thread/src/ipc.c ****         }
1101:rt-thread/src/ipc.c ****     }
1102:rt-thread/src/ipc.c **** 
1103:rt-thread/src/ipc.c ****     /* enable interrupt */
1104:rt-thread/src/ipc.c ****     rt_hw_interrupt_enable(level);
 1851              		.loc 1 1104 0
 1852 0032 4046     		mov	r0, r8
 1853 0034 FFF7FEFF 		bl	rt_hw_interrupt_enable
 1854              	.LVL246:
1105:rt-thread/src/ipc.c **** 
1106:rt-thread/src/ipc.c ****     /* do a schedule */
1107:rt-thread/src/ipc.c ****     if (need_schedule == RT_TRUE)
 1855              		.loc 1 1107 0
 1856 0038 002F     		cmp	r7, #0
 1857 003a 33D1     		bne	.L142
1108:rt-thread/src/ipc.c ****         rt_schedule();
1109:rt-thread/src/ipc.c **** 
1110:rt-thread/src/ipc.c ****     return RT_EOK;
 1858              		.loc 1 1110 0
 1859 003c 0020     		movs	r0, #0
1111:rt-thread/src/ipc.c **** }
 1860              		.loc 1 1111 0
 1861 003e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1862              	.LVL247:
 1863              	.L126:
1072:rt-thread/src/ipc.c ****             {
 1864              		.loc 1 1072 0
 1865 0042 12F0020F 		tst	r2, #2
 1866 0046 08D0     		beq	.L134
1074:rt-thread/src/ipc.c ****                 {
 1867              		.loc 1 1074 0
 1868 0048 996A     		ldr	r1, [r3, #40]
 1869 004a E569     		ldr	r5, [r4, #28]
 1870 004c 2940     		ands	r1, r1, r5
 1871 004e 07D0     		beq	.L135
1077:rt-thread/src/ipc.c **** 
 1872              		.loc 1 1077 0
 1873 0050 9962     		str	r1, [r3, #40]
 1874              	.LVL248:
1080:rt-thread/src/ipc.c ****                 }
 1875              		.loc 1 1080 0
 1876 0052 0021     		movs	r1, #0
 1877 0054 1AE0     		b	.L127
 1878              	.LVL249:
 1879              	.L133:
1069:rt-thread/src/ipc.c ****                 }
 1880              		.loc 1 1069 0
 1881 0056 0021     		movs	r1, #0
 1882 0058 18E0     		b	.L127
 1883              	.L134:
1063:rt-thread/src/ipc.c ****             if (thread->event_info & RT_EVENT_FLAG_AND)
ARM GAS  /tmp/ccOtHhPO.s 			page 57


 1884              		.loc 1 1063 0
 1885 005a 4FF0FF31 		mov	r1, #-1
 1886 005e 15E0     		b	.L127
 1887              	.L135:
 1888 0060 4FF0FF31 		mov	r1, #-1
 1889 0064 12E0     		b	.L127
 1890              	.LVL250:
 1891              	.L129:
1095:rt-thread/src/ipc.c **** 
 1892              		.loc 1 1095 0
 1893 0066 FFF7FEFF 		bl	rt_thread_resume
 1894              	.LVL251:
1098:rt-thread/src/ipc.c ****             }
 1895              		.loc 1 1098 0
 1896 006a 0127     		movs	r7, #1
 1897              	.LVL252:
 1898              	.L128:
 1899 006c 2B46     		mov	r3, r5
 1900              	.LVL253:
 1901              	.L124:
1058:rt-thread/src/ipc.c ****         {
 1902              		.loc 1 1058 0
 1903 006e B342     		cmp	r3, r6
 1904 0070 DFD0     		beq	.L125
1061:rt-thread/src/ipc.c **** 
 1905              		.loc 1 1061 0
 1906 0072 A3F11400 		sub	r0, r3, #20
 1907              	.LVL254:
1064:rt-thread/src/ipc.c ****             {
 1908              		.loc 1 1064 0
 1909 0076 93F82C20 		ldrb	r2, [r3, #44]	@ zero_extendqisi2
 1910 007a 12F0010F 		tst	r2, #1
 1911 007e E0D0     		beq	.L126
1066:rt-thread/src/ipc.c ****                 {
 1912              		.loc 1 1066 0
 1913 0080 996A     		ldr	r1, [r3, #40]
 1914 0082 E569     		ldr	r5, [r4, #28]
 1915 0084 A943     		bics	r1, r1, r5
 1916 0086 E6D0     		beq	.L133
1063:rt-thread/src/ipc.c ****             if (thread->event_info & RT_EVENT_FLAG_AND)
 1917              		.loc 1 1063 0
 1918 0088 4FF0FF31 		mov	r1, #-1
 1919              	.LVL255:
 1920              	.L127:
1085:rt-thread/src/ipc.c **** 
 1921              		.loc 1 1085 0
 1922 008c 1D68     		ldr	r5, [r3]
 1923              	.LVL256:
1088:rt-thread/src/ipc.c ****             {
 1924              		.loc 1 1088 0
 1925 008e 0029     		cmp	r1, #0
 1926 0090 ECD1     		bne	.L128
1091:rt-thread/src/ipc.c ****                     event->set &= ~thread->event_set;
 1927              		.loc 1 1091 0
 1928 0092 12F0040F 		tst	r2, #4
 1929 0096 E6D0     		beq	.L129
1092:rt-thread/src/ipc.c **** 
ARM GAS  /tmp/ccOtHhPO.s 			page 58


 1930              		.loc 1 1092 0
 1931 0098 9A6A     		ldr	r2, [r3, #40]
 1932 009a E369     		ldr	r3, [r4, #28]
 1933 009c 23EA0203 		bic	r3, r3, r2
 1934 00a0 E361     		str	r3, [r4, #28]
 1935 00a2 E0E7     		b	.L129
 1936              	.LVL257:
 1937              	.L142:
1108:rt-thread/src/ipc.c **** 
 1938              		.loc 1 1108 0
 1939 00a4 FFF7FEFF 		bl	rt_schedule
 1940              	.LVL258:
1110:rt-thread/src/ipc.c **** }
 1941              		.loc 1 1110 0
 1942 00a8 0020     		movs	r0, #0
 1943 00aa BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1944              	.LVL259:
 1945              	.L131:
 1946              	.LCFI26:
 1947              		.cfi_def_cfa_offset 0
 1948              		.cfi_restore 4
 1949              		.cfi_restore 5
 1950              		.cfi_restore 6
 1951              		.cfi_restore 7
 1952              		.cfi_restore 8
 1953              		.cfi_restore 14
1042:rt-thread/src/ipc.c **** 
 1954              		.loc 1 1042 0
 1955 00ae 4FF0FF30 		mov	r0, #-1
 1956              	.LVL260:
 1957 00b2 7047     		bx	lr
 1958              	.L144:
 1959              		.align	2
 1960              	.L143:
 1961 00b4 00000000 		.word	rt_object_put_hook
 1962              		.cfi_endproc
 1963              	.LFE38:
 1965              		.section	.text.rt_event_recv,"ax",%progbits
 1966              		.align	1
 1967              		.global	rt_event_recv
 1968              		.syntax unified
 1969              		.thumb
 1970              		.thumb_func
 1971              		.fpu fpv4-sp-d16
 1973              	rt_event_recv:
 1974              	.LFB39:
1112:rt-thread/src/ipc.c **** RTM_EXPORT(rt_event_send);
1113:rt-thread/src/ipc.c **** 
1114:rt-thread/src/ipc.c **** /**
1115:rt-thread/src/ipc.c ****  * This function will receive an event from event object, if the event is
1116:rt-thread/src/ipc.c ****  * unavailable, the thread shall wait for a specified time.
1117:rt-thread/src/ipc.c ****  *
1118:rt-thread/src/ipc.c ****  * @param event the fast event object
1119:rt-thread/src/ipc.c ****  * @param set the interested event set
1120:rt-thread/src/ipc.c ****  * @param option the receive option, either RT_EVENT_FLAG_AND or
1121:rt-thread/src/ipc.c ****  *        RT_EVENT_FLAG_OR should be set.
1122:rt-thread/src/ipc.c ****  * @param timeout the waiting time
ARM GAS  /tmp/ccOtHhPO.s 			page 59


1123:rt-thread/src/ipc.c ****  * @param recved the received event, if you don't care, RT_NULL can be set.
1124:rt-thread/src/ipc.c ****  *
1125:rt-thread/src/ipc.c ****  * @return the error code
1126:rt-thread/src/ipc.c ****  */
1127:rt-thread/src/ipc.c **** rt_err_t rt_event_recv(rt_event_t   event,
1128:rt-thread/src/ipc.c ****                        rt_uint32_t  set,
1129:rt-thread/src/ipc.c ****                        rt_uint8_t   option,
1130:rt-thread/src/ipc.c ****                        rt_int32_t   timeout,
1131:rt-thread/src/ipc.c ****                        rt_uint32_t *recved)
1132:rt-thread/src/ipc.c **** {
 1975              		.loc 1 1132 0
 1976              		.cfi_startproc
 1977              		@ args = 4, pretend = 0, frame = 8
 1978              		@ frame_needed = 0, uses_anonymous_args = 0
 1979              	.LVL261:
 1980 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1981              	.LCFI27:
 1982              		.cfi_def_cfa_offset 24
 1983              		.cfi_offset 4, -24
 1984              		.cfi_offset 5, -20
 1985              		.cfi_offset 6, -16
 1986              		.cfi_offset 7, -12
 1987              		.cfi_offset 8, -8
 1988              		.cfi_offset 14, -4
 1989 0004 82B0     		sub	sp, sp, #8
 1990              	.LCFI28:
 1991              		.cfi_def_cfa_offset 32
 1992 0006 0193     		str	r3, [sp, #4]
1133:rt-thread/src/ipc.c ****     struct rt_thread *thread;
1134:rt-thread/src/ipc.c ****     register rt_ubase_t level;
1135:rt-thread/src/ipc.c ****     register rt_base_t status;
1136:rt-thread/src/ipc.c **** 
1137:rt-thread/src/ipc.c ****     RT_DEBUG_IN_THREAD_CONTEXT;
1138:rt-thread/src/ipc.c **** 
1139:rt-thread/src/ipc.c ****     /* parameter check */
1140:rt-thread/src/ipc.c ****     RT_ASSERT(event != RT_NULL);
1141:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&event->parent.parent) == RT_Object_Class_Event);
1142:rt-thread/src/ipc.c **** 
1143:rt-thread/src/ipc.c ****     if (set == 0)
 1993              		.loc 1 1143 0
 1994 0008 0029     		cmp	r1, #0
 1995 000a 00F0A080 		beq	.L163
 1996 000e 8846     		mov	r8, r1
 1997 0010 1546     		mov	r5, r2
 1998 0012 0446     		mov	r4, r0
 1999              	.LVL262:
1144:rt-thread/src/ipc.c ****         return -RT_ERROR;
1145:rt-thread/src/ipc.c **** 
1146:rt-thread/src/ipc.c ****     /* initialize status */
1147:rt-thread/src/ipc.c ****     status = -RT_ERROR;
1148:rt-thread/src/ipc.c ****     /* get current thread */
1149:rt-thread/src/ipc.c ****     thread = rt_thread_self();
 2000              		.loc 1 1149 0
 2001 0014 FFF7FEFF 		bl	rt_thread_self
 2002              	.LVL263:
 2003 0018 0746     		mov	r7, r0
 2004              	.LVL264:
ARM GAS  /tmp/ccOtHhPO.s 			page 60


1150:rt-thread/src/ipc.c ****     /* reset thread error */
1151:rt-thread/src/ipc.c ****     thread->error = RT_EOK;
 2005              		.loc 1 1151 0
 2006 001a 0023     		movs	r3, #0
 2007 001c 0363     		str	r3, [r0, #48]
1152:rt-thread/src/ipc.c **** 
1153:rt-thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(event->parent.parent)));
 2008              		.loc 1 1153 0
 2009 001e 4D4B     		ldr	r3, .L169
 2010 0020 1B68     		ldr	r3, [r3]
 2011 0022 0BB1     		cbz	r3, .L147
 2012              		.loc 1 1153 0 is_stmt 0 discriminator 1
 2013 0024 2046     		mov	r0, r4
 2014              	.LVL265:
 2015 0026 9847     		blx	r3
 2016              	.LVL266:
 2017              	.L147:
1154:rt-thread/src/ipc.c **** 
1155:rt-thread/src/ipc.c ****     /* disable interrupt */
1156:rt-thread/src/ipc.c ****     level = rt_hw_interrupt_disable();
 2018              		.loc 1 1156 0 is_stmt 1
 2019 0028 FFF7FEFF 		bl	rt_hw_interrupt_disable
 2020              	.LVL267:
 2021 002c 0646     		mov	r6, r0
 2022              	.LVL268:
1157:rt-thread/src/ipc.c **** 
1158:rt-thread/src/ipc.c ****     /* check event set */
1159:rt-thread/src/ipc.c ****     if (option & RT_EVENT_FLAG_AND)
 2023              		.loc 1 1159 0
 2024 002e 15F0010F 		tst	r5, #1
 2025 0032 15D0     		beq	.L148
1160:rt-thread/src/ipc.c ****     {
1161:rt-thread/src/ipc.c ****         if ((event->set & set) == set)
 2026              		.loc 1 1161 0
 2027 0034 E369     		ldr	r3, [r4, #28]
 2028 0036 38EA0303 		bics	r3, r8, r3
 2029 003a 1BD0     		beq	.L164
1147:rt-thread/src/ipc.c ****     /* get current thread */
 2030              		.loc 1 1147 0
 2031 003c 4FF0FF33 		mov	r3, #-1
 2032              	.L149:
 2033              	.LVL269:
1162:rt-thread/src/ipc.c ****             status = RT_EOK;
1163:rt-thread/src/ipc.c ****     }
1164:rt-thread/src/ipc.c ****     else if (option & RT_EVENT_FLAG_OR)
1165:rt-thread/src/ipc.c ****     {
1166:rt-thread/src/ipc.c ****         if (event->set & set)
1167:rt-thread/src/ipc.c ****             status = RT_EOK;
1168:rt-thread/src/ipc.c ****     }
1169:rt-thread/src/ipc.c ****     else
1170:rt-thread/src/ipc.c ****     {
1171:rt-thread/src/ipc.c ****         /* either RT_EVENT_FLAG_AND or RT_EVENT_FLAG_OR should be set */
1172:rt-thread/src/ipc.c ****         RT_ASSERT(0);
1173:rt-thread/src/ipc.c ****     }
1174:rt-thread/src/ipc.c **** 
1175:rt-thread/src/ipc.c ****     if (status == RT_EOK)
 2034              		.loc 1 1175 0
ARM GAS  /tmp/ccOtHhPO.s 			page 61


 2035 0040 FBB9     		cbnz	r3, .L150
1176:rt-thread/src/ipc.c ****     {
1177:rt-thread/src/ipc.c ****         /* set received event */
1178:rt-thread/src/ipc.c ****         if (recved)
 2036              		.loc 1 1178 0
 2037 0042 089B     		ldr	r3, [sp, #32]
 2038              	.LVL270:
 2039 0044 23B1     		cbz	r3, .L151
1179:rt-thread/src/ipc.c ****             *recved = (event->set & set);
 2040              		.loc 1 1179 0
 2041 0046 E369     		ldr	r3, [r4, #28]
 2042 0048 08EA0303 		and	r3, r8, r3
 2043 004c 089A     		ldr	r2, [sp, #32]
 2044 004e 1360     		str	r3, [r2]
 2045              	.L151:
1180:rt-thread/src/ipc.c **** 
1181:rt-thread/src/ipc.c ****         /* received event */
1182:rt-thread/src/ipc.c ****         if (option & RT_EVENT_FLAG_CLEAR)
 2046              		.loc 1 1182 0
 2047 0050 15F0040F 		tst	r5, #4
 2048 0054 1AD0     		beq	.L152
1183:rt-thread/src/ipc.c ****             event->set &= ~set;
 2049              		.loc 1 1183 0
 2050 0056 E369     		ldr	r3, [r4, #28]
 2051 0058 23EA0803 		bic	r3, r3, r8
 2052 005c E361     		str	r3, [r4, #28]
 2053 005e 15E0     		b	.L152
 2054              	.LVL271:
 2055              	.L148:
1164:rt-thread/src/ipc.c ****     {
 2056              		.loc 1 1164 0
 2057 0060 15F0020F 		tst	r5, #2
 2058 0064 08D0     		beq	.L165
1166:rt-thread/src/ipc.c ****             status = RT_EOK;
 2059              		.loc 1 1166 0
 2060 0066 E369     		ldr	r3, [r4, #28]
 2061 0068 18EA030F 		tst	r8, r3
 2062 006c 07D1     		bne	.L166
1147:rt-thread/src/ipc.c ****     /* get current thread */
 2063              		.loc 1 1147 0
 2064 006e 4FF0FF33 		mov	r3, #-1
 2065 0072 E5E7     		b	.L149
 2066              	.L164:
1162:rt-thread/src/ipc.c ****     }
 2067              		.loc 1 1162 0
 2068 0074 0023     		movs	r3, #0
 2069 0076 E3E7     		b	.L149
 2070              	.L165:
1147:rt-thread/src/ipc.c ****     /* get current thread */
 2071              		.loc 1 1147 0
 2072 0078 4FF0FF33 		mov	r3, #-1
 2073 007c E0E7     		b	.L149
 2074              	.L166:
1167:rt-thread/src/ipc.c ****     }
 2075              		.loc 1 1167 0
 2076 007e 0023     		movs	r3, #0
 2077 0080 DEE7     		b	.L149
ARM GAS  /tmp/ccOtHhPO.s 			page 62


 2078              	.LVL272:
 2079              	.L150:
1184:rt-thread/src/ipc.c ****     }
1185:rt-thread/src/ipc.c ****     else if (timeout == 0)
 2080              		.loc 1 1185 0
 2081 0082 019B     		ldr	r3, [sp, #4]
 2082              	.LVL273:
 2083 0084 6BB9     		cbnz	r3, .L153
1186:rt-thread/src/ipc.c ****     {
1187:rt-thread/src/ipc.c ****         /* no waiting */
1188:rt-thread/src/ipc.c ****         thread->error = -RT_ETIMEOUT;
 2084              		.loc 1 1188 0
 2085 0086 6FF00103 		mvn	r3, #1
 2086 008a 3B63     		str	r3, [r7, #48]
 2087              	.LVL274:
 2088              	.L152:
1189:rt-thread/src/ipc.c ****     }
1190:rt-thread/src/ipc.c ****     else
1191:rt-thread/src/ipc.c ****     {
1192:rt-thread/src/ipc.c ****         /* fill thread event info */
1193:rt-thread/src/ipc.c ****         thread->event_set  = set;
1194:rt-thread/src/ipc.c ****         thread->event_info = option;
1195:rt-thread/src/ipc.c **** 
1196:rt-thread/src/ipc.c ****         /* put thread to suspended thread list */
1197:rt-thread/src/ipc.c ****         rt_ipc_list_suspend(&(event->parent.suspend_thread),
1198:rt-thread/src/ipc.c ****                             thread,
1199:rt-thread/src/ipc.c ****                             event->parent.parent.flag);
1200:rt-thread/src/ipc.c **** 
1201:rt-thread/src/ipc.c ****         /* if there is a waiting timeout, active thread timer */
1202:rt-thread/src/ipc.c ****         if (timeout > 0)
1203:rt-thread/src/ipc.c ****         {
1204:rt-thread/src/ipc.c ****             /* reset the timeout of thread timer and start it */
1205:rt-thread/src/ipc.c ****             rt_timer_control(&(thread->thread_timer),
1206:rt-thread/src/ipc.c ****                              RT_TIMER_CTRL_SET_TIME,
1207:rt-thread/src/ipc.c ****                              &timeout);
1208:rt-thread/src/ipc.c ****             rt_timer_start(&(thread->thread_timer));
1209:rt-thread/src/ipc.c ****         }
1210:rt-thread/src/ipc.c **** 
1211:rt-thread/src/ipc.c ****         /* enable interrupt */
1212:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(level);
1213:rt-thread/src/ipc.c **** 
1214:rt-thread/src/ipc.c ****         /* do a schedule */
1215:rt-thread/src/ipc.c ****         rt_schedule();
1216:rt-thread/src/ipc.c **** 
1217:rt-thread/src/ipc.c ****         if (thread->error != RT_EOK)
1218:rt-thread/src/ipc.c ****         {
1219:rt-thread/src/ipc.c ****             /* return error */
1220:rt-thread/src/ipc.c ****             return thread->error;
1221:rt-thread/src/ipc.c ****         }
1222:rt-thread/src/ipc.c **** 
1223:rt-thread/src/ipc.c ****         /* received an event, disable interrupt to protect */
1224:rt-thread/src/ipc.c ****         level = rt_hw_interrupt_disable();
1225:rt-thread/src/ipc.c **** 
1226:rt-thread/src/ipc.c ****         /* set received event */
1227:rt-thread/src/ipc.c ****         if (recved)
1228:rt-thread/src/ipc.c ****             *recved = thread->event_set;
1229:rt-thread/src/ipc.c ****     }
ARM GAS  /tmp/ccOtHhPO.s 			page 63


1230:rt-thread/src/ipc.c **** 
1231:rt-thread/src/ipc.c ****     /* enable interrupt */
1232:rt-thread/src/ipc.c ****     rt_hw_interrupt_enable(level);
 2089              		.loc 1 1232 0
 2090 008c FFF7FEFF 		bl	rt_hw_interrupt_enable
 2091              	.LVL275:
1233:rt-thread/src/ipc.c **** 
1234:rt-thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(event->parent.parent)));
 2092              		.loc 1 1234 0
 2093 0090 314B     		ldr	r3, .L169+4
 2094 0092 1B68     		ldr	r3, [r3]
 2095 0094 0BB1     		cbz	r3, .L162
 2096              		.loc 1 1234 0 is_stmt 0 discriminator 1
 2097 0096 2046     		mov	r0, r4
 2098 0098 9847     		blx	r3
 2099              	.LVL276:
 2100              	.L162:
1235:rt-thread/src/ipc.c **** 
1236:rt-thread/src/ipc.c ****     return thread->error;
 2101              		.loc 1 1236 0 is_stmt 1
 2102 009a 386B     		ldr	r0, [r7, #48]
 2103              	.LVL277:
 2104              	.L145:
1237:rt-thread/src/ipc.c **** }
 2105              		.loc 1 1237 0
 2106 009c 02B0     		add	sp, sp, #8
 2107              	.LCFI29:
 2108              		.cfi_remember_state
 2109              		.cfi_def_cfa_offset 24
 2110              		@ sp needed
 2111 009e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2112              	.LVL278:
 2113              	.L153:
 2114              	.LCFI30:
 2115              		.cfi_restore_state
1193:rt-thread/src/ipc.c ****         thread->event_info = option;
 2116              		.loc 1 1193 0
 2117 00a2 C7F83C80 		str	r8, [r7, #60]
1194:rt-thread/src/ipc.c **** 
 2118              		.loc 1 1194 0
 2119 00a6 87F84050 		strb	r5, [r7, #64]
1197:rt-thread/src/ipc.c ****                             thread,
 2120              		.loc 1 1197 0
 2121 00aa 04F11405 		add	r5, r4, #20
 2122 00ae 94F80980 		ldrb	r8, [r4, #9]	@ zero_extendqisi2
 2123              	.LVL279:
 2124              	.LBB212:
 2125              	.LBB213:
  85:rt-thread/src/ipc.c **** 
 2126              		.loc 1 85 0
 2127 00b2 3846     		mov	r0, r7
 2128              	.LVL280:
 2129 00b4 FFF7FEFF 		bl	rt_thread_suspend
 2130              	.LVL281:
  87:rt-thread/src/ipc.c ****     {
 2131              		.loc 1 87 0
 2132 00b8 B8F1000F 		cmp	r8, #0
ARM GAS  /tmp/ccOtHhPO.s 			page 64


 2133 00bc 20D0     		beq	.L155
 2134 00be B8F1010F 		cmp	r8, #1
 2135 00c2 26D0     		beq	.L156
 2136              	.L154:
 2137              	.LVL282:
 2138              	.LBE213:
 2139              	.LBE212:
1202:rt-thread/src/ipc.c ****         {
 2140              		.loc 1 1202 0
 2141 00c4 019B     		ldr	r3, [sp, #4]
 2142 00c6 002B     		cmp	r3, #0
 2143 00c8 09DD     		ble	.L161
1205:rt-thread/src/ipc.c ****                              RT_TIMER_CTRL_SET_TIME,
 2144              		.loc 1 1205 0
 2145 00ca 07F14C05 		add	r5, r7, #76
 2146 00ce 01AA     		add	r2, sp, #4
 2147 00d0 0021     		movs	r1, #0
 2148 00d2 2846     		mov	r0, r5
 2149 00d4 FFF7FEFF 		bl	rt_timer_control
 2150              	.LVL283:
1208:rt-thread/src/ipc.c ****         }
 2151              		.loc 1 1208 0
 2152 00d8 2846     		mov	r0, r5
 2153 00da FFF7FEFF 		bl	rt_timer_start
 2154              	.LVL284:
 2155              	.L161:
1212:rt-thread/src/ipc.c **** 
 2156              		.loc 1 1212 0
 2157 00de 3046     		mov	r0, r6
 2158 00e0 FFF7FEFF 		bl	rt_hw_interrupt_enable
 2159              	.LVL285:
1215:rt-thread/src/ipc.c **** 
 2160              		.loc 1 1215 0
 2161 00e4 FFF7FEFF 		bl	rt_schedule
 2162              	.LVL286:
1217:rt-thread/src/ipc.c ****         {
 2163              		.loc 1 1217 0
 2164 00e8 386B     		ldr	r0, [r7, #48]
 2165 00ea 0028     		cmp	r0, #0
 2166 00ec D6D1     		bne	.L145
1224:rt-thread/src/ipc.c **** 
 2167              		.loc 1 1224 0
 2168 00ee FFF7FEFF 		bl	rt_hw_interrupt_disable
 2169              	.LVL287:
1227:rt-thread/src/ipc.c ****             *recved = thread->event_set;
 2170              		.loc 1 1227 0
 2171 00f2 089B     		ldr	r3, [sp, #32]
 2172 00f4 002B     		cmp	r3, #0
 2173 00f6 C9D0     		beq	.L152
1228:rt-thread/src/ipc.c ****     }
 2174              		.loc 1 1228 0
 2175 00f8 FB6B     		ldr	r3, [r7, #60]
 2176 00fa 089A     		ldr	r2, [sp, #32]
 2177 00fc 1360     		str	r3, [r2]
 2178 00fe C5E7     		b	.L152
 2179              	.LVL288:
 2180              	.L155:
ARM GAS  /tmp/ccOtHhPO.s 			page 65


 2181              	.LBB222:
 2182              	.LBB221:
  90:rt-thread/src/ipc.c ****         break;
 2183              		.loc 1 90 0
 2184 0100 07F11403 		add	r3, r7, #20
 2185              	.LVL289:
 2186              	.LBB214:
 2187              	.LBB215:
  75:rt-thread/include/rtservice.h ****     n->prev = l->prev;
 2188              		.loc 2 75 0
 2189 0104 6A68     		ldr	r2, [r5, #4]
 2190 0106 1360     		str	r3, [r2]
  76:rt-thread/include/rtservice.h **** 
 2191              		.loc 2 76 0
 2192 0108 6A68     		ldr	r2, [r5, #4]
 2193 010a BA61     		str	r2, [r7, #24]
  78:rt-thread/include/rtservice.h ****     n->next = l;
 2194              		.loc 2 78 0
 2195 010c 6B60     		str	r3, [r5, #4]
  79:rt-thread/include/rtservice.h **** }
 2196              		.loc 2 79 0
 2197 010e 7D61     		str	r5, [r7, #20]
 2198 0110 D8E7     		b	.L154
 2199              	.LVL290:
 2200              	.L156:
 2201              	.LBE215:
 2202              	.LBE214:
 2203              	.LBB216:
  99:rt-thread/src/ipc.c ****             {
 2204              		.loc 1 99 0
 2205 0112 6369     		ldr	r3, [r4, #20]
 2206              	.LVL291:
 2207              	.L157:
 2208 0114 9D42     		cmp	r5, r3
 2209 0116 0FD0     		beq	.L159
 2210              	.LVL292:
 104:rt-thread/src/ipc.c ****                 {
 2211              		.loc 1 104 0
 2212 0118 97F83510 		ldrb	r1, [r7, #53]	@ zero_extendqisi2
 2213 011c 93F82120 		ldrb	r2, [r3, #33]	@ zero_extendqisi2
 2214 0120 9142     		cmp	r1, r2
 2215 0122 01D3     		bcc	.L168
  99:rt-thread/src/ipc.c ****             {
 2216              		.loc 1 99 0
 2217 0124 1B68     		ldr	r3, [r3]
 2218              	.LVL293:
 2219 0126 F5E7     		b	.L157
 2220              	.LVL294:
 2221              	.L168:
 107:rt-thread/src/ipc.c ****                     break;
 2222              		.loc 1 107 0
 2223 0128 07F11402 		add	r2, r7, #20
 2224              	.LVL295:
 2225              	.LBB217:
 2226              	.LBB218:
  75:rt-thread/include/rtservice.h ****     n->prev = l->prev;
 2227              		.loc 2 75 0
ARM GAS  /tmp/ccOtHhPO.s 			page 66


 2228 012c 5968     		ldr	r1, [r3, #4]
 2229 012e 0A60     		str	r2, [r1]
  76:rt-thread/include/rtservice.h **** 
 2230              		.loc 2 76 0
 2231 0130 5968     		ldr	r1, [r3, #4]
 2232 0132 B961     		str	r1, [r7, #24]
  78:rt-thread/include/rtservice.h ****     n->next = l;
 2233              		.loc 2 78 0
 2234 0134 5A60     		str	r2, [r3, #4]
  79:rt-thread/include/rtservice.h **** }
 2235              		.loc 2 79 0
 2236 0136 7B61     		str	r3, [r7, #20]
 2237              	.LVL296:
 2238              	.L159:
 2239              	.LBE218:
 2240              	.LBE217:
 116:rt-thread/src/ipc.c ****                 rt_list_insert_before(list, &(thread->tlist));
 2241              		.loc 1 116 0
 2242 0138 9D42     		cmp	r5, r3
 2243 013a C3D1     		bne	.L154
 117:rt-thread/src/ipc.c ****         }
 2244              		.loc 1 117 0
 2245 013c 07F11403 		add	r3, r7, #20
 2246              	.LVL297:
 2247              	.LBB219:
 2248              	.LBB220:
  75:rt-thread/include/rtservice.h ****     n->prev = l->prev;
 2249              		.loc 2 75 0
 2250 0140 6A68     		ldr	r2, [r5, #4]
 2251 0142 1360     		str	r3, [r2]
  76:rt-thread/include/rtservice.h **** 
 2252              		.loc 2 76 0
 2253 0144 6A68     		ldr	r2, [r5, #4]
 2254 0146 BA61     		str	r2, [r7, #24]
  78:rt-thread/include/rtservice.h ****     n->next = l;
 2255              		.loc 2 78 0
 2256 0148 6B60     		str	r3, [r5, #4]
  79:rt-thread/include/rtservice.h **** }
 2257              		.loc 2 79 0
 2258 014a 7D61     		str	r5, [r7, #20]
 2259 014c BAE7     		b	.L154
 2260              	.LVL298:
 2261              	.L163:
 2262              	.LBE220:
 2263              	.LBE219:
 2264              	.LBE216:
 2265              	.LBE221:
 2266              	.LBE222:
1144:rt-thread/src/ipc.c **** 
 2267              		.loc 1 1144 0
 2268 014e 4FF0FF30 		mov	r0, #-1
 2269              	.LVL299:
 2270 0152 A3E7     		b	.L145
 2271              	.L170:
 2272              		.align	2
 2273              	.L169:
 2274 0154 00000000 		.word	rt_object_trytake_hook
ARM GAS  /tmp/ccOtHhPO.s 			page 67


 2275 0158 00000000 		.word	rt_object_take_hook
 2276              		.cfi_endproc
 2277              	.LFE39:
 2279              		.section	.text.rt_event_control,"ax",%progbits
 2280              		.align	1
 2281              		.global	rt_event_control
 2282              		.syntax unified
 2283              		.thumb
 2284              		.thumb_func
 2285              		.fpu fpv4-sp-d16
 2287              	rt_event_control:
 2288              	.LFB40:
1238:rt-thread/src/ipc.c **** RTM_EXPORT(rt_event_recv);
1239:rt-thread/src/ipc.c **** 
1240:rt-thread/src/ipc.c **** /**
1241:rt-thread/src/ipc.c ****  * This function can get or set some extra attributions of an event object.
1242:rt-thread/src/ipc.c ****  *
1243:rt-thread/src/ipc.c ****  * @param event the event object
1244:rt-thread/src/ipc.c ****  * @param cmd the execution command
1245:rt-thread/src/ipc.c ****  * @param arg the execution argument
1246:rt-thread/src/ipc.c ****  *
1247:rt-thread/src/ipc.c ****  * @return the error code
1248:rt-thread/src/ipc.c ****  */
1249:rt-thread/src/ipc.c **** rt_err_t rt_event_control(rt_event_t event, int cmd, void *arg)
1250:rt-thread/src/ipc.c **** {
 2289              		.loc 1 1250 0
 2290              		.cfi_startproc
 2291              		@ args = 0, pretend = 0, frame = 0
 2292              		@ frame_needed = 0, uses_anonymous_args = 0
 2293              	.LVL300:
1251:rt-thread/src/ipc.c ****     rt_ubase_t level;
1252:rt-thread/src/ipc.c **** 
1253:rt-thread/src/ipc.c ****     /* parameter check */
1254:rt-thread/src/ipc.c ****     RT_ASSERT(event != RT_NULL);
1255:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&event->parent.parent) == RT_Object_Class_Event);
1256:rt-thread/src/ipc.c **** 
1257:rt-thread/src/ipc.c ****     if (cmd == RT_IPC_CMD_RESET)
 2294              		.loc 1 1257 0
 2295 0000 0129     		cmp	r1, #1
 2296 0002 20D1     		bne	.L175
1250:rt-thread/src/ipc.c ****     rt_ubase_t level;
 2297              		.loc 1 1250 0
 2298 0004 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2299              	.LCFI31:
 2300              		.cfi_def_cfa_offset 24
 2301              		.cfi_offset 3, -24
 2302              		.cfi_offset 4, -20
 2303              		.cfi_offset 5, -16
 2304              		.cfi_offset 6, -12
 2305              		.cfi_offset 7, -8
 2306              		.cfi_offset 14, -4
 2307 0006 0646     		mov	r6, r0
1258:rt-thread/src/ipc.c ****     {
1259:rt-thread/src/ipc.c ****         /* disable interrupt */
1260:rt-thread/src/ipc.c ****         level = rt_hw_interrupt_disable();
 2308              		.loc 1 1260 0
 2309 0008 FFF7FEFF 		bl	rt_hw_interrupt_disable
ARM GAS  /tmp/ccOtHhPO.s 			page 68


 2310              	.LVL301:
 2311 000c 0746     		mov	r7, r0
 2312              	.LVL302:
1261:rt-thread/src/ipc.c **** 
1262:rt-thread/src/ipc.c ****         /* resume all waiting thread */
1263:rt-thread/src/ipc.c ****         rt_ipc_list_resume_all(&event->parent.suspend_thread);
 2313              		.loc 1 1263 0
 2314 000e 06F11404 		add	r4, r6, #20
 2315              	.LVL303:
 2316 0012 0CE0     		b	.L173
 2317              	.LVL304:
 2318              	.L174:
 2319              	.LBB227:
 2320              	.LBB228:
 166:rt-thread/src/ipc.c **** 
 2321              		.loc 1 166 0
 2322 0014 FFF7FEFF 		bl	rt_hw_interrupt_disable
 2323              	.LVL305:
 2324 0018 0546     		mov	r5, r0
 2325              	.LVL306:
 169:rt-thread/src/ipc.c ****         /* set error code to RT_ERROR */
 2326              		.loc 1 169 0
 2327 001a 2068     		ldr	r0, [r4]
 2328              	.LVL307:
 171:rt-thread/src/ipc.c **** 
 2329              		.loc 1 171 0
 2330 001c 4FF0FF33 		mov	r3, #-1
 2331 0020 C361     		str	r3, [r0, #28]
 178:rt-thread/src/ipc.c **** 
 2332              		.loc 1 178 0
 2333 0022 1438     		subs	r0, r0, #20
 2334              	.LVL308:
 2335 0024 FFF7FEFF 		bl	rt_thread_resume
 2336              	.LVL309:
 181:rt-thread/src/ipc.c ****     }
 2337              		.loc 1 181 0
 2338 0028 2846     		mov	r0, r5
 2339 002a FFF7FEFF 		bl	rt_hw_interrupt_enable
 2340              	.LVL310:
 2341              	.L173:
 2342              	.LBB229:
 2343              	.LBB230:
 2344              		.loc 2 100 0
 2345 002e 2368     		ldr	r3, [r4]
 2346              	.LVL311:
 2347              	.LBE230:
 2348              	.LBE229:
 163:rt-thread/src/ipc.c ****     {
 2349              		.loc 1 163 0
 2350 0030 9C42     		cmp	r4, r3
 2351 0032 EFD1     		bne	.L174
 2352              	.LVL312:
 2353              	.LBE228:
 2354              	.LBE227:
1264:rt-thread/src/ipc.c **** 
1265:rt-thread/src/ipc.c ****         /* initialize event set */
1266:rt-thread/src/ipc.c ****         event->set = 0;
ARM GAS  /tmp/ccOtHhPO.s 			page 69


 2355              		.loc 1 1266 0
 2356 0034 0024     		movs	r4, #0
 2357 0036 F461     		str	r4, [r6, #28]
1267:rt-thread/src/ipc.c **** 
1268:rt-thread/src/ipc.c ****         /* enable interrupt */
1269:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(level);
 2358              		.loc 1 1269 0
 2359 0038 3846     		mov	r0, r7
 2360 003a FFF7FEFF 		bl	rt_hw_interrupt_enable
 2361              	.LVL313:
1270:rt-thread/src/ipc.c **** 
1271:rt-thread/src/ipc.c ****         rt_schedule();
 2362              		.loc 1 1271 0
 2363 003e FFF7FEFF 		bl	rt_schedule
 2364              	.LVL314:
1272:rt-thread/src/ipc.c **** 
1273:rt-thread/src/ipc.c ****         return RT_EOK;
 2365              		.loc 1 1273 0
 2366 0042 2046     		mov	r0, r4
 2367 0044 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2368              	.LVL315:
 2369              	.L175:
 2370              	.LCFI32:
 2371              		.cfi_def_cfa_offset 0
 2372              		.cfi_restore 3
 2373              		.cfi_restore 4
 2374              		.cfi_restore 5
 2375              		.cfi_restore 6
 2376              		.cfi_restore 7
 2377              		.cfi_restore 14
1274:rt-thread/src/ipc.c ****     }
1275:rt-thread/src/ipc.c **** 
1276:rt-thread/src/ipc.c ****     return -RT_ERROR;
 2378              		.loc 1 1276 0
 2379 0046 4FF0FF30 		mov	r0, #-1
 2380              	.LVL316:
 2381 004a 7047     		bx	lr
 2382              		.cfi_endproc
 2383              	.LFE40:
 2385              		.section	.text.rt_mq_init,"ax",%progbits
 2386              		.align	1
 2387              		.global	rt_mq_init
 2388              		.syntax unified
 2389              		.thumb
 2390              		.thumb_func
 2391              		.fpu fpv4-sp-d16
 2393              	rt_mq_init:
 2394              	.LFB41:
1277:rt-thread/src/ipc.c **** }
1278:rt-thread/src/ipc.c **** RTM_EXPORT(rt_event_control);
1279:rt-thread/src/ipc.c **** #endif /* end of RT_USING_EVENT */
1280:rt-thread/src/ipc.c **** 
1281:rt-thread/src/ipc.c **** #ifdef RT_USING_MAILBOX
1282:rt-thread/src/ipc.c **** /**
1283:rt-thread/src/ipc.c ****  * This function will initialize a mailbox and put it under control of resource
1284:rt-thread/src/ipc.c ****  * management.
1285:rt-thread/src/ipc.c ****  *
ARM GAS  /tmp/ccOtHhPO.s 			page 70


1286:rt-thread/src/ipc.c ****  * @param mb the mailbox object
1287:rt-thread/src/ipc.c ****  * @param name the name of mailbox
1288:rt-thread/src/ipc.c ****  * @param msgpool the begin address of buffer to save received mail
1289:rt-thread/src/ipc.c ****  * @param size the size of mailbox
1290:rt-thread/src/ipc.c ****  * @param flag the flag of mailbox
1291:rt-thread/src/ipc.c ****  *
1292:rt-thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
1293:rt-thread/src/ipc.c ****  */
1294:rt-thread/src/ipc.c **** rt_err_t rt_mb_init(rt_mailbox_t mb,
1295:rt-thread/src/ipc.c ****                     const char  *name,
1296:rt-thread/src/ipc.c ****                     void        *msgpool,
1297:rt-thread/src/ipc.c ****                     rt_size_t    size,
1298:rt-thread/src/ipc.c ****                     rt_uint8_t   flag)
1299:rt-thread/src/ipc.c **** {
1300:rt-thread/src/ipc.c ****     RT_ASSERT(mb != RT_NULL);
1301:rt-thread/src/ipc.c **** 
1302:rt-thread/src/ipc.c ****     /* initialize object */
1303:rt-thread/src/ipc.c ****     rt_object_init(&(mb->parent.parent), RT_Object_Class_MailBox, name);
1304:rt-thread/src/ipc.c **** 
1305:rt-thread/src/ipc.c ****     /* set parent flag */
1306:rt-thread/src/ipc.c ****     mb->parent.parent.flag = flag;
1307:rt-thread/src/ipc.c **** 
1308:rt-thread/src/ipc.c ****     /* initialize ipc object */
1309:rt-thread/src/ipc.c ****     rt_ipc_object_init(&(mb->parent));
1310:rt-thread/src/ipc.c **** 
1311:rt-thread/src/ipc.c ****     /* initialize mailbox */
1312:rt-thread/src/ipc.c ****     mb->msg_pool   = (rt_ubase_t *)msgpool;
1313:rt-thread/src/ipc.c ****     mb->size       = size;
1314:rt-thread/src/ipc.c ****     mb->entry      = 0;
1315:rt-thread/src/ipc.c ****     mb->in_offset  = 0;
1316:rt-thread/src/ipc.c ****     mb->out_offset = 0;
1317:rt-thread/src/ipc.c **** 
1318:rt-thread/src/ipc.c ****     /* initialize an additional list of sender suspend thread */
1319:rt-thread/src/ipc.c ****     rt_list_init(&(mb->suspend_sender_thread));
1320:rt-thread/src/ipc.c **** 
1321:rt-thread/src/ipc.c ****     return RT_EOK;
1322:rt-thread/src/ipc.c **** }
1323:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mb_init);
1324:rt-thread/src/ipc.c **** 
1325:rt-thread/src/ipc.c **** /**
1326:rt-thread/src/ipc.c ****  * This function will detach a mailbox from resource management
1327:rt-thread/src/ipc.c ****  *
1328:rt-thread/src/ipc.c ****  * @param mb the mailbox object
1329:rt-thread/src/ipc.c ****  *
1330:rt-thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
1331:rt-thread/src/ipc.c ****  */
1332:rt-thread/src/ipc.c **** rt_err_t rt_mb_detach(rt_mailbox_t mb)
1333:rt-thread/src/ipc.c **** {
1334:rt-thread/src/ipc.c ****     /* parameter check */
1335:rt-thread/src/ipc.c ****     RT_ASSERT(mb != RT_NULL);
1336:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
1337:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&mb->parent.parent));
1338:rt-thread/src/ipc.c **** 
1339:rt-thread/src/ipc.c ****     /* resume all suspended thread */
1340:rt-thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
1341:rt-thread/src/ipc.c ****     /* also resume all mailbox private suspended thread */
1342:rt-thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
ARM GAS  /tmp/ccOtHhPO.s 			page 71


1343:rt-thread/src/ipc.c **** 
1344:rt-thread/src/ipc.c ****     /* detach mailbox object */
1345:rt-thread/src/ipc.c ****     rt_object_detach(&(mb->parent.parent));
1346:rt-thread/src/ipc.c **** 
1347:rt-thread/src/ipc.c ****     return RT_EOK;
1348:rt-thread/src/ipc.c **** }
1349:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mb_detach);
1350:rt-thread/src/ipc.c **** 
1351:rt-thread/src/ipc.c **** #ifdef RT_USING_HEAP
1352:rt-thread/src/ipc.c **** /**
1353:rt-thread/src/ipc.c ****  * This function will create a mailbox object from system resource
1354:rt-thread/src/ipc.c ****  *
1355:rt-thread/src/ipc.c ****  * @param name the name of mailbox
1356:rt-thread/src/ipc.c ****  * @param size the size of mailbox
1357:rt-thread/src/ipc.c ****  * @param flag the flag of mailbox
1358:rt-thread/src/ipc.c ****  *
1359:rt-thread/src/ipc.c ****  * @return the created mailbox, RT_NULL on error happen
1360:rt-thread/src/ipc.c ****  */
1361:rt-thread/src/ipc.c **** rt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag)
1362:rt-thread/src/ipc.c **** {
1363:rt-thread/src/ipc.c ****     rt_mailbox_t mb;
1364:rt-thread/src/ipc.c **** 
1365:rt-thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
1366:rt-thread/src/ipc.c **** 
1367:rt-thread/src/ipc.c ****     /* allocate object */
1368:rt-thread/src/ipc.c ****     mb = (rt_mailbox_t)rt_object_allocate(RT_Object_Class_MailBox, name);
1369:rt-thread/src/ipc.c ****     if (mb == RT_NULL)
1370:rt-thread/src/ipc.c ****         return mb;
1371:rt-thread/src/ipc.c **** 
1372:rt-thread/src/ipc.c ****     /* set parent */
1373:rt-thread/src/ipc.c ****     mb->parent.parent.flag = flag;
1374:rt-thread/src/ipc.c **** 
1375:rt-thread/src/ipc.c ****     /* initialize ipc object */
1376:rt-thread/src/ipc.c ****     rt_ipc_object_init(&(mb->parent));
1377:rt-thread/src/ipc.c **** 
1378:rt-thread/src/ipc.c ****     /* initialize mailbox */
1379:rt-thread/src/ipc.c ****     mb->size     = size;
1380:rt-thread/src/ipc.c ****     mb->msg_pool = (rt_ubase_t *)RT_KERNEL_MALLOC(mb->size * sizeof(rt_ubase_t));
1381:rt-thread/src/ipc.c ****     if (mb->msg_pool == RT_NULL)
1382:rt-thread/src/ipc.c ****     {
1383:rt-thread/src/ipc.c ****         /* delete mailbox object */
1384:rt-thread/src/ipc.c ****         rt_object_delete(&(mb->parent.parent));
1385:rt-thread/src/ipc.c **** 
1386:rt-thread/src/ipc.c ****         return RT_NULL;
1387:rt-thread/src/ipc.c ****     }
1388:rt-thread/src/ipc.c ****     mb->entry      = 0;
1389:rt-thread/src/ipc.c ****     mb->in_offset  = 0;
1390:rt-thread/src/ipc.c ****     mb->out_offset = 0;
1391:rt-thread/src/ipc.c **** 
1392:rt-thread/src/ipc.c ****     /* initialize an additional list of sender suspend thread */
1393:rt-thread/src/ipc.c ****     rt_list_init(&(mb->suspend_sender_thread));
1394:rt-thread/src/ipc.c **** 
1395:rt-thread/src/ipc.c ****     return mb;
1396:rt-thread/src/ipc.c **** }
1397:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mb_create);
1398:rt-thread/src/ipc.c **** 
1399:rt-thread/src/ipc.c **** /**
ARM GAS  /tmp/ccOtHhPO.s 			page 72


1400:rt-thread/src/ipc.c ****  * This function will delete a mailbox object and release the memory
1401:rt-thread/src/ipc.c ****  *
1402:rt-thread/src/ipc.c ****  * @param mb the mailbox object
1403:rt-thread/src/ipc.c ****  *
1404:rt-thread/src/ipc.c ****  * @return the error code
1405:rt-thread/src/ipc.c ****  */
1406:rt-thread/src/ipc.c **** rt_err_t rt_mb_delete(rt_mailbox_t mb)
1407:rt-thread/src/ipc.c **** {
1408:rt-thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
1409:rt-thread/src/ipc.c **** 
1410:rt-thread/src/ipc.c ****     /* parameter check */
1411:rt-thread/src/ipc.c ****     RT_ASSERT(mb != RT_NULL);
1412:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
1413:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&mb->parent.parent) == RT_FALSE);
1414:rt-thread/src/ipc.c **** 
1415:rt-thread/src/ipc.c ****     /* resume all suspended thread */
1416:rt-thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
1417:rt-thread/src/ipc.c **** 
1418:rt-thread/src/ipc.c ****     /* also resume all mailbox private suspended thread */
1419:rt-thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
1420:rt-thread/src/ipc.c **** 
1421:rt-thread/src/ipc.c ****     /* free mailbox pool */
1422:rt-thread/src/ipc.c ****     RT_KERNEL_FREE(mb->msg_pool);
1423:rt-thread/src/ipc.c **** 
1424:rt-thread/src/ipc.c ****     /* delete mailbox object */
1425:rt-thread/src/ipc.c ****     rt_object_delete(&(mb->parent.parent));
1426:rt-thread/src/ipc.c **** 
1427:rt-thread/src/ipc.c ****     return RT_EOK;
1428:rt-thread/src/ipc.c **** }
1429:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mb_delete);
1430:rt-thread/src/ipc.c **** #endif
1431:rt-thread/src/ipc.c **** 
1432:rt-thread/src/ipc.c **** /**
1433:rt-thread/src/ipc.c ****  * This function will send a mail to mailbox object. If the mailbox is full,
1434:rt-thread/src/ipc.c ****  * current thread will be suspended until timeout.
1435:rt-thread/src/ipc.c ****  *
1436:rt-thread/src/ipc.c ****  * @param mb the mailbox object
1437:rt-thread/src/ipc.c ****  * @param value the mail
1438:rt-thread/src/ipc.c ****  * @param timeout the waiting time
1439:rt-thread/src/ipc.c ****  *
1440:rt-thread/src/ipc.c ****  * @return the error code
1441:rt-thread/src/ipc.c ****  */
1442:rt-thread/src/ipc.c **** rt_err_t rt_mb_send_wait(rt_mailbox_t mb,
1443:rt-thread/src/ipc.c ****                          rt_ubase_t   value,
1444:rt-thread/src/ipc.c ****                          rt_int32_t   timeout)
1445:rt-thread/src/ipc.c **** {
1446:rt-thread/src/ipc.c ****     struct rt_thread *thread;
1447:rt-thread/src/ipc.c ****     register rt_ubase_t temp;
1448:rt-thread/src/ipc.c ****     rt_uint32_t tick_delta;
1449:rt-thread/src/ipc.c **** 
1450:rt-thread/src/ipc.c ****     /* parameter check */
1451:rt-thread/src/ipc.c ****     RT_ASSERT(mb != RT_NULL);
1452:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
1453:rt-thread/src/ipc.c **** 
1454:rt-thread/src/ipc.c ****     /* initialize delta tick */
1455:rt-thread/src/ipc.c ****     tick_delta = 0;
1456:rt-thread/src/ipc.c ****     /* get current thread */
ARM GAS  /tmp/ccOtHhPO.s 			page 73


1457:rt-thread/src/ipc.c ****     thread = rt_thread_self();
1458:rt-thread/src/ipc.c **** 
1459:rt-thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mb->parent.parent)));
1460:rt-thread/src/ipc.c **** 
1461:rt-thread/src/ipc.c ****     /* disable interrupt */
1462:rt-thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
1463:rt-thread/src/ipc.c **** 
1464:rt-thread/src/ipc.c ****     /* for non-blocking call */
1465:rt-thread/src/ipc.c ****     if (mb->entry == mb->size && timeout == 0)
1466:rt-thread/src/ipc.c ****     {
1467:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
1468:rt-thread/src/ipc.c **** 
1469:rt-thread/src/ipc.c ****         return -RT_EFULL;
1470:rt-thread/src/ipc.c ****     }
1471:rt-thread/src/ipc.c **** 
1472:rt-thread/src/ipc.c ****     /* mailbox is full */
1473:rt-thread/src/ipc.c ****     while (mb->entry == mb->size)
1474:rt-thread/src/ipc.c ****     {
1475:rt-thread/src/ipc.c ****         /* reset error number in thread */
1476:rt-thread/src/ipc.c ****         thread->error = RT_EOK;
1477:rt-thread/src/ipc.c **** 
1478:rt-thread/src/ipc.c ****         /* no waiting, return timeout */
1479:rt-thread/src/ipc.c ****         if (timeout == 0)
1480:rt-thread/src/ipc.c ****         {
1481:rt-thread/src/ipc.c ****             /* enable interrupt */
1482:rt-thread/src/ipc.c ****             rt_hw_interrupt_enable(temp);
1483:rt-thread/src/ipc.c **** 
1484:rt-thread/src/ipc.c ****             return -RT_EFULL;
1485:rt-thread/src/ipc.c ****         }
1486:rt-thread/src/ipc.c **** 
1487:rt-thread/src/ipc.c ****         RT_DEBUG_IN_THREAD_CONTEXT;
1488:rt-thread/src/ipc.c ****         /* suspend current thread */
1489:rt-thread/src/ipc.c ****         rt_ipc_list_suspend(&(mb->suspend_sender_thread),
1490:rt-thread/src/ipc.c ****                             thread,
1491:rt-thread/src/ipc.c ****                             mb->parent.parent.flag);
1492:rt-thread/src/ipc.c **** 
1493:rt-thread/src/ipc.c ****         /* has waiting time, start thread timer */
1494:rt-thread/src/ipc.c ****         if (timeout > 0)
1495:rt-thread/src/ipc.c ****         {
1496:rt-thread/src/ipc.c ****             /* get the start tick of timer */
1497:rt-thread/src/ipc.c ****             tick_delta = rt_tick_get();
1498:rt-thread/src/ipc.c **** 
1499:rt-thread/src/ipc.c ****             RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_send_wait: start timer of thread:%s\n",
1500:rt-thread/src/ipc.c ****                                         thread->name));
1501:rt-thread/src/ipc.c **** 
1502:rt-thread/src/ipc.c ****             /* reset the timeout of thread timer and start it */
1503:rt-thread/src/ipc.c ****             rt_timer_control(&(thread->thread_timer),
1504:rt-thread/src/ipc.c ****                              RT_TIMER_CTRL_SET_TIME,
1505:rt-thread/src/ipc.c ****                              &timeout);
1506:rt-thread/src/ipc.c ****             rt_timer_start(&(thread->thread_timer));
1507:rt-thread/src/ipc.c ****         }
1508:rt-thread/src/ipc.c **** 
1509:rt-thread/src/ipc.c ****         /* enable interrupt */
1510:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
1511:rt-thread/src/ipc.c **** 
1512:rt-thread/src/ipc.c ****         /* re-schedule */
1513:rt-thread/src/ipc.c ****         rt_schedule();
ARM GAS  /tmp/ccOtHhPO.s 			page 74


1514:rt-thread/src/ipc.c **** 
1515:rt-thread/src/ipc.c ****         /* resume from suspend state */
1516:rt-thread/src/ipc.c ****         if (thread->error != RT_EOK)
1517:rt-thread/src/ipc.c ****         {
1518:rt-thread/src/ipc.c ****             /* return error */
1519:rt-thread/src/ipc.c ****             return thread->error;
1520:rt-thread/src/ipc.c ****         }
1521:rt-thread/src/ipc.c **** 
1522:rt-thread/src/ipc.c ****         /* disable interrupt */
1523:rt-thread/src/ipc.c ****         temp = rt_hw_interrupt_disable();
1524:rt-thread/src/ipc.c **** 
1525:rt-thread/src/ipc.c ****         /* if it's not waiting forever and then re-calculate timeout tick */
1526:rt-thread/src/ipc.c ****         if (timeout > 0)
1527:rt-thread/src/ipc.c ****         {
1528:rt-thread/src/ipc.c ****             tick_delta = rt_tick_get() - tick_delta;
1529:rt-thread/src/ipc.c ****             timeout -= tick_delta;
1530:rt-thread/src/ipc.c ****             if (timeout < 0)
1531:rt-thread/src/ipc.c ****                 timeout = 0;
1532:rt-thread/src/ipc.c ****         }
1533:rt-thread/src/ipc.c ****     }
1534:rt-thread/src/ipc.c **** 
1535:rt-thread/src/ipc.c ****     /* set ptr */
1536:rt-thread/src/ipc.c ****     mb->msg_pool[mb->in_offset] = value;
1537:rt-thread/src/ipc.c ****     /* increase input offset */
1538:rt-thread/src/ipc.c ****     ++ mb->in_offset;
1539:rt-thread/src/ipc.c ****     if (mb->in_offset >= mb->size)
1540:rt-thread/src/ipc.c ****         mb->in_offset = 0;
1541:rt-thread/src/ipc.c ****     /* increase message entry */
1542:rt-thread/src/ipc.c ****     mb->entry ++;
1543:rt-thread/src/ipc.c **** 
1544:rt-thread/src/ipc.c ****     /* resume suspended thread */
1545:rt-thread/src/ipc.c ****     if (!rt_list_isempty(&mb->parent.suspend_thread))
1546:rt-thread/src/ipc.c ****     {
1547:rt-thread/src/ipc.c ****         rt_ipc_list_resume(&(mb->parent.suspend_thread));
1548:rt-thread/src/ipc.c **** 
1549:rt-thread/src/ipc.c ****         /* enable interrupt */
1550:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
1551:rt-thread/src/ipc.c **** 
1552:rt-thread/src/ipc.c ****         rt_schedule();
1553:rt-thread/src/ipc.c **** 
1554:rt-thread/src/ipc.c ****         return RT_EOK;
1555:rt-thread/src/ipc.c ****     }
1556:rt-thread/src/ipc.c **** 
1557:rt-thread/src/ipc.c ****     /* enable interrupt */
1558:rt-thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
1559:rt-thread/src/ipc.c **** 
1560:rt-thread/src/ipc.c ****     return RT_EOK;
1561:rt-thread/src/ipc.c **** }
1562:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mb_send_wait);
1563:rt-thread/src/ipc.c **** 
1564:rt-thread/src/ipc.c **** /**
1565:rt-thread/src/ipc.c ****  * This function will send a mail to mailbox object, if there are threads
1566:rt-thread/src/ipc.c ****  * suspended on mailbox object, it will be waked up. This function will return
1567:rt-thread/src/ipc.c ****  * immediately, if you want blocking send, use rt_mb_send_wait instead.
1568:rt-thread/src/ipc.c ****  *
1569:rt-thread/src/ipc.c ****  * @param mb the mailbox object
1570:rt-thread/src/ipc.c ****  * @param value the mail
ARM GAS  /tmp/ccOtHhPO.s 			page 75


1571:rt-thread/src/ipc.c ****  *
1572:rt-thread/src/ipc.c ****  * @return the error code
1573:rt-thread/src/ipc.c ****  */
1574:rt-thread/src/ipc.c **** rt_err_t rt_mb_send(rt_mailbox_t mb, rt_ubase_t value)
1575:rt-thread/src/ipc.c **** {
1576:rt-thread/src/ipc.c ****     return rt_mb_send_wait(mb, value, 0);
1577:rt-thread/src/ipc.c **** }
1578:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mb_send);
1579:rt-thread/src/ipc.c **** 
1580:rt-thread/src/ipc.c **** /**
1581:rt-thread/src/ipc.c ****  * This function will receive a mail from mailbox object, if there is no mail
1582:rt-thread/src/ipc.c ****  * in mailbox object, the thread shall wait for a specified time.
1583:rt-thread/src/ipc.c ****  *
1584:rt-thread/src/ipc.c ****  * @param mb the mailbox object
1585:rt-thread/src/ipc.c ****  * @param value the received mail will be saved in
1586:rt-thread/src/ipc.c ****  * @param timeout the waiting time
1587:rt-thread/src/ipc.c ****  *
1588:rt-thread/src/ipc.c ****  * @return the error code
1589:rt-thread/src/ipc.c ****  */
1590:rt-thread/src/ipc.c **** rt_err_t rt_mb_recv(rt_mailbox_t mb, rt_ubase_t *value, rt_int32_t timeout)
1591:rt-thread/src/ipc.c **** {
1592:rt-thread/src/ipc.c ****     struct rt_thread *thread;
1593:rt-thread/src/ipc.c ****     register rt_ubase_t temp;
1594:rt-thread/src/ipc.c ****     rt_uint32_t tick_delta;
1595:rt-thread/src/ipc.c **** 
1596:rt-thread/src/ipc.c ****     /* parameter check */
1597:rt-thread/src/ipc.c ****     RT_ASSERT(mb != RT_NULL);
1598:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
1599:rt-thread/src/ipc.c **** 
1600:rt-thread/src/ipc.c ****     /* initialize delta tick */
1601:rt-thread/src/ipc.c ****     tick_delta = 0;
1602:rt-thread/src/ipc.c ****     /* get current thread */
1603:rt-thread/src/ipc.c ****     thread = rt_thread_self();
1604:rt-thread/src/ipc.c **** 
1605:rt-thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mb->parent.parent)));
1606:rt-thread/src/ipc.c **** 
1607:rt-thread/src/ipc.c ****     /* disable interrupt */
1608:rt-thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
1609:rt-thread/src/ipc.c **** 
1610:rt-thread/src/ipc.c ****     /* for non-blocking call */
1611:rt-thread/src/ipc.c ****     if (mb->entry == 0 && timeout == 0)
1612:rt-thread/src/ipc.c ****     {
1613:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
1614:rt-thread/src/ipc.c **** 
1615:rt-thread/src/ipc.c ****         return -RT_ETIMEOUT;
1616:rt-thread/src/ipc.c ****     }
1617:rt-thread/src/ipc.c **** 
1618:rt-thread/src/ipc.c ****     /* mailbox is empty */
1619:rt-thread/src/ipc.c ****     while (mb->entry == 0)
1620:rt-thread/src/ipc.c ****     {
1621:rt-thread/src/ipc.c ****         /* reset error number in thread */
1622:rt-thread/src/ipc.c ****         thread->error = RT_EOK;
1623:rt-thread/src/ipc.c **** 
1624:rt-thread/src/ipc.c ****         /* no waiting, return timeout */
1625:rt-thread/src/ipc.c ****         if (timeout == 0)
1626:rt-thread/src/ipc.c ****         {
1627:rt-thread/src/ipc.c ****             /* enable interrupt */
ARM GAS  /tmp/ccOtHhPO.s 			page 76


1628:rt-thread/src/ipc.c ****             rt_hw_interrupt_enable(temp);
1629:rt-thread/src/ipc.c **** 
1630:rt-thread/src/ipc.c ****             thread->error = -RT_ETIMEOUT;
1631:rt-thread/src/ipc.c **** 
1632:rt-thread/src/ipc.c ****             return -RT_ETIMEOUT;
1633:rt-thread/src/ipc.c ****         }
1634:rt-thread/src/ipc.c **** 
1635:rt-thread/src/ipc.c ****         RT_DEBUG_IN_THREAD_CONTEXT;
1636:rt-thread/src/ipc.c ****         /* suspend current thread */
1637:rt-thread/src/ipc.c ****         rt_ipc_list_suspend(&(mb->parent.suspend_thread),
1638:rt-thread/src/ipc.c ****                             thread,
1639:rt-thread/src/ipc.c ****                             mb->parent.parent.flag);
1640:rt-thread/src/ipc.c **** 
1641:rt-thread/src/ipc.c ****         /* has waiting time, start thread timer */
1642:rt-thread/src/ipc.c ****         if (timeout > 0)
1643:rt-thread/src/ipc.c ****         {
1644:rt-thread/src/ipc.c ****             /* get the start tick of timer */
1645:rt-thread/src/ipc.c ****             tick_delta = rt_tick_get();
1646:rt-thread/src/ipc.c **** 
1647:rt-thread/src/ipc.c ****             RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_recv: start timer of thread:%s\n",
1648:rt-thread/src/ipc.c ****                                         thread->name));
1649:rt-thread/src/ipc.c **** 
1650:rt-thread/src/ipc.c ****             /* reset the timeout of thread timer and start it */
1651:rt-thread/src/ipc.c ****             rt_timer_control(&(thread->thread_timer),
1652:rt-thread/src/ipc.c ****                              RT_TIMER_CTRL_SET_TIME,
1653:rt-thread/src/ipc.c ****                              &timeout);
1654:rt-thread/src/ipc.c ****             rt_timer_start(&(thread->thread_timer));
1655:rt-thread/src/ipc.c ****         }
1656:rt-thread/src/ipc.c **** 
1657:rt-thread/src/ipc.c ****         /* enable interrupt */
1658:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
1659:rt-thread/src/ipc.c **** 
1660:rt-thread/src/ipc.c ****         /* re-schedule */
1661:rt-thread/src/ipc.c ****         rt_schedule();
1662:rt-thread/src/ipc.c **** 
1663:rt-thread/src/ipc.c ****         /* resume from suspend state */
1664:rt-thread/src/ipc.c ****         if (thread->error != RT_EOK)
1665:rt-thread/src/ipc.c ****         {
1666:rt-thread/src/ipc.c ****             /* return error */
1667:rt-thread/src/ipc.c ****             return thread->error;
1668:rt-thread/src/ipc.c ****         }
1669:rt-thread/src/ipc.c **** 
1670:rt-thread/src/ipc.c ****         /* disable interrupt */
1671:rt-thread/src/ipc.c ****         temp = rt_hw_interrupt_disable();
1672:rt-thread/src/ipc.c **** 
1673:rt-thread/src/ipc.c ****         /* if it's not waiting forever and then re-calculate timeout tick */
1674:rt-thread/src/ipc.c ****         if (timeout > 0)
1675:rt-thread/src/ipc.c ****         {
1676:rt-thread/src/ipc.c ****             tick_delta = rt_tick_get() - tick_delta;
1677:rt-thread/src/ipc.c ****             timeout -= tick_delta;
1678:rt-thread/src/ipc.c ****             if (timeout < 0)
1679:rt-thread/src/ipc.c ****                 timeout = 0;
1680:rt-thread/src/ipc.c ****         }
1681:rt-thread/src/ipc.c ****     }
1682:rt-thread/src/ipc.c **** 
1683:rt-thread/src/ipc.c ****     /* fill ptr */
1684:rt-thread/src/ipc.c ****     *value = mb->msg_pool[mb->out_offset];
ARM GAS  /tmp/ccOtHhPO.s 			page 77


1685:rt-thread/src/ipc.c **** 
1686:rt-thread/src/ipc.c ****     /* increase output offset */
1687:rt-thread/src/ipc.c ****     ++ mb->out_offset;
1688:rt-thread/src/ipc.c ****     if (mb->out_offset >= mb->size)
1689:rt-thread/src/ipc.c ****         mb->out_offset = 0;
1690:rt-thread/src/ipc.c ****     /* decrease message entry */
1691:rt-thread/src/ipc.c ****     mb->entry --;
1692:rt-thread/src/ipc.c **** 
1693:rt-thread/src/ipc.c ****     /* resume suspended thread */
1694:rt-thread/src/ipc.c ****     if (!rt_list_isempty(&(mb->suspend_sender_thread)))
1695:rt-thread/src/ipc.c ****     {
1696:rt-thread/src/ipc.c ****         rt_ipc_list_resume(&(mb->suspend_sender_thread));
1697:rt-thread/src/ipc.c **** 
1698:rt-thread/src/ipc.c ****         /* enable interrupt */
1699:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
1700:rt-thread/src/ipc.c **** 
1701:rt-thread/src/ipc.c ****         RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
1702:rt-thread/src/ipc.c **** 
1703:rt-thread/src/ipc.c ****         rt_schedule();
1704:rt-thread/src/ipc.c **** 
1705:rt-thread/src/ipc.c ****         return RT_EOK;
1706:rt-thread/src/ipc.c ****     }
1707:rt-thread/src/ipc.c **** 
1708:rt-thread/src/ipc.c ****     /* enable interrupt */
1709:rt-thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
1710:rt-thread/src/ipc.c **** 
1711:rt-thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
1712:rt-thread/src/ipc.c **** 
1713:rt-thread/src/ipc.c ****     return RT_EOK;
1714:rt-thread/src/ipc.c **** }
1715:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mb_recv);
1716:rt-thread/src/ipc.c **** 
1717:rt-thread/src/ipc.c **** /**
1718:rt-thread/src/ipc.c ****  * This function can get or set some extra attributions of a mailbox object.
1719:rt-thread/src/ipc.c ****  *
1720:rt-thread/src/ipc.c ****  * @param mb the mailbox object
1721:rt-thread/src/ipc.c ****  * @param cmd the execution command
1722:rt-thread/src/ipc.c ****  * @param arg the execution argument
1723:rt-thread/src/ipc.c ****  *
1724:rt-thread/src/ipc.c ****  * @return the error code
1725:rt-thread/src/ipc.c ****  */
1726:rt-thread/src/ipc.c **** rt_err_t rt_mb_control(rt_mailbox_t mb, int cmd, void *arg)
1727:rt-thread/src/ipc.c **** {
1728:rt-thread/src/ipc.c ****     rt_ubase_t level;
1729:rt-thread/src/ipc.c **** 
1730:rt-thread/src/ipc.c ****     /* parameter check */
1731:rt-thread/src/ipc.c ****     RT_ASSERT(mb != RT_NULL);
1732:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
1733:rt-thread/src/ipc.c **** 
1734:rt-thread/src/ipc.c ****     if (cmd == RT_IPC_CMD_RESET)
1735:rt-thread/src/ipc.c ****     {
1736:rt-thread/src/ipc.c ****         /* disable interrupt */
1737:rt-thread/src/ipc.c ****         level = rt_hw_interrupt_disable();
1738:rt-thread/src/ipc.c **** 
1739:rt-thread/src/ipc.c ****         /* resume all waiting thread */
1740:rt-thread/src/ipc.c ****         rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
1741:rt-thread/src/ipc.c ****         /* also resume all mailbox private suspended thread */
ARM GAS  /tmp/ccOtHhPO.s 			page 78


1742:rt-thread/src/ipc.c ****         rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
1743:rt-thread/src/ipc.c **** 
1744:rt-thread/src/ipc.c ****         /* re-init mailbox */
1745:rt-thread/src/ipc.c ****         mb->entry      = 0;
1746:rt-thread/src/ipc.c ****         mb->in_offset  = 0;
1747:rt-thread/src/ipc.c ****         mb->out_offset = 0;
1748:rt-thread/src/ipc.c **** 
1749:rt-thread/src/ipc.c ****         /* enable interrupt */
1750:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(level);
1751:rt-thread/src/ipc.c **** 
1752:rt-thread/src/ipc.c ****         rt_schedule();
1753:rt-thread/src/ipc.c **** 
1754:rt-thread/src/ipc.c ****         return RT_EOK;
1755:rt-thread/src/ipc.c ****     }
1756:rt-thread/src/ipc.c **** 
1757:rt-thread/src/ipc.c ****     return -RT_ERROR;
1758:rt-thread/src/ipc.c **** }
1759:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mb_control);
1760:rt-thread/src/ipc.c **** #endif /* end of RT_USING_MAILBOX */
1761:rt-thread/src/ipc.c **** 
1762:rt-thread/src/ipc.c **** #ifdef RT_USING_MESSAGEQUEUE
1763:rt-thread/src/ipc.c **** struct rt_mq_message
1764:rt-thread/src/ipc.c **** {
1765:rt-thread/src/ipc.c ****     struct rt_mq_message *next;
1766:rt-thread/src/ipc.c **** };
1767:rt-thread/src/ipc.c **** 
1768:rt-thread/src/ipc.c **** /**
1769:rt-thread/src/ipc.c ****  * This function will initialize a message queue and put it under control of
1770:rt-thread/src/ipc.c ****  * resource management.
1771:rt-thread/src/ipc.c ****  *
1772:rt-thread/src/ipc.c ****  * @param mq the message object
1773:rt-thread/src/ipc.c ****  * @param name the name of message queue
1774:rt-thread/src/ipc.c ****  * @param msgpool the beginning address of buffer to save messages
1775:rt-thread/src/ipc.c ****  * @param msg_size the maximum size of message
1776:rt-thread/src/ipc.c ****  * @param pool_size the size of buffer to save messages
1777:rt-thread/src/ipc.c ****  * @param flag the flag of message queue
1778:rt-thread/src/ipc.c ****  *
1779:rt-thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
1780:rt-thread/src/ipc.c ****  */
1781:rt-thread/src/ipc.c **** rt_err_t rt_mq_init(rt_mq_t     mq,
1782:rt-thread/src/ipc.c ****                     const char *name,
1783:rt-thread/src/ipc.c ****                     void       *msgpool,
1784:rt-thread/src/ipc.c ****                     rt_size_t   msg_size,
1785:rt-thread/src/ipc.c ****                     rt_size_t   pool_size,
1786:rt-thread/src/ipc.c ****                     rt_uint8_t  flag)
1787:rt-thread/src/ipc.c **** {
 2395              		.loc 1 1787 0
 2396              		.cfi_startproc
 2397              		@ args = 8, pretend = 0, frame = 0
 2398              		@ frame_needed = 0, uses_anonymous_args = 0
 2399              	.LVL317:
 2400 0000 70B5     		push	{r4, r5, r6, lr}
 2401              	.LCFI33:
 2402              		.cfi_def_cfa_offset 16
 2403              		.cfi_offset 4, -16
 2404              		.cfi_offset 5, -12
 2405              		.cfi_offset 6, -8
ARM GAS  /tmp/ccOtHhPO.s 			page 79


 2406              		.cfi_offset 14, -4
 2407 0002 0446     		mov	r4, r0
 2408 0004 1646     		mov	r6, r2
 2409 0006 1D46     		mov	r5, r3
1788:rt-thread/src/ipc.c ****     struct rt_mq_message *head;
1789:rt-thread/src/ipc.c ****     register rt_base_t temp;
1790:rt-thread/src/ipc.c **** 
1791:rt-thread/src/ipc.c ****     /* parameter check */
1792:rt-thread/src/ipc.c ****     RT_ASSERT(mq != RT_NULL);
1793:rt-thread/src/ipc.c **** 
1794:rt-thread/src/ipc.c ****     /* initialize object */
1795:rt-thread/src/ipc.c ****     rt_object_init(&(mq->parent.parent), RT_Object_Class_MessageQueue, name);
 2410              		.loc 1 1795 0
 2411 0008 0A46     		mov	r2, r1
 2412              	.LVL318:
 2413 000a 0621     		movs	r1, #6
 2414              	.LVL319:
 2415 000c FFF7FEFF 		bl	rt_object_init
 2416              	.LVL320:
1796:rt-thread/src/ipc.c **** 
1797:rt-thread/src/ipc.c ****     /* set parent flag */
1798:rt-thread/src/ipc.c ****     mq->parent.parent.flag = flag;
 2417              		.loc 1 1798 0
 2418 0010 9DF81430 		ldrb	r3, [sp, #20]	@ zero_extendqisi2
 2419 0014 6372     		strb	r3, [r4, #9]
 2420              	.LVL321:
 2421              	.LBB231:
 2422              	.LBB232:
  64:rt-thread/src/ipc.c **** 
 2423              		.loc 1 64 0
 2424 0016 04F11403 		add	r3, r4, #20
 2425              	.LVL322:
 2426              	.LBB233:
 2427              	.LBB234:
  49:rt-thread/include/rtservice.h **** }
 2428              		.loc 2 49 0
 2429 001a A361     		str	r3, [r4, #24]
 2430 001c 6361     		str	r3, [r4, #20]
 2431              	.LVL323:
 2432              	.LBE234:
 2433              	.LBE233:
 2434              	.LBE232:
 2435              	.LBE231:
1799:rt-thread/src/ipc.c **** 
1800:rt-thread/src/ipc.c ****     /* initialize ipc object */
1801:rt-thread/src/ipc.c ****     rt_ipc_object_init(&(mq->parent));
1802:rt-thread/src/ipc.c **** 
1803:rt-thread/src/ipc.c ****     /* set message pool */
1804:rt-thread/src/ipc.c ****     mq->msg_pool = msgpool;
 2436              		.loc 1 1804 0
 2437 001e E661     		str	r6, [r4, #28]
1805:rt-thread/src/ipc.c **** 
1806:rt-thread/src/ipc.c ****     /* get correct message size */
1807:rt-thread/src/ipc.c ****     mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
 2438              		.loc 1 1807 0
 2439 0020 EB1C     		adds	r3, r5, #3
 2440 0022 9BB2     		uxth	r3, r3
ARM GAS  /tmp/ccOtHhPO.s 			page 80


 2441 0024 23F00303 		bic	r3, r3, #3
 2442 0028 9BB2     		uxth	r3, r3
 2443 002a 2384     		strh	r3, [r4, #32]	@ movhi
1808:rt-thread/src/ipc.c ****     mq->max_msgs = pool_size / (mq->msg_size + sizeof(struct rt_mq_message));
 2444              		.loc 1 1808 0
 2445 002c 0433     		adds	r3, r3, #4
 2446 002e 049A     		ldr	r2, [sp, #16]
 2447 0030 B2FBF3F3 		udiv	r3, r2, r3
 2448 0034 6384     		strh	r3, [r4, #34]	@ movhi
1809:rt-thread/src/ipc.c **** 
1810:rt-thread/src/ipc.c ****     /* initialize message list */
1811:rt-thread/src/ipc.c ****     mq->msg_queue_head = RT_NULL;
 2449              		.loc 1 1811 0
 2450 0036 0022     		movs	r2, #0
 2451 0038 A262     		str	r2, [r4, #40]
1812:rt-thread/src/ipc.c ****     mq->msg_queue_tail = RT_NULL;
 2452              		.loc 1 1812 0
 2453 003a E262     		str	r2, [r4, #44]
1813:rt-thread/src/ipc.c **** 
1814:rt-thread/src/ipc.c ****     /* initialize message empty list */
1815:rt-thread/src/ipc.c ****     mq->msg_queue_free = RT_NULL;
 2454              		.loc 1 1815 0
 2455 003c 2263     		str	r2, [r4, #48]
 2456              	.LVL324:
1816:rt-thread/src/ipc.c ****     for (temp = 0; temp < mq->max_msgs; temp ++)
 2457              		.loc 1 1816 0
 2458 003e 09E0     		b	.L181
 2459              	.LVL325:
 2460              	.L182:
1817:rt-thread/src/ipc.c ****     {
1818:rt-thread/src/ipc.c ****         head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
 2461              		.loc 1 1818 0 discriminator 3
 2462 0040 E169     		ldr	r1, [r4, #28]
1819:rt-thread/src/ipc.c ****                                         temp * (mq->msg_size + sizeof(struct rt_mq_message)));
 2463              		.loc 1 1819 0 discriminator 3
 2464 0042 238C     		ldrh	r3, [r4, #32]
 2465 0044 0433     		adds	r3, r3, #4
 2466 0046 03FB02F3 		mul	r3, r3, r2
1818:rt-thread/src/ipc.c ****                                         temp * (mq->msg_size + sizeof(struct rt_mq_message)));
 2467              		.loc 1 1818 0 discriminator 3
 2468 004a C818     		adds	r0, r1, r3
 2469              	.LVL326:
1820:rt-thread/src/ipc.c ****         head->next = (struct rt_mq_message *)mq->msg_queue_free;
 2470              		.loc 1 1820 0 discriminator 3
 2471 004c 256B     		ldr	r5, [r4, #48]
 2472 004e CD50     		str	r5, [r1, r3]
1821:rt-thread/src/ipc.c ****         mq->msg_queue_free = head;
 2473              		.loc 1 1821 0 discriminator 3
 2474 0050 2063     		str	r0, [r4, #48]
1816:rt-thread/src/ipc.c ****     {
 2475              		.loc 1 1816 0 discriminator 3
 2476 0052 0132     		adds	r2, r2, #1
 2477              	.LVL327:
 2478              	.L181:
1816:rt-thread/src/ipc.c ****     {
 2479              		.loc 1 1816 0 is_stmt 0 discriminator 1
 2480 0054 638C     		ldrh	r3, [r4, #34]
ARM GAS  /tmp/ccOtHhPO.s 			page 81


 2481 0056 9A42     		cmp	r2, r3
 2482 0058 F2DB     		blt	.L182
1822:rt-thread/src/ipc.c ****     }
1823:rt-thread/src/ipc.c **** 
1824:rt-thread/src/ipc.c ****     /* the initial entry is zero */
1825:rt-thread/src/ipc.c ****     mq->entry = 0;
 2483              		.loc 1 1825 0 is_stmt 1
 2484 005a 0020     		movs	r0, #0
 2485 005c A084     		strh	r0, [r4, #36]	@ movhi
1826:rt-thread/src/ipc.c **** 
1827:rt-thread/src/ipc.c ****     /* initialize an additional list of sender suspend thread */
1828:rt-thread/src/ipc.c ****     rt_list_init(&(mq->suspend_sender_thread));
 2486              		.loc 1 1828 0
 2487 005e 04F13403 		add	r3, r4, #52
 2488              	.LVL328:
 2489              	.LBB235:
 2490              	.LBB236:
  49:rt-thread/include/rtservice.h **** }
 2491              		.loc 2 49 0
 2492 0062 A363     		str	r3, [r4, #56]
 2493 0064 6363     		str	r3, [r4, #52]
 2494              	.LVL329:
 2495              	.LBE236:
 2496              	.LBE235:
1829:rt-thread/src/ipc.c **** 
1830:rt-thread/src/ipc.c ****     return RT_EOK;
1831:rt-thread/src/ipc.c **** }
 2497              		.loc 1 1831 0
 2498 0066 70BD     		pop	{r4, r5, r6, pc}
 2499              		.cfi_endproc
 2500              	.LFE41:
 2502              		.section	.text.rt_mq_detach,"ax",%progbits
 2503              		.align	1
 2504              		.global	rt_mq_detach
 2505              		.syntax unified
 2506              		.thumb
 2507              		.thumb_func
 2508              		.fpu fpv4-sp-d16
 2510              	rt_mq_detach:
 2511              	.LFB42:
1832:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mq_init);
1833:rt-thread/src/ipc.c **** 
1834:rt-thread/src/ipc.c **** /**
1835:rt-thread/src/ipc.c ****  * This function will detach a message queue object from resource management
1836:rt-thread/src/ipc.c ****  *
1837:rt-thread/src/ipc.c ****  * @param mq the message queue object
1838:rt-thread/src/ipc.c ****  *
1839:rt-thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
1840:rt-thread/src/ipc.c ****  */
1841:rt-thread/src/ipc.c **** rt_err_t rt_mq_detach(rt_mq_t mq)
1842:rt-thread/src/ipc.c **** {
 2512              		.loc 1 1842 0
 2513              		.cfi_startproc
 2514              		@ args = 0, pretend = 0, frame = 0
 2515              		@ frame_needed = 0, uses_anonymous_args = 0
 2516              	.LVL330:
 2517 0000 70B5     		push	{r4, r5, r6, lr}
ARM GAS  /tmp/ccOtHhPO.s 			page 82


 2518              	.LCFI34:
 2519              		.cfi_def_cfa_offset 16
 2520              		.cfi_offset 4, -16
 2521              		.cfi_offset 5, -12
 2522              		.cfi_offset 6, -8
 2523              		.cfi_offset 14, -4
 2524 0002 0646     		mov	r6, r0
1843:rt-thread/src/ipc.c ****     /* parameter check */
1844:rt-thread/src/ipc.c ****     RT_ASSERT(mq != RT_NULL);
1845:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mq->parent.parent) == RT_Object_Class_MessageQueue);
1846:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&mq->parent.parent));
1847:rt-thread/src/ipc.c **** 
1848:rt-thread/src/ipc.c ****     /* resume all suspended thread */
1849:rt-thread/src/ipc.c ****     rt_ipc_list_resume_all(&mq->parent.suspend_thread);
 2525              		.loc 1 1849 0
 2526 0004 00F11404 		add	r4, r0, #20
 2527              	.LVL331:
 2528 0008 0CE0     		b	.L185
 2529              	.LVL332:
 2530              	.L186:
 2531              	.LBB245:
 2532              	.LBB246:
 166:rt-thread/src/ipc.c **** 
 2533              		.loc 1 166 0
 2534 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 2535              	.LVL333:
 2536 000e 0546     		mov	r5, r0
 2537              	.LVL334:
 169:rt-thread/src/ipc.c ****         /* set error code to RT_ERROR */
 2538              		.loc 1 169 0
 2539 0010 2068     		ldr	r0, [r4]
 2540              	.LVL335:
 171:rt-thread/src/ipc.c **** 
 2541              		.loc 1 171 0
 2542 0012 4FF0FF33 		mov	r3, #-1
 2543 0016 C361     		str	r3, [r0, #28]
 178:rt-thread/src/ipc.c **** 
 2544              		.loc 1 178 0
 2545 0018 1438     		subs	r0, r0, #20
 2546              	.LVL336:
 2547 001a FFF7FEFF 		bl	rt_thread_resume
 2548              	.LVL337:
 181:rt-thread/src/ipc.c ****     }
 2549              		.loc 1 181 0
 2550 001e 2846     		mov	r0, r5
 2551 0020 FFF7FEFF 		bl	rt_hw_interrupt_enable
 2552              	.LVL338:
 2553              	.L185:
 2554              	.LBB247:
 2555              	.LBB248:
 2556              		.loc 2 100 0
 2557 0024 2368     		ldr	r3, [r4]
 2558              	.LVL339:
 2559              	.LBE248:
 2560              	.LBE247:
 163:rt-thread/src/ipc.c ****     {
 2561              		.loc 1 163 0
ARM GAS  /tmp/ccOtHhPO.s 			page 83


 2562 0026 9C42     		cmp	r4, r3
 2563 0028 EFD1     		bne	.L186
 2564              	.LVL340:
 2565              	.LBE246:
 2566              	.LBE245:
1850:rt-thread/src/ipc.c ****     /* also resume all message queue private suspended thread */
1851:rt-thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mq->suspend_sender_thread));
 2567              		.loc 1 1851 0
 2568 002a 06F13404 		add	r4, r6, #52
 2569              	.LVL341:
 2570 002e 0CE0     		b	.L187
 2571              	.L188:
 2572              	.LBB249:
 2573              	.LBB250:
 166:rt-thread/src/ipc.c **** 
 2574              		.loc 1 166 0
 2575 0030 FFF7FEFF 		bl	rt_hw_interrupt_disable
 2576              	.LVL342:
 2577 0034 0546     		mov	r5, r0
 2578              	.LVL343:
 169:rt-thread/src/ipc.c ****         /* set error code to RT_ERROR */
 2579              		.loc 1 169 0
 2580 0036 2068     		ldr	r0, [r4]
 2581              	.LVL344:
 171:rt-thread/src/ipc.c **** 
 2582              		.loc 1 171 0
 2583 0038 4FF0FF33 		mov	r3, #-1
 2584 003c C361     		str	r3, [r0, #28]
 178:rt-thread/src/ipc.c **** 
 2585              		.loc 1 178 0
 2586 003e 1438     		subs	r0, r0, #20
 2587              	.LVL345:
 2588 0040 FFF7FEFF 		bl	rt_thread_resume
 2589              	.LVL346:
 181:rt-thread/src/ipc.c ****     }
 2590              		.loc 1 181 0
 2591 0044 2846     		mov	r0, r5
 2592 0046 FFF7FEFF 		bl	rt_hw_interrupt_enable
 2593              	.LVL347:
 2594              	.L187:
 2595              	.LBB251:
 2596              	.LBB252:
 2597              		.loc 2 100 0
 2598 004a 2368     		ldr	r3, [r4]
 2599              	.LVL348:
 2600              	.LBE252:
 2601              	.LBE251:
 163:rt-thread/src/ipc.c ****     {
 2602              		.loc 1 163 0
 2603 004c 9C42     		cmp	r4, r3
 2604 004e EFD1     		bne	.L188
 2605              	.LVL349:
 2606              	.LBE250:
 2607              	.LBE249:
1852:rt-thread/src/ipc.c **** 
1853:rt-thread/src/ipc.c ****     /* detach message queue object */
1854:rt-thread/src/ipc.c ****     rt_object_detach(&(mq->parent.parent));
ARM GAS  /tmp/ccOtHhPO.s 			page 84


 2608              		.loc 1 1854 0
 2609 0050 3046     		mov	r0, r6
 2610 0052 FFF7FEFF 		bl	rt_object_detach
 2611              	.LVL350:
1855:rt-thread/src/ipc.c **** 
1856:rt-thread/src/ipc.c ****     return RT_EOK;
1857:rt-thread/src/ipc.c **** }
 2612              		.loc 1 1857 0
 2613 0056 0020     		movs	r0, #0
 2614 0058 70BD     		pop	{r4, r5, r6, pc}
 2615              		.cfi_endproc
 2616              	.LFE42:
 2618              		.section	.text.rt_mq_create,"ax",%progbits
 2619              		.align	1
 2620              		.global	rt_mq_create
 2621              		.syntax unified
 2622              		.thumb
 2623              		.thumb_func
 2624              		.fpu fpv4-sp-d16
 2626              	rt_mq_create:
 2627              	.LFB43:
1858:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mq_detach);
1859:rt-thread/src/ipc.c **** 
1860:rt-thread/src/ipc.c **** #ifdef RT_USING_HEAP
1861:rt-thread/src/ipc.c **** /**
1862:rt-thread/src/ipc.c ****  * This function will create a message queue object from system resource
1863:rt-thread/src/ipc.c ****  *
1864:rt-thread/src/ipc.c ****  * @param name the name of message queue
1865:rt-thread/src/ipc.c ****  * @param msg_size the size of message
1866:rt-thread/src/ipc.c ****  * @param max_msgs the maximum number of message in queue
1867:rt-thread/src/ipc.c ****  * @param flag the flag of message queue
1868:rt-thread/src/ipc.c ****  *
1869:rt-thread/src/ipc.c ****  * @return the created message queue, RT_NULL on error happen
1870:rt-thread/src/ipc.c ****  */
1871:rt-thread/src/ipc.c **** rt_mq_t rt_mq_create(const char *name,
1872:rt-thread/src/ipc.c ****                      rt_size_t   msg_size,
1873:rt-thread/src/ipc.c ****                      rt_size_t   max_msgs,
1874:rt-thread/src/ipc.c ****                      rt_uint8_t  flag)
1875:rt-thread/src/ipc.c **** {
 2628              		.loc 1 1875 0
 2629              		.cfi_startproc
 2630              		@ args = 0, pretend = 0, frame = 0
 2631              		@ frame_needed = 0, uses_anonymous_args = 0
 2632              	.LVL351:
 2633 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2634              	.LCFI35:
 2635              		.cfi_def_cfa_offset 24
 2636              		.cfi_offset 3, -24
 2637              		.cfi_offset 4, -20
 2638              		.cfi_offset 5, -16
 2639              		.cfi_offset 6, -12
 2640              		.cfi_offset 7, -8
 2641              		.cfi_offset 14, -4
 2642 0002 0D46     		mov	r5, r1
 2643 0004 1646     		mov	r6, r2
 2644 0006 1F46     		mov	r7, r3
1876:rt-thread/src/ipc.c ****     struct rt_messagequeue *mq;
ARM GAS  /tmp/ccOtHhPO.s 			page 85


1877:rt-thread/src/ipc.c ****     struct rt_mq_message *head;
1878:rt-thread/src/ipc.c ****     register rt_base_t temp;
1879:rt-thread/src/ipc.c **** 
1880:rt-thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
1881:rt-thread/src/ipc.c **** 
1882:rt-thread/src/ipc.c ****     /* allocate object */
1883:rt-thread/src/ipc.c ****     mq = (rt_mq_t)rt_object_allocate(RT_Object_Class_MessageQueue, name);
 2645              		.loc 1 1883 0
 2646 0008 0146     		mov	r1, r0
 2647              	.LVL352:
 2648 000a 0620     		movs	r0, #6
 2649              	.LVL353:
 2650 000c FFF7FEFF 		bl	rt_object_allocate
 2651              	.LVL354:
1884:rt-thread/src/ipc.c ****     if (mq == RT_NULL)
 2652              		.loc 1 1884 0
 2653 0010 0446     		mov	r4, r0
 2654 0012 0028     		cmp	r0, #0
 2655 0014 30D0     		beq	.L190
1885:rt-thread/src/ipc.c ****         return mq;
1886:rt-thread/src/ipc.c **** 
1887:rt-thread/src/ipc.c ****     /* set parent */
1888:rt-thread/src/ipc.c ****     mq->parent.parent.flag = flag;
 2656              		.loc 1 1888 0
 2657 0016 4772     		strb	r7, [r0, #9]
 2658              	.LVL355:
 2659              	.LBB253:
 2660              	.LBB254:
  64:rt-thread/src/ipc.c **** 
 2661              		.loc 1 64 0
 2662 0018 00F11403 		add	r3, r0, #20
 2663              	.LVL356:
 2664              	.LBB255:
 2665              	.LBB256:
  49:rt-thread/include/rtservice.h **** }
 2666              		.loc 2 49 0
 2667 001c 8361     		str	r3, [r0, #24]
 2668 001e 4361     		str	r3, [r0, #20]
 2669              	.LVL357:
 2670              	.LBE256:
 2671              	.LBE255:
 2672              	.LBE254:
 2673              	.LBE253:
1889:rt-thread/src/ipc.c **** 
1890:rt-thread/src/ipc.c ****     /* initialize ipc object */
1891:rt-thread/src/ipc.c ****     rt_ipc_object_init(&(mq->parent));
1892:rt-thread/src/ipc.c **** 
1893:rt-thread/src/ipc.c ****     /* initialize message queue */
1894:rt-thread/src/ipc.c **** 
1895:rt-thread/src/ipc.c ****     /* get correct message size */
1896:rt-thread/src/ipc.c ****     mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
 2674              		.loc 1 1896 0
 2675 0020 EB1C     		adds	r3, r5, #3
 2676 0022 9BB2     		uxth	r3, r3
 2677 0024 23F00303 		bic	r3, r3, #3
 2678 0028 9BB2     		uxth	r3, r3
 2679 002a 0384     		strh	r3, [r0, #32]	@ movhi
ARM GAS  /tmp/ccOtHhPO.s 			page 86


1897:rt-thread/src/ipc.c ****     mq->max_msgs = max_msgs;
 2680              		.loc 1 1897 0
 2681 002c B0B2     		uxth	r0, r6
 2682              	.LVL358:
 2683 002e 6084     		strh	r0, [r4, #34]	@ movhi
1898:rt-thread/src/ipc.c **** 
1899:rt-thread/src/ipc.c ****     /* allocate message pool */
1900:rt-thread/src/ipc.c ****     mq->msg_pool = RT_KERNEL_MALLOC((mq->msg_size + sizeof(struct rt_mq_message)) * mq->max_msgs);
 2684              		.loc 1 1900 0
 2685 0030 0433     		adds	r3, r3, #4
 2686 0032 00FB03F0 		mul	r0, r0, r3
 2687 0036 FFF7FEFF 		bl	rt_malloc
 2688              	.LVL359:
 2689 003a E061     		str	r0, [r4, #28]
1901:rt-thread/src/ipc.c ****     if (mq->msg_pool == RT_NULL)
 2690              		.loc 1 1901 0
 2691 003c 20B1     		cbz	r0, .L196
1902:rt-thread/src/ipc.c ****     {
1903:rt-thread/src/ipc.c ****         rt_object_delete(&(mq->parent.parent));
1904:rt-thread/src/ipc.c **** 
1905:rt-thread/src/ipc.c ****         return RT_NULL;
1906:rt-thread/src/ipc.c ****     }
1907:rt-thread/src/ipc.c **** 
1908:rt-thread/src/ipc.c ****     /* initialize message list */
1909:rt-thread/src/ipc.c ****     mq->msg_queue_head = RT_NULL;
 2692              		.loc 1 1909 0
 2693 003e 0022     		movs	r2, #0
 2694 0040 A262     		str	r2, [r4, #40]
1910:rt-thread/src/ipc.c ****     mq->msg_queue_tail = RT_NULL;
 2695              		.loc 1 1910 0
 2696 0042 E262     		str	r2, [r4, #44]
1911:rt-thread/src/ipc.c **** 
1912:rt-thread/src/ipc.c ****     /* initialize message empty list */
1913:rt-thread/src/ipc.c ****     mq->msg_queue_free = RT_NULL;
 2697              		.loc 1 1913 0
 2698 0044 2263     		str	r2, [r4, #48]
 2699              	.LVL360:
1914:rt-thread/src/ipc.c ****     for (temp = 0; temp < mq->max_msgs; temp ++)
 2700              		.loc 1 1914 0
 2701 0046 0EE0     		b	.L193
 2702              	.LVL361:
 2703              	.L196:
1903:rt-thread/src/ipc.c **** 
 2704              		.loc 1 1903 0
 2705 0048 2046     		mov	r0, r4
 2706 004a FFF7FEFF 		bl	rt_object_delete
 2707              	.LVL362:
1905:rt-thread/src/ipc.c ****     }
 2708              		.loc 1 1905 0
 2709 004e 0024     		movs	r4, #0
 2710              	.LVL363:
 2711 0050 12E0     		b	.L190
 2712              	.LVL364:
 2713              	.L194:
1915:rt-thread/src/ipc.c ****     {
1916:rt-thread/src/ipc.c ****         head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
 2714              		.loc 1 1916 0 discriminator 3
ARM GAS  /tmp/ccOtHhPO.s 			page 87


 2715 0052 E169     		ldr	r1, [r4, #28]
1917:rt-thread/src/ipc.c ****                                         temp * (mq->msg_size + sizeof(struct rt_mq_message)));
 2716              		.loc 1 1917 0 discriminator 3
 2717 0054 238C     		ldrh	r3, [r4, #32]
 2718 0056 0433     		adds	r3, r3, #4
 2719 0058 03FB02F3 		mul	r3, r3, r2
1916:rt-thread/src/ipc.c ****                                         temp * (mq->msg_size + sizeof(struct rt_mq_message)));
 2720              		.loc 1 1916 0 discriminator 3
 2721 005c C818     		adds	r0, r1, r3
 2722              	.LVL365:
1918:rt-thread/src/ipc.c ****         head->next = (struct rt_mq_message *)mq->msg_queue_free;
 2723              		.loc 1 1918 0 discriminator 3
 2724 005e 256B     		ldr	r5, [r4, #48]
 2725 0060 CD50     		str	r5, [r1, r3]
1919:rt-thread/src/ipc.c ****         mq->msg_queue_free = head;
 2726              		.loc 1 1919 0 discriminator 3
 2727 0062 2063     		str	r0, [r4, #48]
1914:rt-thread/src/ipc.c ****     {
 2728              		.loc 1 1914 0 discriminator 3
 2729 0064 0132     		adds	r2, r2, #1
 2730              	.LVL366:
 2731              	.L193:
1914:rt-thread/src/ipc.c ****     {
 2732              		.loc 1 1914 0 is_stmt 0 discriminator 1
 2733 0066 638C     		ldrh	r3, [r4, #34]
 2734 0068 9A42     		cmp	r2, r3
 2735 006a F2DB     		blt	.L194
1920:rt-thread/src/ipc.c ****     }
1921:rt-thread/src/ipc.c **** 
1922:rt-thread/src/ipc.c ****     /* the initial entry is zero */
1923:rt-thread/src/ipc.c ****     mq->entry = 0;
 2736              		.loc 1 1923 0 is_stmt 1
 2737 006c 0023     		movs	r3, #0
 2738 006e A384     		strh	r3, [r4, #36]	@ movhi
1924:rt-thread/src/ipc.c **** 
1925:rt-thread/src/ipc.c ****     /* initialize an additional list of sender suspend thread */
1926:rt-thread/src/ipc.c ****     rt_list_init(&(mq->suspend_sender_thread));
 2739              		.loc 1 1926 0
 2740 0070 04F13403 		add	r3, r4, #52
 2741              	.LVL367:
 2742              	.LBB257:
 2743              	.LBB258:
  49:rt-thread/include/rtservice.h **** }
 2744              		.loc 2 49 0
 2745 0074 A363     		str	r3, [r4, #56]
 2746 0076 6363     		str	r3, [r4, #52]
 2747              	.LVL368:
 2748              	.L190:
 2749              	.LBE258:
 2750              	.LBE257:
1927:rt-thread/src/ipc.c **** 
1928:rt-thread/src/ipc.c ****     return mq;
1929:rt-thread/src/ipc.c **** }
 2751              		.loc 1 1929 0
 2752 0078 2046     		mov	r0, r4
 2753 007a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2754              		.cfi_endproc
ARM GAS  /tmp/ccOtHhPO.s 			page 88


 2755              	.LFE43:
 2757              		.section	.text.rt_mq_delete,"ax",%progbits
 2758              		.align	1
 2759              		.global	rt_mq_delete
 2760              		.syntax unified
 2761              		.thumb
 2762              		.thumb_func
 2763              		.fpu fpv4-sp-d16
 2765              	rt_mq_delete:
 2766              	.LFB44:
1930:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mq_create);
1931:rt-thread/src/ipc.c **** 
1932:rt-thread/src/ipc.c **** /**
1933:rt-thread/src/ipc.c ****  * This function will delete a message queue object and release the memory
1934:rt-thread/src/ipc.c ****  *
1935:rt-thread/src/ipc.c ****  * @param mq the message queue object
1936:rt-thread/src/ipc.c ****  *
1937:rt-thread/src/ipc.c ****  * @return the error code
1938:rt-thread/src/ipc.c ****  */
1939:rt-thread/src/ipc.c **** rt_err_t rt_mq_delete(rt_mq_t mq)
1940:rt-thread/src/ipc.c **** {
 2767              		.loc 1 1940 0
 2768              		.cfi_startproc
 2769              		@ args = 0, pretend = 0, frame = 0
 2770              		@ frame_needed = 0, uses_anonymous_args = 0
 2771              	.LVL369:
 2772 0000 70B5     		push	{r4, r5, r6, lr}
 2773              	.LCFI36:
 2774              		.cfi_def_cfa_offset 16
 2775              		.cfi_offset 4, -16
 2776              		.cfi_offset 5, -12
 2777              		.cfi_offset 6, -8
 2778              		.cfi_offset 14, -4
 2779 0002 0646     		mov	r6, r0
1941:rt-thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
1942:rt-thread/src/ipc.c **** 
1943:rt-thread/src/ipc.c ****     /* parameter check */
1944:rt-thread/src/ipc.c ****     RT_ASSERT(mq != RT_NULL);
1945:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mq->parent.parent) == RT_Object_Class_MessageQueue);
1946:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&mq->parent.parent) == RT_FALSE);
1947:rt-thread/src/ipc.c **** 
1948:rt-thread/src/ipc.c ****     /* resume all suspended thread */
1949:rt-thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mq->parent.suspend_thread));
 2780              		.loc 1 1949 0
 2781 0004 00F11404 		add	r4, r0, #20
 2782              	.LVL370:
 2783 0008 0CE0     		b	.L198
 2784              	.LVL371:
 2785              	.L199:
 2786              	.LBB267:
 2787              	.LBB268:
 166:rt-thread/src/ipc.c **** 
 2788              		.loc 1 166 0
 2789 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 2790              	.LVL372:
 2791 000e 0546     		mov	r5, r0
 2792              	.LVL373:
ARM GAS  /tmp/ccOtHhPO.s 			page 89


 169:rt-thread/src/ipc.c ****         /* set error code to RT_ERROR */
 2793              		.loc 1 169 0
 2794 0010 2068     		ldr	r0, [r4]
 2795              	.LVL374:
 171:rt-thread/src/ipc.c **** 
 2796              		.loc 1 171 0
 2797 0012 4FF0FF33 		mov	r3, #-1
 2798 0016 C361     		str	r3, [r0, #28]
 178:rt-thread/src/ipc.c **** 
 2799              		.loc 1 178 0
 2800 0018 1438     		subs	r0, r0, #20
 2801              	.LVL375:
 2802 001a FFF7FEFF 		bl	rt_thread_resume
 2803              	.LVL376:
 181:rt-thread/src/ipc.c ****     }
 2804              		.loc 1 181 0
 2805 001e 2846     		mov	r0, r5
 2806 0020 FFF7FEFF 		bl	rt_hw_interrupt_enable
 2807              	.LVL377:
 2808              	.L198:
 2809              	.LBB269:
 2810              	.LBB270:
 2811              		.loc 2 100 0
 2812 0024 2368     		ldr	r3, [r4]
 2813              	.LVL378:
 2814              	.LBE270:
 2815              	.LBE269:
 163:rt-thread/src/ipc.c ****     {
 2816              		.loc 1 163 0
 2817 0026 9C42     		cmp	r4, r3
 2818 0028 EFD1     		bne	.L199
 2819              	.LVL379:
 2820              	.LBE268:
 2821              	.LBE267:
1950:rt-thread/src/ipc.c ****     /* also resume all message queue private suspended thread */
1951:rt-thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mq->suspend_sender_thread));
 2822              		.loc 1 1951 0
 2823 002a 06F13404 		add	r4, r6, #52
 2824              	.LVL380:
 2825 002e 0CE0     		b	.L200
 2826              	.L201:
 2827              	.LBB271:
 2828              	.LBB272:
 166:rt-thread/src/ipc.c **** 
 2829              		.loc 1 166 0
 2830 0030 FFF7FEFF 		bl	rt_hw_interrupt_disable
 2831              	.LVL381:
 2832 0034 0546     		mov	r5, r0
 2833              	.LVL382:
 169:rt-thread/src/ipc.c ****         /* set error code to RT_ERROR */
 2834              		.loc 1 169 0
 2835 0036 2068     		ldr	r0, [r4]
 2836              	.LVL383:
 171:rt-thread/src/ipc.c **** 
 2837              		.loc 1 171 0
 2838 0038 4FF0FF33 		mov	r3, #-1
 2839 003c C361     		str	r3, [r0, #28]
ARM GAS  /tmp/ccOtHhPO.s 			page 90


 178:rt-thread/src/ipc.c **** 
 2840              		.loc 1 178 0
 2841 003e 1438     		subs	r0, r0, #20
 2842              	.LVL384:
 2843 0040 FFF7FEFF 		bl	rt_thread_resume
 2844              	.LVL385:
 181:rt-thread/src/ipc.c ****     }
 2845              		.loc 1 181 0
 2846 0044 2846     		mov	r0, r5
 2847 0046 FFF7FEFF 		bl	rt_hw_interrupt_enable
 2848              	.LVL386:
 2849              	.L200:
 2850              	.LBB273:
 2851              	.LBB274:
 2852              		.loc 2 100 0
 2853 004a 2368     		ldr	r3, [r4]
 2854              	.LVL387:
 2855              	.LBE274:
 2856              	.LBE273:
 163:rt-thread/src/ipc.c ****     {
 2857              		.loc 1 163 0
 2858 004c 9C42     		cmp	r4, r3
 2859 004e EFD1     		bne	.L201
 2860              	.LVL388:
 2861              	.LBE272:
 2862              	.LBE271:
1952:rt-thread/src/ipc.c **** 
1953:rt-thread/src/ipc.c ****     /* free message queue pool */
1954:rt-thread/src/ipc.c ****     RT_KERNEL_FREE(mq->msg_pool);
 2863              		.loc 1 1954 0
 2864 0050 F069     		ldr	r0, [r6, #28]
 2865 0052 FFF7FEFF 		bl	rt_free
 2866              	.LVL389:
1955:rt-thread/src/ipc.c **** 
1956:rt-thread/src/ipc.c ****     /* delete message queue object */
1957:rt-thread/src/ipc.c ****     rt_object_delete(&(mq->parent.parent));
 2867              		.loc 1 1957 0
 2868 0056 3046     		mov	r0, r6
 2869 0058 FFF7FEFF 		bl	rt_object_delete
 2870              	.LVL390:
1958:rt-thread/src/ipc.c **** 
1959:rt-thread/src/ipc.c ****     return RT_EOK;
1960:rt-thread/src/ipc.c **** }
 2871              		.loc 1 1960 0
 2872 005c 0020     		movs	r0, #0
 2873 005e 70BD     		pop	{r4, r5, r6, pc}
 2874              		.cfi_endproc
 2875              	.LFE44:
 2877              		.section	.text.rt_mq_send_wait,"ax",%progbits
 2878              		.align	1
 2879              		.global	rt_mq_send_wait
 2880              		.syntax unified
 2881              		.thumb
 2882              		.thumb_func
 2883              		.fpu fpv4-sp-d16
 2885              	rt_mq_send_wait:
 2886              	.LFB45:
ARM GAS  /tmp/ccOtHhPO.s 			page 91


1961:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mq_delete);
1962:rt-thread/src/ipc.c **** #endif
1963:rt-thread/src/ipc.c **** 
1964:rt-thread/src/ipc.c **** /**
1965:rt-thread/src/ipc.c ****  * This function will send a message to message queue object. If the message queue is full,
1966:rt-thread/src/ipc.c ****  * current thread will be suspended until timeout.
1967:rt-thread/src/ipc.c ****  *
1968:rt-thread/src/ipc.c ****  * @param mq the message queue object
1969:rt-thread/src/ipc.c ****  * @param buffer the message
1970:rt-thread/src/ipc.c ****  * @param size the size of buffer
1971:rt-thread/src/ipc.c ****  * @param timeout the waiting time
1972:rt-thread/src/ipc.c ****  *
1973:rt-thread/src/ipc.c ****  * @return the error code
1974:rt-thread/src/ipc.c ****  */
1975:rt-thread/src/ipc.c **** rt_err_t rt_mq_send_wait(rt_mq_t     mq,
1976:rt-thread/src/ipc.c ****                          const void *buffer,
1977:rt-thread/src/ipc.c ****                          rt_size_t   size,
1978:rt-thread/src/ipc.c ****                          rt_int32_t  timeout)
1979:rt-thread/src/ipc.c **** {
 2887              		.loc 1 1979 0
 2888              		.cfi_startproc
 2889              		@ args = 0, pretend = 0, frame = 8
 2890              		@ frame_needed = 0, uses_anonymous_args = 0
 2891              	.LVL391:
 2892 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2893              	.LCFI37:
 2894              		.cfi_def_cfa_offset 36
 2895              		.cfi_offset 4, -36
 2896              		.cfi_offset 5, -32
 2897              		.cfi_offset 6, -28
 2898              		.cfi_offset 7, -24
 2899              		.cfi_offset 8, -20
 2900              		.cfi_offset 9, -16
 2901              		.cfi_offset 10, -12
 2902              		.cfi_offset 11, -8
 2903              		.cfi_offset 14, -4
 2904 0004 83B0     		sub	sp, sp, #12
 2905              	.LCFI38:
 2906              		.cfi_def_cfa_offset 48
 2907 0006 0193     		str	r3, [sp, #4]
1980:rt-thread/src/ipc.c ****     register rt_ubase_t temp;
1981:rt-thread/src/ipc.c ****     struct rt_mq_message *msg;
1982:rt-thread/src/ipc.c ****     rt_uint32_t tick_delta;
1983:rt-thread/src/ipc.c ****     struct rt_thread *thread;
1984:rt-thread/src/ipc.c **** 
1985:rt-thread/src/ipc.c ****     /* parameter check */
1986:rt-thread/src/ipc.c ****     RT_ASSERT(mq != RT_NULL);
1987:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mq->parent.parent) == RT_Object_Class_MessageQueue);
1988:rt-thread/src/ipc.c ****     RT_ASSERT(buffer != RT_NULL);
1989:rt-thread/src/ipc.c ****     RT_ASSERT(size != 0);
1990:rt-thread/src/ipc.c **** 
1991:rt-thread/src/ipc.c ****     /* greater than one message size */
1992:rt-thread/src/ipc.c ****     if (size > mq->msg_size)
 2908              		.loc 1 1992 0
 2909 0008 038C     		ldrh	r3, [r0, #32]
 2910              	.LVL392:
 2911 000a 9342     		cmp	r3, r2
ARM GAS  /tmp/ccOtHhPO.s 			page 92


 2912 000c C0F0B680 		bcc	.L221
 2913 0010 9146     		mov	r9, r2
 2914 0012 8A46     		mov	r10, r1
 2915 0014 0646     		mov	r6, r0
 2916              	.LVL393:
1993:rt-thread/src/ipc.c ****         return -RT_ERROR;
1994:rt-thread/src/ipc.c **** 
1995:rt-thread/src/ipc.c ****     /* initialize delta tick */
1996:rt-thread/src/ipc.c ****     tick_delta = 0;
1997:rt-thread/src/ipc.c ****     /* get current thread */
1998:rt-thread/src/ipc.c ****     thread = rt_thread_self();
 2917              		.loc 1 1998 0
 2918 0016 FFF7FEFF 		bl	rt_thread_self
 2919              	.LVL394:
 2920 001a 0446     		mov	r4, r0
 2921              	.LVL395:
1999:rt-thread/src/ipc.c **** 
2000:rt-thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
 2922              		.loc 1 2000 0
 2923 001c 594B     		ldr	r3, .L232
 2924 001e 1B68     		ldr	r3, [r3]
 2925 0020 0BB1     		cbz	r3, .L205
 2926              		.loc 1 2000 0 is_stmt 0 discriminator 1
 2927 0022 3046     		mov	r0, r6
 2928              	.LVL396:
 2929 0024 9847     		blx	r3
 2930              	.LVL397:
 2931              	.L205:
2001:rt-thread/src/ipc.c **** 
2002:rt-thread/src/ipc.c ****     /* disable interrupt */
2003:rt-thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
 2932              		.loc 1 2003 0 is_stmt 1
 2933 0026 FFF7FEFF 		bl	rt_hw_interrupt_disable
 2934              	.LVL398:
 2935 002a 8046     		mov	r8, r0
 2936              	.LVL399:
2004:rt-thread/src/ipc.c **** 
2005:rt-thread/src/ipc.c ****     /* get a free list, there must be an empty item */
2006:rt-thread/src/ipc.c ****     msg = (struct rt_mq_message *)mq->msg_queue_free;
 2937              		.loc 1 2006 0
 2938 002c 336B     		ldr	r3, [r6, #48]
 2939              	.LVL400:
2007:rt-thread/src/ipc.c ****     /* for non-blocking call */
2008:rt-thread/src/ipc.c ****     if (msg == RT_NULL && timeout == 0)
 2940              		.loc 1 2008 0
 2941 002e 0BB1     		cbz	r3, .L225
 2942 0030 0027     		movs	r7, #0
 2943 0032 3EE0     		b	.L206
 2944              	.L225:
 2945              		.loc 1 2008 0 is_stmt 0 discriminator 1
 2946 0034 019B     		ldr	r3, [sp, #4]
 2947              	.LVL401:
 2948 0036 0BB1     		cbz	r3, .L226
 2949 0038 0027     		movs	r7, #0
 2950 003a 3AE0     		b	.L206
 2951              	.L226:
2009:rt-thread/src/ipc.c ****     {
ARM GAS  /tmp/ccOtHhPO.s 			page 93


2010:rt-thread/src/ipc.c ****         /* enable interrupt */
2011:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
 2952              		.loc 1 2011 0 is_stmt 1
 2953 003c FFF7FEFF 		bl	rt_hw_interrupt_enable
 2954              	.LVL402:
2012:rt-thread/src/ipc.c **** 
2013:rt-thread/src/ipc.c ****         return -RT_EFULL;
 2955              		.loc 1 2013 0
 2956 0040 6FF00200 		mvn	r0, #2
 2957 0044 04E0     		b	.L203
 2958              	.LVL403:
 2959              	.L229:
2014:rt-thread/src/ipc.c ****     }
2015:rt-thread/src/ipc.c **** 
2016:rt-thread/src/ipc.c ****     /* message queue is full */
2017:rt-thread/src/ipc.c ****     while ((msg = mq->msg_queue_free) == RT_NULL)
2018:rt-thread/src/ipc.c ****     {
2019:rt-thread/src/ipc.c ****         /* reset error number in thread */
2020:rt-thread/src/ipc.c ****         thread->error = RT_EOK;
2021:rt-thread/src/ipc.c **** 
2022:rt-thread/src/ipc.c ****         /* no waiting, return timeout */
2023:rt-thread/src/ipc.c ****         if (timeout == 0)
2024:rt-thread/src/ipc.c ****         {
2025:rt-thread/src/ipc.c ****             /* enable interrupt */
2026:rt-thread/src/ipc.c ****             rt_hw_interrupt_enable(temp);
 2960              		.loc 1 2026 0
 2961 0046 4046     		mov	r0, r8
 2962 0048 FFF7FEFF 		bl	rt_hw_interrupt_enable
 2963              	.LVL404:
2027:rt-thread/src/ipc.c **** 
2028:rt-thread/src/ipc.c ****             return -RT_EFULL;
 2964              		.loc 1 2028 0
 2965 004c 6FF00200 		mvn	r0, #2
 2966              	.LVL405:
 2967              	.L203:
2029:rt-thread/src/ipc.c ****         }
2030:rt-thread/src/ipc.c **** 
2031:rt-thread/src/ipc.c ****         RT_DEBUG_IN_THREAD_CONTEXT;
2032:rt-thread/src/ipc.c ****         /* suspend current thread */
2033:rt-thread/src/ipc.c ****         rt_ipc_list_suspend(&(mq->suspend_sender_thread),
2034:rt-thread/src/ipc.c ****                             thread,
2035:rt-thread/src/ipc.c ****                             mq->parent.parent.flag);
2036:rt-thread/src/ipc.c **** 
2037:rt-thread/src/ipc.c ****         /* has waiting time, start thread timer */
2038:rt-thread/src/ipc.c ****         if (timeout > 0)
2039:rt-thread/src/ipc.c ****         {
2040:rt-thread/src/ipc.c ****             /* get the start tick of timer */
2041:rt-thread/src/ipc.c ****             tick_delta = rt_tick_get();
2042:rt-thread/src/ipc.c **** 
2043:rt-thread/src/ipc.c ****             RT_DEBUG_LOG(RT_DEBUG_IPC, ("mq_send_wait: start timer of thread:%s\n",
2044:rt-thread/src/ipc.c ****                                         thread->name));
2045:rt-thread/src/ipc.c **** 
2046:rt-thread/src/ipc.c ****             /* reset the timeout of thread timer and start it */
2047:rt-thread/src/ipc.c ****             rt_timer_control(&(thread->thread_timer),
2048:rt-thread/src/ipc.c ****                              RT_TIMER_CTRL_SET_TIME,
2049:rt-thread/src/ipc.c ****                              &timeout);
2050:rt-thread/src/ipc.c ****             rt_timer_start(&(thread->thread_timer));
ARM GAS  /tmp/ccOtHhPO.s 			page 94


2051:rt-thread/src/ipc.c ****         }
2052:rt-thread/src/ipc.c **** 
2053:rt-thread/src/ipc.c ****         /* enable interrupt */
2054:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
2055:rt-thread/src/ipc.c **** 
2056:rt-thread/src/ipc.c ****         /* re-schedule */
2057:rt-thread/src/ipc.c ****         rt_schedule();
2058:rt-thread/src/ipc.c **** 
2059:rt-thread/src/ipc.c ****         /* resume from suspend state */
2060:rt-thread/src/ipc.c ****         if (thread->error != RT_EOK)
2061:rt-thread/src/ipc.c ****         {
2062:rt-thread/src/ipc.c ****             /* return error */
2063:rt-thread/src/ipc.c ****             return thread->error;
2064:rt-thread/src/ipc.c ****         }
2065:rt-thread/src/ipc.c **** 
2066:rt-thread/src/ipc.c ****         /* disable interrupt */
2067:rt-thread/src/ipc.c ****         temp = rt_hw_interrupt_disable();
2068:rt-thread/src/ipc.c **** 
2069:rt-thread/src/ipc.c ****         /* if it's not waiting forever and then re-calculate timeout tick */
2070:rt-thread/src/ipc.c ****         if (timeout > 0)
2071:rt-thread/src/ipc.c ****         {
2072:rt-thread/src/ipc.c ****             tick_delta = rt_tick_get() - tick_delta;
2073:rt-thread/src/ipc.c ****             timeout -= tick_delta;
2074:rt-thread/src/ipc.c ****             if (timeout < 0)
2075:rt-thread/src/ipc.c ****                 timeout = 0;
2076:rt-thread/src/ipc.c ****         }
2077:rt-thread/src/ipc.c ****     }
2078:rt-thread/src/ipc.c **** 
2079:rt-thread/src/ipc.c ****     /* move free list pointer */
2080:rt-thread/src/ipc.c ****     mq->msg_queue_free = msg->next;
2081:rt-thread/src/ipc.c **** 
2082:rt-thread/src/ipc.c ****     /* enable interrupt */
2083:rt-thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
2084:rt-thread/src/ipc.c **** 
2085:rt-thread/src/ipc.c ****     /* the msg is the new tailer of list, the next shall be NULL */
2086:rt-thread/src/ipc.c ****     msg->next = RT_NULL;
2087:rt-thread/src/ipc.c ****     /* copy buffer */
2088:rt-thread/src/ipc.c ****     rt_memcpy(msg + 1, buffer, size);
2089:rt-thread/src/ipc.c **** 
2090:rt-thread/src/ipc.c ****     /* disable interrupt */
2091:rt-thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
2092:rt-thread/src/ipc.c ****     /* link msg to message queue */
2093:rt-thread/src/ipc.c ****     if (mq->msg_queue_tail != RT_NULL)
2094:rt-thread/src/ipc.c ****     {
2095:rt-thread/src/ipc.c ****         /* if the tail exists, */
2096:rt-thread/src/ipc.c ****         ((struct rt_mq_message *)mq->msg_queue_tail)->next = msg;
2097:rt-thread/src/ipc.c ****     }
2098:rt-thread/src/ipc.c **** 
2099:rt-thread/src/ipc.c ****     /* set new tail */
2100:rt-thread/src/ipc.c ****     mq->msg_queue_tail = msg;
2101:rt-thread/src/ipc.c ****     /* if the head is empty, set head */
2102:rt-thread/src/ipc.c ****     if (mq->msg_queue_head == RT_NULL)
2103:rt-thread/src/ipc.c ****         mq->msg_queue_head = msg;
2104:rt-thread/src/ipc.c **** 
2105:rt-thread/src/ipc.c ****     /* increase message entry */
2106:rt-thread/src/ipc.c ****     mq->entry ++;
2107:rt-thread/src/ipc.c **** 
ARM GAS  /tmp/ccOtHhPO.s 			page 95


2108:rt-thread/src/ipc.c ****     /* resume suspended thread */
2109:rt-thread/src/ipc.c ****     if (!rt_list_isempty(&mq->parent.suspend_thread))
2110:rt-thread/src/ipc.c ****     {
2111:rt-thread/src/ipc.c ****         rt_ipc_list_resume(&(mq->parent.suspend_thread));
2112:rt-thread/src/ipc.c **** 
2113:rt-thread/src/ipc.c ****         /* enable interrupt */
2114:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
2115:rt-thread/src/ipc.c **** 
2116:rt-thread/src/ipc.c ****         rt_schedule();
2117:rt-thread/src/ipc.c **** 
2118:rt-thread/src/ipc.c ****         return RT_EOK;
2119:rt-thread/src/ipc.c ****     }
2120:rt-thread/src/ipc.c **** 
2121:rt-thread/src/ipc.c ****     /* enable interrupt */
2122:rt-thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
2123:rt-thread/src/ipc.c **** 
2124:rt-thread/src/ipc.c ****     return RT_EOK;
2125:rt-thread/src/ipc.c **** }
 2968              		.loc 1 2125 0
 2969 0050 03B0     		add	sp, sp, #12
 2970              	.LCFI39:
 2971              		.cfi_remember_state
 2972              		.cfi_def_cfa_offset 36
 2973              		@ sp needed
 2974 0052 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2975              	.LVL406:
 2976              	.L209:
 2977              	.LCFI40:
 2978              		.cfi_restore_state
 2979              	.LBB288:
 2980              	.LBB289:
  90:rt-thread/src/ipc.c ****         break;
 2981              		.loc 1 90 0
 2982 0056 04F11403 		add	r3, r4, #20
 2983              	.LVL407:
 2984              	.LBB290:
 2985              	.LBB291:
  75:rt-thread/include/rtservice.h ****     n->prev = l->prev;
 2986              		.loc 2 75 0
 2987 005a 6A68     		ldr	r2, [r5, #4]
 2988 005c 1360     		str	r3, [r2]
  76:rt-thread/include/rtservice.h **** 
 2989              		.loc 2 76 0
 2990 005e 6A68     		ldr	r2, [r5, #4]
 2991 0060 A261     		str	r2, [r4, #24]
  78:rt-thread/include/rtservice.h ****     n->next = l;
 2992              		.loc 2 78 0
 2993 0062 6B60     		str	r3, [r5, #4]
  79:rt-thread/include/rtservice.h **** }
 2994              		.loc 2 79 0
 2995 0064 6561     		str	r5, [r4, #20]
 2996              	.LVL408:
 2997              	.L208:
 2998              	.LBE291:
 2999              	.LBE290:
 3000              	.LBE289:
 3001              	.LBE288:
ARM GAS  /tmp/ccOtHhPO.s 			page 96


2038:rt-thread/src/ipc.c ****         {
 3002              		.loc 1 2038 0
 3003 0066 019B     		ldr	r3, [sp, #4]
 3004 0068 002B     		cmp	r3, #0
 3005 006a 0CDD     		ble	.L215
2041:rt-thread/src/ipc.c **** 
 3006              		.loc 1 2041 0
 3007 006c FFF7FEFF 		bl	rt_tick_get
 3008              	.LVL409:
 3009 0070 0746     		mov	r7, r0
 3010              	.LVL410:
2047:rt-thread/src/ipc.c ****                              RT_TIMER_CTRL_SET_TIME,
 3011              		.loc 1 2047 0
 3012 0072 04F14C05 		add	r5, r4, #76
 3013 0076 01AA     		add	r2, sp, #4
 3014 0078 0021     		movs	r1, #0
 3015 007a 2846     		mov	r0, r5
 3016              	.LVL411:
 3017 007c FFF7FEFF 		bl	rt_timer_control
 3018              	.LVL412:
2050:rt-thread/src/ipc.c ****         }
 3019              		.loc 1 2050 0
 3020 0080 2846     		mov	r0, r5
 3021 0082 FFF7FEFF 		bl	rt_timer_start
 3022              	.LVL413:
 3023              	.L215:
2054:rt-thread/src/ipc.c **** 
 3024              		.loc 1 2054 0
 3025 0086 4046     		mov	r0, r8
 3026 0088 FFF7FEFF 		bl	rt_hw_interrupt_enable
 3027              	.LVL414:
2057:rt-thread/src/ipc.c **** 
 3028              		.loc 1 2057 0
 3029 008c FFF7FEFF 		bl	rt_schedule
 3030              	.LVL415:
2060:rt-thread/src/ipc.c ****         {
 3031              		.loc 1 2060 0
 3032 0090 206B     		ldr	r0, [r4, #48]
 3033 0092 0028     		cmp	r0, #0
 3034 0094 DCD1     		bne	.L203
2067:rt-thread/src/ipc.c **** 
 3035              		.loc 1 2067 0
 3036 0096 FFF7FEFF 		bl	rt_hw_interrupt_disable
 3037              	.LVL416:
 3038 009a 8046     		mov	r8, r0
 3039              	.LVL417:
2070:rt-thread/src/ipc.c ****         {
 3040              		.loc 1 2070 0
 3041 009c 019B     		ldr	r3, [sp, #4]
 3042 009e 002B     		cmp	r3, #0
 3043 00a0 07DD     		ble	.L206
2072:rt-thread/src/ipc.c ****             timeout -= tick_delta;
 3044              		.loc 1 2072 0
 3045 00a2 FFF7FEFF 		bl	rt_tick_get
 3046              	.LVL418:
 3047 00a6 C71B     		subs	r7, r0, r7
 3048              	.LVL419:
ARM GAS  /tmp/ccOtHhPO.s 			page 97


2073:rt-thread/src/ipc.c ****             if (timeout < 0)
 3049              		.loc 1 2073 0
 3050 00a8 019B     		ldr	r3, [sp, #4]
 3051 00aa DB1B     		subs	r3, r3, r7
 3052 00ac 0193     		str	r3, [sp, #4]
2074:rt-thread/src/ipc.c ****                 timeout = 0;
 3053              		.loc 1 2074 0
 3054 00ae 002B     		cmp	r3, #0
 3055 00b0 32DB     		blt	.L227
 3056              	.LVL420:
 3057              	.L206:
2017:rt-thread/src/ipc.c ****     {
 3058              		.loc 1 2017 0
 3059 00b2 356B     		ldr	r5, [r6, #48]
 3060              	.LVL421:
 3061 00b4 002D     		cmp	r5, #0
 3062 00b6 32D1     		bne	.L228
2020:rt-thread/src/ipc.c **** 
 3063              		.loc 1 2020 0
 3064 00b8 0023     		movs	r3, #0
 3065 00ba 2363     		str	r3, [r4, #48]
2023:rt-thread/src/ipc.c ****         {
 3066              		.loc 1 2023 0
 3067 00bc 019B     		ldr	r3, [sp, #4]
 3068 00be 002B     		cmp	r3, #0
 3069 00c0 C1D0     		beq	.L229
2033:rt-thread/src/ipc.c ****                             thread,
 3070              		.loc 1 2033 0
 3071 00c2 06F13405 		add	r5, r6, #52
 3072              	.LVL422:
 3073 00c6 96F809B0 		ldrb	fp, [r6, #9]	@ zero_extendqisi2
 3074              	.LVL423:
 3075              	.LBB298:
 3076              	.LBB297:
  85:rt-thread/src/ipc.c **** 
 3077              		.loc 1 85 0
 3078 00ca 2046     		mov	r0, r4
 3079 00cc FFF7FEFF 		bl	rt_thread_suspend
 3080              	.LVL424:
  87:rt-thread/src/ipc.c ****     {
 3081              		.loc 1 87 0
 3082 00d0 BBF1000F 		cmp	fp, #0
 3083 00d4 BFD0     		beq	.L209
 3084 00d6 BBF1010F 		cmp	fp, #1
 3085 00da C4D1     		bne	.L208
 3086              	.LBB292:
  99:rt-thread/src/ipc.c ****             {
 3087              		.loc 1 99 0
 3088 00dc 736B     		ldr	r3, [r6, #52]
 3089              	.LVL425:
 3090              	.L211:
 3091 00de 9D42     		cmp	r5, r3
 3092 00e0 0FD0     		beq	.L213
 3093              	.LVL426:
 104:rt-thread/src/ipc.c ****                 {
 3094              		.loc 1 104 0
 3095 00e2 94F83510 		ldrb	r1, [r4, #53]	@ zero_extendqisi2
ARM GAS  /tmp/ccOtHhPO.s 			page 98


 3096 00e6 93F82120 		ldrb	r2, [r3, #33]	@ zero_extendqisi2
 3097 00ea 9142     		cmp	r1, r2
 3098 00ec 01D3     		bcc	.L230
  99:rt-thread/src/ipc.c ****             {
 3099              		.loc 1 99 0
 3100 00ee 1B68     		ldr	r3, [r3]
 3101              	.LVL427:
 3102 00f0 F5E7     		b	.L211
 3103              	.LVL428:
 3104              	.L230:
 107:rt-thread/src/ipc.c ****                     break;
 3105              		.loc 1 107 0
 3106 00f2 04F11402 		add	r2, r4, #20
 3107              	.LVL429:
 3108              	.LBB293:
 3109              	.LBB294:
  75:rt-thread/include/rtservice.h ****     n->prev = l->prev;
 3110              		.loc 2 75 0
 3111 00f6 5968     		ldr	r1, [r3, #4]
 3112 00f8 0A60     		str	r2, [r1]
  76:rt-thread/include/rtservice.h **** 
 3113              		.loc 2 76 0
 3114 00fa 5968     		ldr	r1, [r3, #4]
 3115 00fc A161     		str	r1, [r4, #24]
  78:rt-thread/include/rtservice.h ****     n->next = l;
 3116              		.loc 2 78 0
 3117 00fe 5A60     		str	r2, [r3, #4]
  79:rt-thread/include/rtservice.h **** }
 3118              		.loc 2 79 0
 3119 0100 6361     		str	r3, [r4, #20]
 3120              	.LVL430:
 3121              	.L213:
 3122              	.LBE294:
 3123              	.LBE293:
 116:rt-thread/src/ipc.c ****                 rt_list_insert_before(list, &(thread->tlist));
 3124              		.loc 1 116 0
 3125 0102 9D42     		cmp	r5, r3
 3126 0104 AFD1     		bne	.L208
 117:rt-thread/src/ipc.c ****         }
 3127              		.loc 1 117 0
 3128 0106 04F11403 		add	r3, r4, #20
 3129              	.LVL431:
 3130              	.LBB295:
 3131              	.LBB296:
  75:rt-thread/include/rtservice.h ****     n->prev = l->prev;
 3132              		.loc 2 75 0
 3133 010a 6A68     		ldr	r2, [r5, #4]
 3134 010c 1360     		str	r3, [r2]
  76:rt-thread/include/rtservice.h **** 
 3135              		.loc 2 76 0
 3136 010e 6A68     		ldr	r2, [r5, #4]
 3137 0110 A261     		str	r2, [r4, #24]
  78:rt-thread/include/rtservice.h ****     n->next = l;
 3138              		.loc 2 78 0
 3139 0112 6B60     		str	r3, [r5, #4]
  79:rt-thread/include/rtservice.h **** }
 3140              		.loc 2 79 0
ARM GAS  /tmp/ccOtHhPO.s 			page 99


 3141 0114 6561     		str	r5, [r4, #20]
 3142 0116 A6E7     		b	.L208
 3143              	.LVL432:
 3144              	.L227:
 3145              	.LBE296:
 3146              	.LBE295:
 3147              	.LBE292:
 3148              	.LBE297:
 3149              	.LBE298:
2075:rt-thread/src/ipc.c ****         }
 3150              		.loc 1 2075 0
 3151 0118 0023     		movs	r3, #0
 3152 011a 0193     		str	r3, [sp, #4]
 3153 011c C9E7     		b	.L206
 3154              	.LVL433:
 3155              	.L228:
2080:rt-thread/src/ipc.c **** 
 3156              		.loc 1 2080 0
 3157 011e 2B68     		ldr	r3, [r5]
 3158 0120 3363     		str	r3, [r6, #48]
2083:rt-thread/src/ipc.c **** 
 3159              		.loc 1 2083 0
 3160 0122 4046     		mov	r0, r8
 3161 0124 FFF7FEFF 		bl	rt_hw_interrupt_enable
 3162              	.LVL434:
2086:rt-thread/src/ipc.c ****     /* copy buffer */
 3163              		.loc 1 2086 0
 3164 0128 2846     		mov	r0, r5
 3165 012a 0023     		movs	r3, #0
 3166 012c 40F8043B 		str	r3, [r0], #4
2088:rt-thread/src/ipc.c **** 
 3167              		.loc 1 2088 0
 3168 0130 4A46     		mov	r2, r9
 3169 0132 5146     		mov	r1, r10
 3170 0134 FFF7FEFF 		bl	rt_memcpy
 3171              	.LVL435:
2091:rt-thread/src/ipc.c ****     /* link msg to message queue */
 3172              		.loc 1 2091 0
 3173 0138 FFF7FEFF 		bl	rt_hw_interrupt_disable
 3174              	.LVL436:
 3175 013c 0446     		mov	r4, r0
 3176              	.LVL437:
2093:rt-thread/src/ipc.c ****     {
 3177              		.loc 1 2093 0
 3178 013e F36A     		ldr	r3, [r6, #44]
 3179 0140 03B1     		cbz	r3, .L218
2096:rt-thread/src/ipc.c ****     }
 3180              		.loc 1 2096 0
 3181 0142 1D60     		str	r5, [r3]
 3182              	.L218:
2100:rt-thread/src/ipc.c ****     /* if the head is empty, set head */
 3183              		.loc 1 2100 0
 3184 0144 F562     		str	r5, [r6, #44]
2102:rt-thread/src/ipc.c ****         mq->msg_queue_head = msg;
 3185              		.loc 1 2102 0
 3186 0146 B36A     		ldr	r3, [r6, #40]
 3187 0148 8BB1     		cbz	r3, .L231
ARM GAS  /tmp/ccOtHhPO.s 			page 100


 3188              	.L219:
2106:rt-thread/src/ipc.c **** 
 3189              		.loc 1 2106 0
 3190 014a B38C     		ldrh	r3, [r6, #36]
 3191 014c 0133     		adds	r3, r3, #1
 3192 014e B384     		strh	r3, [r6, #36]	@ movhi
2109:rt-thread/src/ipc.c ****     {
 3193              		.loc 1 2109 0
 3194 0150 06F11403 		add	r3, r6, #20
 3195              	.LVL438:
 3196              	.LBB299:
 3197              	.LBB300:
 3198              		.loc 2 100 0
 3199 0154 7069     		ldr	r0, [r6, #20]
 3200              	.LVL439:
 3201              	.LBE300:
 3202              	.LBE299:
2109:rt-thread/src/ipc.c ****     {
 3203              		.loc 1 2109 0
 3204 0156 8342     		cmp	r3, r0
 3205 0158 0BD0     		beq	.L220
 3206              	.LVL440:
 3207              	.LBB301:
 3208              	.LBB302:
 144:rt-thread/src/ipc.c **** 
 3209              		.loc 1 144 0
 3210 015a 1438     		subs	r0, r0, #20
 3211              	.LVL441:
 3212 015c FFF7FEFF 		bl	rt_thread_resume
 3213              	.LVL442:
 3214              	.LBE302:
 3215              	.LBE301:
2114:rt-thread/src/ipc.c **** 
 3216              		.loc 1 2114 0
 3217 0160 2046     		mov	r0, r4
 3218 0162 FFF7FEFF 		bl	rt_hw_interrupt_enable
 3219              	.LVL443:
2116:rt-thread/src/ipc.c **** 
 3220              		.loc 1 2116 0
 3221 0166 FFF7FEFF 		bl	rt_schedule
 3222              	.LVL444:
2118:rt-thread/src/ipc.c ****     }
 3223              		.loc 1 2118 0
 3224 016a 0020     		movs	r0, #0
 3225 016c 70E7     		b	.L203
 3226              	.LVL445:
 3227              	.L231:
2103:rt-thread/src/ipc.c **** 
 3228              		.loc 1 2103 0
 3229 016e B562     		str	r5, [r6, #40]
 3230 0170 EBE7     		b	.L219
 3231              	.LVL446:
 3232              	.L220:
2122:rt-thread/src/ipc.c **** 
 3233              		.loc 1 2122 0
 3234 0172 2046     		mov	r0, r4
 3235 0174 FFF7FEFF 		bl	rt_hw_interrupt_enable
ARM GAS  /tmp/ccOtHhPO.s 			page 101


 3236              	.LVL447:
2124:rt-thread/src/ipc.c **** }
 3237              		.loc 1 2124 0
 3238 0178 0020     		movs	r0, #0
 3239 017a 69E7     		b	.L203
 3240              	.LVL448:
 3241              	.L221:
1993:rt-thread/src/ipc.c **** 
 3242              		.loc 1 1993 0
 3243 017c 4FF0FF30 		mov	r0, #-1
 3244              	.LVL449:
 3245 0180 66E7     		b	.L203
 3246              	.L233:
 3247 0182 00BF     		.align	2
 3248              	.L232:
 3249 0184 00000000 		.word	rt_object_put_hook
 3250              		.cfi_endproc
 3251              	.LFE45:
 3253              		.section	.text.rt_mq_send,"ax",%progbits
 3254              		.align	1
 3255              		.global	rt_mq_send
 3256              		.syntax unified
 3257              		.thumb
 3258              		.thumb_func
 3259              		.fpu fpv4-sp-d16
 3261              	rt_mq_send:
 3262              	.LFB46:
2126:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mq_send_wait)
2127:rt-thread/src/ipc.c **** 
2128:rt-thread/src/ipc.c **** /**
2129:rt-thread/src/ipc.c ****  * This function will send a message to message queue object, if there are
2130:rt-thread/src/ipc.c ****  * threads suspended on message queue object, it will be waked up.
2131:rt-thread/src/ipc.c ****  *
2132:rt-thread/src/ipc.c ****  * @param mq the message queue object
2133:rt-thread/src/ipc.c ****  * @param buffer the message
2134:rt-thread/src/ipc.c ****  * @param size the size of buffer
2135:rt-thread/src/ipc.c ****  *
2136:rt-thread/src/ipc.c ****  * @return the error code
2137:rt-thread/src/ipc.c ****  */
2138:rt-thread/src/ipc.c **** rt_err_t rt_mq_send(rt_mq_t mq, const void *buffer, rt_size_t size)
2139:rt-thread/src/ipc.c **** {
 3263              		.loc 1 2139 0
 3264              		.cfi_startproc
 3265              		@ args = 0, pretend = 0, frame = 0
 3266              		@ frame_needed = 0, uses_anonymous_args = 0
 3267              	.LVL450:
 3268 0000 08B5     		push	{r3, lr}
 3269              	.LCFI41:
 3270              		.cfi_def_cfa_offset 8
 3271              		.cfi_offset 3, -8
 3272              		.cfi_offset 14, -4
2140:rt-thread/src/ipc.c ****     return rt_mq_send_wait(mq, buffer, size, 0);
 3273              		.loc 1 2140 0
 3274 0002 0023     		movs	r3, #0
 3275 0004 FFF7FEFF 		bl	rt_mq_send_wait
 3276              	.LVL451:
2141:rt-thread/src/ipc.c **** }
ARM GAS  /tmp/ccOtHhPO.s 			page 102


 3277              		.loc 1 2141 0
 3278 0008 08BD     		pop	{r3, pc}
 3279              		.cfi_endproc
 3280              	.LFE46:
 3282              		.section	.text.rt_mq_urgent,"ax",%progbits
 3283              		.align	1
 3284              		.global	rt_mq_urgent
 3285              		.syntax unified
 3286              		.thumb
 3287              		.thumb_func
 3288              		.fpu fpv4-sp-d16
 3290              	rt_mq_urgent:
 3291              	.LFB47:
2142:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mq_send);
2143:rt-thread/src/ipc.c **** 
2144:rt-thread/src/ipc.c **** /**
2145:rt-thread/src/ipc.c ****  * This function will send an urgent message to message queue object, which
2146:rt-thread/src/ipc.c ****  * means the message will be inserted to the head of message queue. If there
2147:rt-thread/src/ipc.c ****  * are threads suspended on message queue object, it will be waked up.
2148:rt-thread/src/ipc.c ****  *
2149:rt-thread/src/ipc.c ****  * @param mq the message queue object
2150:rt-thread/src/ipc.c ****  * @param buffer the message
2151:rt-thread/src/ipc.c ****  * @param size the size of buffer
2152:rt-thread/src/ipc.c ****  *
2153:rt-thread/src/ipc.c ****  * @return the error code
2154:rt-thread/src/ipc.c ****  */
2155:rt-thread/src/ipc.c **** rt_err_t rt_mq_urgent(rt_mq_t mq, const void *buffer, rt_size_t size)
2156:rt-thread/src/ipc.c **** {
 3292              		.loc 1 2156 0
 3293              		.cfi_startproc
 3294              		@ args = 0, pretend = 0, frame = 0
 3295              		@ frame_needed = 0, uses_anonymous_args = 0
 3296              	.LVL452:
2157:rt-thread/src/ipc.c ****     register rt_ubase_t temp;
2158:rt-thread/src/ipc.c ****     struct rt_mq_message *msg;
2159:rt-thread/src/ipc.c **** 
2160:rt-thread/src/ipc.c ****     /* parameter check */
2161:rt-thread/src/ipc.c ****     RT_ASSERT(mq != RT_NULL);
2162:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mq->parent.parent) == RT_Object_Class_MessageQueue);
2163:rt-thread/src/ipc.c ****     RT_ASSERT(buffer != RT_NULL);
2164:rt-thread/src/ipc.c ****     RT_ASSERT(size != 0);
2165:rt-thread/src/ipc.c **** 
2166:rt-thread/src/ipc.c ****     /* greater than one message size */
2167:rt-thread/src/ipc.c ****     if (size > mq->msg_size)
 3297              		.loc 1 2167 0
 3298 0000 038C     		ldrh	r3, [r0, #32]
 3299 0002 9342     		cmp	r3, r2
 3300 0004 40D3     		bcc	.L242
2156:rt-thread/src/ipc.c ****     register rt_ubase_t temp;
 3301              		.loc 1 2156 0
 3302 0006 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 3303              	.LCFI42:
 3304              		.cfi_def_cfa_offset 24
 3305              		.cfi_offset 4, -24
 3306              		.cfi_offset 5, -20
 3307              		.cfi_offset 6, -16
 3308              		.cfi_offset 7, -12
ARM GAS  /tmp/ccOtHhPO.s 			page 103


 3309              		.cfi_offset 8, -8
 3310              		.cfi_offset 14, -4
 3311 000a 1746     		mov	r7, r2
 3312 000c 8846     		mov	r8, r1
 3313 000e 0446     		mov	r4, r0
2168:rt-thread/src/ipc.c ****         return -RT_ERROR;
2169:rt-thread/src/ipc.c **** 
2170:rt-thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
 3314              		.loc 1 2170 0
 3315 0010 1F4B     		ldr	r3, .L249
 3316 0012 1B68     		ldr	r3, [r3]
 3317 0014 03B1     		cbz	r3, .L238
 3318              		.loc 1 2170 0 is_stmt 0 discriminator 1
 3319 0016 9847     		blx	r3
 3320              	.LVL453:
 3321              	.L238:
2171:rt-thread/src/ipc.c **** 
2172:rt-thread/src/ipc.c ****     /* disable interrupt */
2173:rt-thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
 3322              		.loc 1 2173 0 is_stmt 1
 3323 0018 FFF7FEFF 		bl	rt_hw_interrupt_disable
 3324              	.LVL454:
2174:rt-thread/src/ipc.c **** 
2175:rt-thread/src/ipc.c ****     /* get a free list, there must be an empty item */
2176:rt-thread/src/ipc.c ****     msg = (struct rt_mq_message *)mq->msg_queue_free;
 3325              		.loc 1 2176 0
 3326 001c 256B     		ldr	r5, [r4, #48]
 3327              	.LVL455:
2177:rt-thread/src/ipc.c ****     /* message queue is full */
2178:rt-thread/src/ipc.c ****     if (msg == RT_NULL)
 3328              		.loc 1 2178 0
 3329 001e 2DB3     		cbz	r5, .L247
2179:rt-thread/src/ipc.c ****     {
2180:rt-thread/src/ipc.c ****         /* enable interrupt */
2181:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
2182:rt-thread/src/ipc.c **** 
2183:rt-thread/src/ipc.c ****         return -RT_EFULL;
2184:rt-thread/src/ipc.c ****     }
2185:rt-thread/src/ipc.c ****     /* move free list pointer */
2186:rt-thread/src/ipc.c ****     mq->msg_queue_free = msg->next;
 3330              		.loc 1 2186 0
 3331 0020 2E46     		mov	r6, r5
 3332 0022 56F8043B 		ldr	r3, [r6], #4
 3333 0026 2363     		str	r3, [r4, #48]
2187:rt-thread/src/ipc.c **** 
2188:rt-thread/src/ipc.c ****     /* enable interrupt */
2189:rt-thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
 3334              		.loc 1 2189 0
 3335 0028 FFF7FEFF 		bl	rt_hw_interrupt_enable
 3336              	.LVL456:
2190:rt-thread/src/ipc.c **** 
2191:rt-thread/src/ipc.c ****     /* copy buffer */
2192:rt-thread/src/ipc.c ****     rt_memcpy(msg + 1, buffer, size);
 3337              		.loc 1 2192 0
 3338 002c 3A46     		mov	r2, r7
 3339 002e 4146     		mov	r1, r8
 3340 0030 3046     		mov	r0, r6
ARM GAS  /tmp/ccOtHhPO.s 			page 104


 3341 0032 FFF7FEFF 		bl	rt_memcpy
 3342              	.LVL457:
2193:rt-thread/src/ipc.c **** 
2194:rt-thread/src/ipc.c ****     /* disable interrupt */
2195:rt-thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
 3343              		.loc 1 2195 0
 3344 0036 FFF7FEFF 		bl	rt_hw_interrupt_disable
 3345              	.LVL458:
 3346 003a 0646     		mov	r6, r0
 3347              	.LVL459:
2196:rt-thread/src/ipc.c **** 
2197:rt-thread/src/ipc.c ****     /* link msg to the beginning of message queue */
2198:rt-thread/src/ipc.c ****     msg->next = (struct rt_mq_message *)mq->msg_queue_head;
 3348              		.loc 1 2198 0
 3349 003c A36A     		ldr	r3, [r4, #40]
 3350 003e 2B60     		str	r3, [r5]
2199:rt-thread/src/ipc.c ****     mq->msg_queue_head = msg;
 3351              		.loc 1 2199 0
 3352 0040 A562     		str	r5, [r4, #40]
2200:rt-thread/src/ipc.c **** 
2201:rt-thread/src/ipc.c ****     /* if there is no tail */
2202:rt-thread/src/ipc.c ****     if (mq->msg_queue_tail == RT_NULL)
 3353              		.loc 1 2202 0
 3354 0042 E36A     		ldr	r3, [r4, #44]
 3355 0044 C3B1     		cbz	r3, .L248
 3356              	.L240:
2203:rt-thread/src/ipc.c ****         mq->msg_queue_tail = msg;
2204:rt-thread/src/ipc.c **** 
2205:rt-thread/src/ipc.c ****     /* increase message entry */
2206:rt-thread/src/ipc.c ****     mq->entry ++;
 3357              		.loc 1 2206 0
 3358 0046 A38C     		ldrh	r3, [r4, #36]
 3359 0048 0133     		adds	r3, r3, #1
 3360 004a A384     		strh	r3, [r4, #36]	@ movhi
2207:rt-thread/src/ipc.c **** 
2208:rt-thread/src/ipc.c ****     /* resume suspended thread */
2209:rt-thread/src/ipc.c ****     if (!rt_list_isempty(&mq->parent.suspend_thread))
 3361              		.loc 1 2209 0
 3362 004c 04F11403 		add	r3, r4, #20
 3363              	.LVL460:
 3364              	.LBB303:
 3365              	.LBB304:
 3366              		.loc 2 100 0
 3367 0050 6069     		ldr	r0, [r4, #20]
 3368              	.LVL461:
 3369              	.LBE304:
 3370              	.LBE303:
 3371              		.loc 1 2209 0
 3372 0052 8342     		cmp	r3, r0
 3373 0054 12D0     		beq	.L241
 3374              	.LVL462:
 3375              	.LBB305:
 3376              	.LBB306:
 144:rt-thread/src/ipc.c **** 
 3377              		.loc 1 144 0
 3378 0056 1438     		subs	r0, r0, #20
 3379              	.LVL463:
ARM GAS  /tmp/ccOtHhPO.s 			page 105


 3380 0058 FFF7FEFF 		bl	rt_thread_resume
 3381              	.LVL464:
 3382              	.LBE306:
 3383              	.LBE305:
2210:rt-thread/src/ipc.c ****     {
2211:rt-thread/src/ipc.c ****         rt_ipc_list_resume(&(mq->parent.suspend_thread));
2212:rt-thread/src/ipc.c **** 
2213:rt-thread/src/ipc.c ****         /* enable interrupt */
2214:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
 3384              		.loc 1 2214 0
 3385 005c 3046     		mov	r0, r6
 3386 005e FFF7FEFF 		bl	rt_hw_interrupt_enable
 3387              	.LVL465:
2215:rt-thread/src/ipc.c **** 
2216:rt-thread/src/ipc.c ****         rt_schedule();
 3388              		.loc 1 2216 0
 3389 0062 FFF7FEFF 		bl	rt_schedule
 3390              	.LVL466:
2217:rt-thread/src/ipc.c **** 
2218:rt-thread/src/ipc.c ****         return RT_EOK;
 3391              		.loc 1 2218 0
 3392 0066 0020     		movs	r0, #0
 3393 0068 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 3394              	.LVL467:
 3395              	.L247:
2181:rt-thread/src/ipc.c **** 
 3396              		.loc 1 2181 0
 3397 006c FFF7FEFF 		bl	rt_hw_interrupt_enable
 3398              	.LVL468:
2183:rt-thread/src/ipc.c ****     }
 3399              		.loc 1 2183 0
 3400 0070 6FF00200 		mvn	r0, #2
 3401 0074 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 3402              	.LVL469:
 3403              	.L248:
2203:rt-thread/src/ipc.c **** 
 3404              		.loc 1 2203 0
 3405 0078 E562     		str	r5, [r4, #44]
 3406 007a E4E7     		b	.L240
 3407              	.LVL470:
 3408              	.L241:
2219:rt-thread/src/ipc.c ****     }
2220:rt-thread/src/ipc.c **** 
2221:rt-thread/src/ipc.c ****     /* enable interrupt */
2222:rt-thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
 3409              		.loc 1 2222 0
 3410 007c 3046     		mov	r0, r6
 3411 007e FFF7FEFF 		bl	rt_hw_interrupt_enable
 3412              	.LVL471:
2223:rt-thread/src/ipc.c **** 
2224:rt-thread/src/ipc.c ****     return RT_EOK;
 3413              		.loc 1 2224 0
 3414 0082 0020     		movs	r0, #0
 3415 0084 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 3416              	.LVL472:
 3417              	.L242:
 3418              	.LCFI43:
ARM GAS  /tmp/ccOtHhPO.s 			page 106


 3419              		.cfi_def_cfa_offset 0
 3420              		.cfi_restore 4
 3421              		.cfi_restore 5
 3422              		.cfi_restore 6
 3423              		.cfi_restore 7
 3424              		.cfi_restore 8
 3425              		.cfi_restore 14
2168:rt-thread/src/ipc.c **** 
 3426              		.loc 1 2168 0
 3427 0088 4FF0FF30 		mov	r0, #-1
 3428              	.LVL473:
 3429 008c 7047     		bx	lr
 3430              	.L250:
 3431 008e 00BF     		.align	2
 3432              	.L249:
 3433 0090 00000000 		.word	rt_object_put_hook
 3434              		.cfi_endproc
 3435              	.LFE47:
 3437              		.section	.text.rt_mq_recv,"ax",%progbits
 3438              		.align	1
 3439              		.global	rt_mq_recv
 3440              		.syntax unified
 3441              		.thumb
 3442              		.thumb_func
 3443              		.fpu fpv4-sp-d16
 3445              	rt_mq_recv:
 3446              	.LFB48:
2225:rt-thread/src/ipc.c **** }
2226:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mq_urgent);
2227:rt-thread/src/ipc.c **** 
2228:rt-thread/src/ipc.c **** /**
2229:rt-thread/src/ipc.c ****  * This function will receive a message from message queue object, if there is
2230:rt-thread/src/ipc.c ****  * no message in message queue object, the thread shall wait for a specified
2231:rt-thread/src/ipc.c ****  * time.
2232:rt-thread/src/ipc.c ****  *
2233:rt-thread/src/ipc.c ****  * @param mq the message queue object
2234:rt-thread/src/ipc.c ****  * @param buffer the received message will be saved in
2235:rt-thread/src/ipc.c ****  * @param size the size of buffer
2236:rt-thread/src/ipc.c ****  * @param timeout the waiting time
2237:rt-thread/src/ipc.c ****  *
2238:rt-thread/src/ipc.c ****  * @return the error code
2239:rt-thread/src/ipc.c ****  */
2240:rt-thread/src/ipc.c **** rt_err_t rt_mq_recv(rt_mq_t    mq,
2241:rt-thread/src/ipc.c ****                     void      *buffer,
2242:rt-thread/src/ipc.c ****                     rt_size_t  size,
2243:rt-thread/src/ipc.c ****                     rt_int32_t timeout)
2244:rt-thread/src/ipc.c **** {
 3447              		.loc 1 2244 0
 3448              		.cfi_startproc
 3449              		@ args = 0, pretend = 0, frame = 8
 3450              		@ frame_needed = 0, uses_anonymous_args = 0
 3451              	.LVL474:
 3452 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 3453              	.LCFI44:
 3454              		.cfi_def_cfa_offset 36
 3455              		.cfi_offset 4, -36
 3456              		.cfi_offset 5, -32
ARM GAS  /tmp/ccOtHhPO.s 			page 107


 3457              		.cfi_offset 6, -28
 3458              		.cfi_offset 7, -24
 3459              		.cfi_offset 8, -20
 3460              		.cfi_offset 9, -16
 3461              		.cfi_offset 10, -12
 3462              		.cfi_offset 11, -8
 3463              		.cfi_offset 14, -4
 3464 0004 83B0     		sub	sp, sp, #12
 3465              	.LCFI45:
 3466              		.cfi_def_cfa_offset 48
 3467 0006 0646     		mov	r6, r0
 3468 0008 8946     		mov	r9, r1
 3469 000a 9246     		mov	r10, r2
 3470 000c 0193     		str	r3, [sp, #4]
 3471              	.LVL475:
2245:rt-thread/src/ipc.c ****     struct rt_thread *thread;
2246:rt-thread/src/ipc.c ****     register rt_ubase_t temp;
2247:rt-thread/src/ipc.c ****     struct rt_mq_message *msg;
2248:rt-thread/src/ipc.c ****     rt_uint32_t tick_delta;
2249:rt-thread/src/ipc.c **** 
2250:rt-thread/src/ipc.c ****     /* parameter check */
2251:rt-thread/src/ipc.c ****     RT_ASSERT(mq != RT_NULL);
2252:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mq->parent.parent) == RT_Object_Class_MessageQueue);
2253:rt-thread/src/ipc.c ****     RT_ASSERT(buffer != RT_NULL);
2254:rt-thread/src/ipc.c ****     RT_ASSERT(size != 0);
2255:rt-thread/src/ipc.c **** 
2256:rt-thread/src/ipc.c ****     /* initialize delta tick */
2257:rt-thread/src/ipc.c ****     tick_delta = 0;
2258:rt-thread/src/ipc.c ****     /* get current thread */
2259:rt-thread/src/ipc.c ****     thread = rt_thread_self();
 3472              		.loc 1 2259 0
 3473 000e FFF7FEFF 		bl	rt_thread_self
 3474              	.LVL476:
 3475 0012 0446     		mov	r4, r0
 3476              	.LVL477:
2260:rt-thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mq->parent.parent)));
 3477              		.loc 1 2260 0
 3478 0014 5F4B     		ldr	r3, .L279
 3479 0016 1B68     		ldr	r3, [r3]
 3480 0018 0BB1     		cbz	r3, .L252
 3481              		.loc 1 2260 0 is_stmt 0 discriminator 1
 3482 001a 3046     		mov	r0, r6
 3483              	.LVL478:
 3484 001c 9847     		blx	r3
 3485              	.LVL479:
 3486              	.L252:
2261:rt-thread/src/ipc.c **** 
2262:rt-thread/src/ipc.c ****     /* disable interrupt */
2263:rt-thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
 3487              		.loc 1 2263 0 is_stmt 1
 3488 001e FFF7FEFF 		bl	rt_hw_interrupt_disable
 3489              	.LVL480:
 3490 0022 8046     		mov	r8, r0
 3491              	.LVL481:
2264:rt-thread/src/ipc.c **** 
2265:rt-thread/src/ipc.c ****     /* for non-blocking call */
2266:rt-thread/src/ipc.c ****     if (mq->entry == 0 && timeout == 0)
ARM GAS  /tmp/ccOtHhPO.s 			page 108


 3492              		.loc 1 2266 0
 3493 0024 B38C     		ldrh	r3, [r6, #36]
 3494 0026 002B     		cmp	r3, #0
 3495 0028 75D1     		bne	.L269
 3496              		.loc 1 2266 0 is_stmt 0 discriminator 1
 3497 002a 019B     		ldr	r3, [sp, #4]
 3498 002c 0BB1     		cbz	r3, .L273
 3499 002e 0027     		movs	r7, #0
 3500 0030 3BE0     		b	.L253
 3501              	.L273:
2267:rt-thread/src/ipc.c ****     {
2268:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
 3502              		.loc 1 2268 0 is_stmt 1
 3503 0032 FFF7FEFF 		bl	rt_hw_interrupt_enable
 3504              	.LVL482:
2269:rt-thread/src/ipc.c **** 
2270:rt-thread/src/ipc.c ****         return -RT_ETIMEOUT;
 3505              		.loc 1 2270 0
 3506 0036 6FF00100 		mvn	r0, #1
 3507 003a 05E0     		b	.L251
 3508              	.LVL483:
 3509              	.L276:
2271:rt-thread/src/ipc.c ****     }
2272:rt-thread/src/ipc.c **** 
2273:rt-thread/src/ipc.c ****     /* message queue is empty */
2274:rt-thread/src/ipc.c ****     while (mq->entry == 0)
2275:rt-thread/src/ipc.c ****     {
2276:rt-thread/src/ipc.c ****         RT_DEBUG_IN_THREAD_CONTEXT;
2277:rt-thread/src/ipc.c **** 
2278:rt-thread/src/ipc.c ****         /* reset error number in thread */
2279:rt-thread/src/ipc.c ****         thread->error = RT_EOK;
2280:rt-thread/src/ipc.c **** 
2281:rt-thread/src/ipc.c ****         /* no waiting, return timeout */
2282:rt-thread/src/ipc.c ****         if (timeout == 0)
2283:rt-thread/src/ipc.c ****         {
2284:rt-thread/src/ipc.c ****             /* enable interrupt */
2285:rt-thread/src/ipc.c ****             rt_hw_interrupt_enable(temp);
 3510              		.loc 1 2285 0
 3511 003c 4046     		mov	r0, r8
 3512 003e FFF7FEFF 		bl	rt_hw_interrupt_enable
 3513              	.LVL484:
2286:rt-thread/src/ipc.c **** 
2287:rt-thread/src/ipc.c ****             thread->error = -RT_ETIMEOUT;
 3514              		.loc 1 2287 0
 3515 0042 6FF00100 		mvn	r0, #1
 3516 0046 2063     		str	r0, [r4, #48]
 3517              	.LVL485:
 3518              	.L251:
2288:rt-thread/src/ipc.c **** 
2289:rt-thread/src/ipc.c ****             return -RT_ETIMEOUT;
2290:rt-thread/src/ipc.c ****         }
2291:rt-thread/src/ipc.c **** 
2292:rt-thread/src/ipc.c ****         /* suspend current thread */
2293:rt-thread/src/ipc.c ****         rt_ipc_list_suspend(&(mq->parent.suspend_thread),
2294:rt-thread/src/ipc.c ****                             thread,
2295:rt-thread/src/ipc.c ****                             mq->parent.parent.flag);
2296:rt-thread/src/ipc.c **** 
ARM GAS  /tmp/ccOtHhPO.s 			page 109


2297:rt-thread/src/ipc.c ****         /* has waiting time, start thread timer */
2298:rt-thread/src/ipc.c ****         if (timeout > 0)
2299:rt-thread/src/ipc.c ****         {
2300:rt-thread/src/ipc.c ****             /* get the start tick of timer */
2301:rt-thread/src/ipc.c ****             tick_delta = rt_tick_get();
2302:rt-thread/src/ipc.c **** 
2303:rt-thread/src/ipc.c ****             RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
2304:rt-thread/src/ipc.c ****                                         thread->name));
2305:rt-thread/src/ipc.c **** 
2306:rt-thread/src/ipc.c ****             /* reset the timeout of thread timer and start it */
2307:rt-thread/src/ipc.c ****             rt_timer_control(&(thread->thread_timer),
2308:rt-thread/src/ipc.c ****                              RT_TIMER_CTRL_SET_TIME,
2309:rt-thread/src/ipc.c ****                              &timeout);
2310:rt-thread/src/ipc.c ****             rt_timer_start(&(thread->thread_timer));
2311:rt-thread/src/ipc.c ****         }
2312:rt-thread/src/ipc.c **** 
2313:rt-thread/src/ipc.c ****         /* enable interrupt */
2314:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
2315:rt-thread/src/ipc.c **** 
2316:rt-thread/src/ipc.c ****         /* re-schedule */
2317:rt-thread/src/ipc.c ****         rt_schedule();
2318:rt-thread/src/ipc.c **** 
2319:rt-thread/src/ipc.c ****         /* recv message */
2320:rt-thread/src/ipc.c ****         if (thread->error != RT_EOK)
2321:rt-thread/src/ipc.c ****         {
2322:rt-thread/src/ipc.c ****             /* return error */
2323:rt-thread/src/ipc.c ****             return thread->error;
2324:rt-thread/src/ipc.c ****         }
2325:rt-thread/src/ipc.c **** 
2326:rt-thread/src/ipc.c ****         /* disable interrupt */
2327:rt-thread/src/ipc.c ****         temp = rt_hw_interrupt_disable();
2328:rt-thread/src/ipc.c **** 
2329:rt-thread/src/ipc.c ****         /* if it's not waiting forever and then re-calculate timeout tick */
2330:rt-thread/src/ipc.c ****         if (timeout > 0)
2331:rt-thread/src/ipc.c ****         {
2332:rt-thread/src/ipc.c ****             tick_delta = rt_tick_get() - tick_delta;
2333:rt-thread/src/ipc.c ****             timeout -= tick_delta;
2334:rt-thread/src/ipc.c ****             if (timeout < 0)
2335:rt-thread/src/ipc.c ****                 timeout = 0;
2336:rt-thread/src/ipc.c ****         }
2337:rt-thread/src/ipc.c ****     }
2338:rt-thread/src/ipc.c **** 
2339:rt-thread/src/ipc.c ****     /* get message from queue */
2340:rt-thread/src/ipc.c ****     msg = (struct rt_mq_message *)mq->msg_queue_head;
2341:rt-thread/src/ipc.c **** 
2342:rt-thread/src/ipc.c ****     /* move message queue head */
2343:rt-thread/src/ipc.c ****     mq->msg_queue_head = msg->next;
2344:rt-thread/src/ipc.c ****     /* reach queue tail, set to NULL */
2345:rt-thread/src/ipc.c ****     if (mq->msg_queue_tail == msg)
2346:rt-thread/src/ipc.c ****         mq->msg_queue_tail = RT_NULL;
2347:rt-thread/src/ipc.c **** 
2348:rt-thread/src/ipc.c ****     /* decrease message entry */
2349:rt-thread/src/ipc.c ****     mq->entry --;
2350:rt-thread/src/ipc.c **** 
2351:rt-thread/src/ipc.c ****     /* enable interrupt */
2352:rt-thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
2353:rt-thread/src/ipc.c **** 
ARM GAS  /tmp/ccOtHhPO.s 			page 110


2354:rt-thread/src/ipc.c ****     /* copy message */
2355:rt-thread/src/ipc.c ****     rt_memcpy(buffer, msg + 1, size > mq->msg_size ? mq->msg_size : size);
2356:rt-thread/src/ipc.c **** 
2357:rt-thread/src/ipc.c ****     /* disable interrupt */
2358:rt-thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
2359:rt-thread/src/ipc.c ****     /* put message to free list */
2360:rt-thread/src/ipc.c ****     msg->next = (struct rt_mq_message *)mq->msg_queue_free;
2361:rt-thread/src/ipc.c ****     mq->msg_queue_free = msg;
2362:rt-thread/src/ipc.c **** 
2363:rt-thread/src/ipc.c ****     /* resume suspended thread */
2364:rt-thread/src/ipc.c ****     if (!rt_list_isempty(&(mq->suspend_sender_thread)))
2365:rt-thread/src/ipc.c ****     {
2366:rt-thread/src/ipc.c ****         rt_ipc_list_resume(&(mq->suspend_sender_thread));
2367:rt-thread/src/ipc.c **** 
2368:rt-thread/src/ipc.c ****         /* enable interrupt */
2369:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
2370:rt-thread/src/ipc.c **** 
2371:rt-thread/src/ipc.c ****         RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mq->parent.parent)));
2372:rt-thread/src/ipc.c **** 
2373:rt-thread/src/ipc.c ****         rt_schedule();
2374:rt-thread/src/ipc.c **** 
2375:rt-thread/src/ipc.c ****         return RT_EOK;
2376:rt-thread/src/ipc.c ****     }
2377:rt-thread/src/ipc.c **** 
2378:rt-thread/src/ipc.c ****     /* enable interrupt */
2379:rt-thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
2380:rt-thread/src/ipc.c **** 
2381:rt-thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mq->parent.parent)));
2382:rt-thread/src/ipc.c **** 
2383:rt-thread/src/ipc.c ****     return RT_EOK;
2384:rt-thread/src/ipc.c **** }
 3519              		.loc 1 2384 0
 3520 0048 03B0     		add	sp, sp, #12
 3521              	.LCFI46:
 3522              		.cfi_remember_state
 3523              		.cfi_def_cfa_offset 36
 3524              		@ sp needed
 3525 004a BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 3526              	.LVL486:
 3527              	.L257:
 3528              	.LCFI47:
 3529              		.cfi_restore_state
 3530              	.LBB320:
 3531              	.LBB321:
  90:rt-thread/src/ipc.c ****         break;
 3532              		.loc 1 90 0
 3533 004e 04F11403 		add	r3, r4, #20
 3534              	.LVL487:
 3535              	.LBB322:
 3536              	.LBB323:
  75:rt-thread/include/rtservice.h ****     n->prev = l->prev;
 3537              		.loc 2 75 0
 3538 0052 6A68     		ldr	r2, [r5, #4]
 3539 0054 1360     		str	r3, [r2]
  76:rt-thread/include/rtservice.h **** 
 3540              		.loc 2 76 0
 3541 0056 6A68     		ldr	r2, [r5, #4]
ARM GAS  /tmp/ccOtHhPO.s 			page 111


 3542 0058 A261     		str	r2, [r4, #24]
  78:rt-thread/include/rtservice.h ****     n->next = l;
 3543              		.loc 2 78 0
 3544 005a 6B60     		str	r3, [r5, #4]
  79:rt-thread/include/rtservice.h **** }
 3545              		.loc 2 79 0
 3546 005c 6561     		str	r5, [r4, #20]
 3547              	.LVL488:
 3548              	.L256:
 3549              	.LBE323:
 3550              	.LBE322:
 3551              	.LBE321:
 3552              	.LBE320:
2298:rt-thread/src/ipc.c ****         {
 3553              		.loc 1 2298 0
 3554 005e 019B     		ldr	r3, [sp, #4]
 3555 0060 002B     		cmp	r3, #0
 3556 0062 0CDD     		ble	.L263
2301:rt-thread/src/ipc.c **** 
 3557              		.loc 1 2301 0
 3558 0064 FFF7FEFF 		bl	rt_tick_get
 3559              	.LVL489:
 3560 0068 0746     		mov	r7, r0
 3561              	.LVL490:
2307:rt-thread/src/ipc.c ****                              RT_TIMER_CTRL_SET_TIME,
 3562              		.loc 1 2307 0
 3563 006a 04F14C05 		add	r5, r4, #76
 3564 006e 01AA     		add	r2, sp, #4
 3565 0070 0021     		movs	r1, #0
 3566 0072 2846     		mov	r0, r5
 3567              	.LVL491:
 3568 0074 FFF7FEFF 		bl	rt_timer_control
 3569              	.LVL492:
2310:rt-thread/src/ipc.c ****         }
 3570              		.loc 1 2310 0
 3571 0078 2846     		mov	r0, r5
 3572 007a FFF7FEFF 		bl	rt_timer_start
 3573              	.LVL493:
 3574              	.L263:
2314:rt-thread/src/ipc.c **** 
 3575              		.loc 1 2314 0
 3576 007e 4046     		mov	r0, r8
 3577 0080 FFF7FEFF 		bl	rt_hw_interrupt_enable
 3578              	.LVL494:
2317:rt-thread/src/ipc.c **** 
 3579              		.loc 1 2317 0
 3580 0084 FFF7FEFF 		bl	rt_schedule
 3581              	.LVL495:
2320:rt-thread/src/ipc.c ****         {
 3582              		.loc 1 2320 0
 3583 0088 206B     		ldr	r0, [r4, #48]
 3584 008a 0028     		cmp	r0, #0
 3585 008c DCD1     		bne	.L251
2327:rt-thread/src/ipc.c **** 
 3586              		.loc 1 2327 0
 3587 008e FFF7FEFF 		bl	rt_hw_interrupt_disable
 3588              	.LVL496:
ARM GAS  /tmp/ccOtHhPO.s 			page 112


 3589 0092 8046     		mov	r8, r0
 3590              	.LVL497:
2330:rt-thread/src/ipc.c ****         {
 3591              		.loc 1 2330 0
 3592 0094 019B     		ldr	r3, [sp, #4]
 3593 0096 002B     		cmp	r3, #0
 3594 0098 07DD     		ble	.L253
2332:rt-thread/src/ipc.c ****             timeout -= tick_delta;
 3595              		.loc 1 2332 0
 3596 009a FFF7FEFF 		bl	rt_tick_get
 3597              	.LVL498:
 3598 009e C71B     		subs	r7, r0, r7
 3599              	.LVL499:
2333:rt-thread/src/ipc.c ****             if (timeout < 0)
 3600              		.loc 1 2333 0
 3601 00a0 019B     		ldr	r3, [sp, #4]
 3602 00a2 DB1B     		subs	r3, r3, r7
 3603 00a4 0193     		str	r3, [sp, #4]
2334:rt-thread/src/ipc.c ****                 timeout = 0;
 3604              		.loc 1 2334 0
 3605 00a6 002B     		cmp	r3, #0
 3606 00a8 32DB     		blt	.L274
 3607              	.LVL500:
 3608              	.L253:
2274:rt-thread/src/ipc.c ****     {
 3609              		.loc 1 2274 0
 3610 00aa B38C     		ldrh	r3, [r6, #36]
 3611 00ac 002B     		cmp	r3, #0
 3612 00ae 34D1     		bne	.L275
2279:rt-thread/src/ipc.c **** 
 3613              		.loc 1 2279 0
 3614 00b0 0023     		movs	r3, #0
 3615 00b2 2363     		str	r3, [r4, #48]
2282:rt-thread/src/ipc.c ****         {
 3616              		.loc 1 2282 0
 3617 00b4 019B     		ldr	r3, [sp, #4]
 3618 00b6 002B     		cmp	r3, #0
 3619 00b8 C0D0     		beq	.L276
2293:rt-thread/src/ipc.c ****                             thread,
 3620              		.loc 1 2293 0
 3621 00ba 06F11405 		add	r5, r6, #20
 3622 00be 96F809B0 		ldrb	fp, [r6, #9]	@ zero_extendqisi2
 3623              	.LVL501:
 3624              	.LBB330:
 3625              	.LBB329:
  85:rt-thread/src/ipc.c **** 
 3626              		.loc 1 85 0
 3627 00c2 2046     		mov	r0, r4
 3628 00c4 FFF7FEFF 		bl	rt_thread_suspend
 3629              	.LVL502:
  87:rt-thread/src/ipc.c ****     {
 3630              		.loc 1 87 0
 3631 00c8 BBF1000F 		cmp	fp, #0
 3632 00cc BFD0     		beq	.L257
 3633 00ce BBF1010F 		cmp	fp, #1
 3634 00d2 C4D1     		bne	.L256
 3635              	.LBB324:
ARM GAS  /tmp/ccOtHhPO.s 			page 113


  99:rt-thread/src/ipc.c ****             {
 3636              		.loc 1 99 0
 3637 00d4 7369     		ldr	r3, [r6, #20]
 3638              	.LVL503:
 3639              	.L259:
 3640 00d6 9D42     		cmp	r5, r3
 3641 00d8 0FD0     		beq	.L261
 3642              	.LVL504:
 104:rt-thread/src/ipc.c ****                 {
 3643              		.loc 1 104 0
 3644 00da 94F83510 		ldrb	r1, [r4, #53]	@ zero_extendqisi2
 3645 00de 93F82120 		ldrb	r2, [r3, #33]	@ zero_extendqisi2
 3646 00e2 9142     		cmp	r1, r2
 3647 00e4 01D3     		bcc	.L277
  99:rt-thread/src/ipc.c ****             {
 3648              		.loc 1 99 0
 3649 00e6 1B68     		ldr	r3, [r3]
 3650              	.LVL505:
 3651 00e8 F5E7     		b	.L259
 3652              	.LVL506:
 3653              	.L277:
 107:rt-thread/src/ipc.c ****                     break;
 3654              		.loc 1 107 0
 3655 00ea 04F11402 		add	r2, r4, #20
 3656              	.LVL507:
 3657              	.LBB325:
 3658              	.LBB326:
  75:rt-thread/include/rtservice.h ****     n->prev = l->prev;
 3659              		.loc 2 75 0
 3660 00ee 5968     		ldr	r1, [r3, #4]
 3661 00f0 0A60     		str	r2, [r1]
  76:rt-thread/include/rtservice.h **** 
 3662              		.loc 2 76 0
 3663 00f2 5968     		ldr	r1, [r3, #4]
 3664 00f4 A161     		str	r1, [r4, #24]
  78:rt-thread/include/rtservice.h ****     n->next = l;
 3665              		.loc 2 78 0
 3666 00f6 5A60     		str	r2, [r3, #4]
  79:rt-thread/include/rtservice.h **** }
 3667              		.loc 2 79 0
 3668 00f8 6361     		str	r3, [r4, #20]
 3669              	.LVL508:
 3670              	.L261:
 3671              	.LBE326:
 3672              	.LBE325:
 116:rt-thread/src/ipc.c ****                 rt_list_insert_before(list, &(thread->tlist));
 3673              		.loc 1 116 0
 3674 00fa 9D42     		cmp	r5, r3
 3675 00fc AFD1     		bne	.L256
 117:rt-thread/src/ipc.c ****         }
 3676              		.loc 1 117 0
 3677 00fe 04F11403 		add	r3, r4, #20
 3678              	.LVL509:
 3679              	.LBB327:
 3680              	.LBB328:
  75:rt-thread/include/rtservice.h ****     n->prev = l->prev;
 3681              		.loc 2 75 0
ARM GAS  /tmp/ccOtHhPO.s 			page 114


 3682 0102 6A68     		ldr	r2, [r5, #4]
 3683 0104 1360     		str	r3, [r2]
  76:rt-thread/include/rtservice.h **** 
 3684              		.loc 2 76 0
 3685 0106 6A68     		ldr	r2, [r5, #4]
 3686 0108 A261     		str	r2, [r4, #24]
  78:rt-thread/include/rtservice.h ****     n->next = l;
 3687              		.loc 2 78 0
 3688 010a 6B60     		str	r3, [r5, #4]
  79:rt-thread/include/rtservice.h **** }
 3689              		.loc 2 79 0
 3690 010c 6561     		str	r5, [r4, #20]
 3691 010e A6E7     		b	.L256
 3692              	.LVL510:
 3693              	.L274:
 3694              	.LBE328:
 3695              	.LBE327:
 3696              	.LBE324:
 3697              	.LBE329:
 3698              	.LBE330:
2335:rt-thread/src/ipc.c ****         }
 3699              		.loc 1 2335 0
 3700 0110 0023     		movs	r3, #0
 3701 0112 0193     		str	r3, [sp, #4]
 3702 0114 C9E7     		b	.L253
 3703              	.LVL511:
 3704              	.L269:
 3705 0116 0027     		movs	r7, #0
 3706 0118 C7E7     		b	.L253
 3707              	.LVL512:
 3708              	.L275:
2340:rt-thread/src/ipc.c **** 
 3709              		.loc 1 2340 0
 3710 011a B46A     		ldr	r4, [r6, #40]
 3711              	.LVL513:
2343:rt-thread/src/ipc.c ****     /* reach queue tail, set to NULL */
 3712              		.loc 1 2343 0
 3713 011c 2268     		ldr	r2, [r4]
 3714 011e B262     		str	r2, [r6, #40]
2345:rt-thread/src/ipc.c ****         mq->msg_queue_tail = RT_NULL;
 3715              		.loc 1 2345 0
 3716 0120 F26A     		ldr	r2, [r6, #44]
 3717 0122 9442     		cmp	r4, r2
 3718 0124 26D0     		beq	.L278
 3719              	.L266:
2349:rt-thread/src/ipc.c **** 
 3720              		.loc 1 2349 0
 3721 0126 013B     		subs	r3, r3, #1
 3722 0128 B384     		strh	r3, [r6, #36]	@ movhi
2352:rt-thread/src/ipc.c **** 
 3723              		.loc 1 2352 0
 3724 012a 4046     		mov	r0, r8
 3725 012c FFF7FEFF 		bl	rt_hw_interrupt_enable
 3726              	.LVL514:
2355:rt-thread/src/ipc.c **** 
 3727              		.loc 1 2355 0
 3728 0130 328C     		ldrh	r2, [r6, #32]
ARM GAS  /tmp/ccOtHhPO.s 			page 115


 3729 0132 5245     		cmp	r2, r10
 3730 0134 28BF     		it	cs
 3731 0136 5246     		movcs	r2, r10
 3732 0138 211D     		adds	r1, r4, #4
 3733 013a 4846     		mov	r0, r9
 3734 013c FFF7FEFF 		bl	rt_memcpy
 3735              	.LVL515:
2358:rt-thread/src/ipc.c ****     /* put message to free list */
 3736              		.loc 1 2358 0
 3737 0140 FFF7FEFF 		bl	rt_hw_interrupt_disable
 3738              	.LVL516:
 3739 0144 0546     		mov	r5, r0
 3740              	.LVL517:
2360:rt-thread/src/ipc.c ****     mq->msg_queue_free = msg;
 3741              		.loc 1 2360 0
 3742 0146 336B     		ldr	r3, [r6, #48]
 3743 0148 2360     		str	r3, [r4]
2361:rt-thread/src/ipc.c **** 
 3744              		.loc 1 2361 0
 3745 014a 3463     		str	r4, [r6, #48]
2364:rt-thread/src/ipc.c ****     {
 3746              		.loc 1 2364 0
 3747 014c 06F13403 		add	r3, r6, #52
 3748              	.LBB331:
 3749              	.LBB332:
 3750              		.loc 2 100 0
 3751 0150 706B     		ldr	r0, [r6, #52]
 3752              	.LVL518:
 3753              	.LBE332:
 3754              	.LBE331:
2364:rt-thread/src/ipc.c ****     {
 3755              		.loc 1 2364 0
 3756 0152 8342     		cmp	r3, r0
 3757 0154 11D0     		beq	.L267
 3758              	.LVL519:
 3759              	.LBB333:
 3760              	.LBB334:
 144:rt-thread/src/ipc.c **** 
 3761              		.loc 1 144 0
 3762 0156 1438     		subs	r0, r0, #20
 3763              	.LVL520:
 3764 0158 FFF7FEFF 		bl	rt_thread_resume
 3765              	.LVL521:
 3766              	.LBE334:
 3767              	.LBE333:
2369:rt-thread/src/ipc.c **** 
 3768              		.loc 1 2369 0
 3769 015c 2846     		mov	r0, r5
 3770 015e FFF7FEFF 		bl	rt_hw_interrupt_enable
 3771              	.LVL522:
2371:rt-thread/src/ipc.c **** 
 3772              		.loc 1 2371 0
 3773 0162 0D4B     		ldr	r3, .L279+4
 3774 0164 1B68     		ldr	r3, [r3]
 3775 0166 0BB1     		cbz	r3, .L268
2371:rt-thread/src/ipc.c **** 
 3776              		.loc 1 2371 0 is_stmt 0 discriminator 1
ARM GAS  /tmp/ccOtHhPO.s 			page 116


 3777 0168 3046     		mov	r0, r6
 3778 016a 9847     		blx	r3
 3779              	.LVL523:
 3780              	.L268:
2373:rt-thread/src/ipc.c **** 
 3781              		.loc 1 2373 0 is_stmt 1
 3782 016c FFF7FEFF 		bl	rt_schedule
 3783              	.LVL524:
2375:rt-thread/src/ipc.c ****     }
 3784              		.loc 1 2375 0
 3785 0170 0020     		movs	r0, #0
 3786 0172 69E7     		b	.L251
 3787              	.LVL525:
 3788              	.L278:
2346:rt-thread/src/ipc.c **** 
 3789              		.loc 1 2346 0
 3790 0174 0022     		movs	r2, #0
 3791 0176 F262     		str	r2, [r6, #44]
 3792 0178 D5E7     		b	.L266
 3793              	.LVL526:
 3794              	.L267:
2379:rt-thread/src/ipc.c **** 
 3795              		.loc 1 2379 0
 3796 017a 2846     		mov	r0, r5
 3797 017c FFF7FEFF 		bl	rt_hw_interrupt_enable
 3798              	.LVL527:
2381:rt-thread/src/ipc.c **** 
 3799              		.loc 1 2381 0
 3800 0180 054B     		ldr	r3, .L279+4
 3801 0182 1B68     		ldr	r3, [r3]
 3802 0184 1BB1     		cbz	r3, .L271
2381:rt-thread/src/ipc.c **** 
 3803              		.loc 1 2381 0 is_stmt 0 discriminator 1
 3804 0186 3046     		mov	r0, r6
 3805 0188 9847     		blx	r3
 3806              	.LVL528:
2383:rt-thread/src/ipc.c **** }
 3807              		.loc 1 2383 0 is_stmt 1 discriminator 1
 3808 018a 0020     		movs	r0, #0
 3809 018c 5CE7     		b	.L251
 3810              	.L271:
2383:rt-thread/src/ipc.c **** }
 3811              		.loc 1 2383 0 is_stmt 0
 3812 018e 0020     		movs	r0, #0
 3813 0190 5AE7     		b	.L251
 3814              	.L280:
 3815 0192 00BF     		.align	2
 3816              	.L279:
 3817 0194 00000000 		.word	rt_object_trytake_hook
 3818 0198 00000000 		.word	rt_object_take_hook
 3819              		.cfi_endproc
 3820              	.LFE48:
 3822              		.section	.text.rt_mq_control,"ax",%progbits
 3823              		.align	1
 3824              		.global	rt_mq_control
 3825              		.syntax unified
 3826              		.thumb
ARM GAS  /tmp/ccOtHhPO.s 			page 117


 3827              		.thumb_func
 3828              		.fpu fpv4-sp-d16
 3830              	rt_mq_control:
 3831              	.LFB49:
2385:rt-thread/src/ipc.c **** RTM_EXPORT(rt_mq_recv);
2386:rt-thread/src/ipc.c **** 
2387:rt-thread/src/ipc.c **** /**
2388:rt-thread/src/ipc.c ****  * This function can get or set some extra attributions of a message queue
2389:rt-thread/src/ipc.c ****  * object.
2390:rt-thread/src/ipc.c ****  *
2391:rt-thread/src/ipc.c ****  * @param mq the message queue object
2392:rt-thread/src/ipc.c ****  * @param cmd the execution command
2393:rt-thread/src/ipc.c ****  * @param arg the execution argument
2394:rt-thread/src/ipc.c ****  *
2395:rt-thread/src/ipc.c ****  * @return the error code
2396:rt-thread/src/ipc.c ****  */
2397:rt-thread/src/ipc.c **** rt_err_t rt_mq_control(rt_mq_t mq, int cmd, void *arg)
2398:rt-thread/src/ipc.c **** {
 3832              		.loc 1 2398 0 is_stmt 1
 3833              		.cfi_startproc
 3834              		@ args = 0, pretend = 0, frame = 0
 3835              		@ frame_needed = 0, uses_anonymous_args = 0
 3836              	.LVL529:
2399:rt-thread/src/ipc.c ****     rt_ubase_t level;
2400:rt-thread/src/ipc.c ****     struct rt_mq_message *msg;
2401:rt-thread/src/ipc.c **** 
2402:rt-thread/src/ipc.c ****     /* parameter check */
2403:rt-thread/src/ipc.c ****     RT_ASSERT(mq != RT_NULL);
2404:rt-thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mq->parent.parent) == RT_Object_Class_MessageQueue);
2405:rt-thread/src/ipc.c **** 
2406:rt-thread/src/ipc.c ****     if (cmd == RT_IPC_CMD_RESET)
 3837              		.loc 1 2406 0
 3838 0000 0129     		cmp	r1, #1
 3839 0002 41D1     		bne	.L290
2398:rt-thread/src/ipc.c ****     rt_ubase_t level;
 3840              		.loc 1 2398 0
 3841 0004 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3842              	.LCFI48:
 3843              		.cfi_def_cfa_offset 24
 3844              		.cfi_offset 3, -24
 3845              		.cfi_offset 4, -20
 3846              		.cfi_offset 5, -16
 3847              		.cfi_offset 6, -12
 3848              		.cfi_offset 7, -8
 3849              		.cfi_offset 14, -4
 3850 0006 0446     		mov	r4, r0
2407:rt-thread/src/ipc.c ****     {
2408:rt-thread/src/ipc.c ****         /* disable interrupt */
2409:rt-thread/src/ipc.c ****         level = rt_hw_interrupt_disable();
 3851              		.loc 1 2409 0
 3852 0008 FFF7FEFF 		bl	rt_hw_interrupt_disable
 3853              	.LVL530:
 3854 000c 0646     		mov	r6, r0
 3855              	.LVL531:
2410:rt-thread/src/ipc.c **** 
2411:rt-thread/src/ipc.c ****         /* resume all waiting thread */
2412:rt-thread/src/ipc.c ****         rt_ipc_list_resume_all(&mq->parent.suspend_thread);
ARM GAS  /tmp/ccOtHhPO.s 			page 118


 3856              		.loc 1 2412 0
 3857 000e 04F11405 		add	r5, r4, #20
 3858              	.LVL532:
 3859 0012 0CE0     		b	.L283
 3860              	.LVL533:
 3861              	.L284:
 3862              	.LBB343:
 3863              	.LBB344:
 166:rt-thread/src/ipc.c **** 
 3864              		.loc 1 166 0
 3865 0014 FFF7FEFF 		bl	rt_hw_interrupt_disable
 3866              	.LVL534:
 3867 0018 0746     		mov	r7, r0
 3868              	.LVL535:
 169:rt-thread/src/ipc.c ****         /* set error code to RT_ERROR */
 3869              		.loc 1 169 0
 3870 001a 2868     		ldr	r0, [r5]
 3871              	.LVL536:
 171:rt-thread/src/ipc.c **** 
 3872              		.loc 1 171 0
 3873 001c 4FF0FF33 		mov	r3, #-1
 3874 0020 C361     		str	r3, [r0, #28]
 178:rt-thread/src/ipc.c **** 
 3875              		.loc 1 178 0
 3876 0022 1438     		subs	r0, r0, #20
 3877              	.LVL537:
 3878 0024 FFF7FEFF 		bl	rt_thread_resume
 3879              	.LVL538:
 181:rt-thread/src/ipc.c ****     }
 3880              		.loc 1 181 0
 3881 0028 3846     		mov	r0, r7
 3882 002a FFF7FEFF 		bl	rt_hw_interrupt_enable
 3883              	.LVL539:
 3884              	.L283:
 3885              	.LBB345:
 3886              	.LBB346:
 3887              		.loc 2 100 0
 3888 002e 2B68     		ldr	r3, [r5]
 3889              	.LVL540:
 3890              	.LBE346:
 3891              	.LBE345:
 163:rt-thread/src/ipc.c ****     {
 3892              		.loc 1 163 0
 3893 0030 9D42     		cmp	r5, r3
 3894 0032 EFD1     		bne	.L284
 3895              	.LVL541:
 3896              	.LBE344:
 3897              	.LBE343:
2413:rt-thread/src/ipc.c ****         /* also resume all message queue private suspended thread */
2414:rt-thread/src/ipc.c ****         rt_ipc_list_resume_all(&(mq->suspend_sender_thread));
 3898              		.loc 1 2414 0
 3899 0034 04F13405 		add	r5, r4, #52
 3900              	.LVL542:
 3901 0038 0CE0     		b	.L285
 3902              	.L286:
 3903              	.LBB347:
 3904              	.LBB348:
ARM GAS  /tmp/ccOtHhPO.s 			page 119


 166:rt-thread/src/ipc.c **** 
 3905              		.loc 1 166 0
 3906 003a FFF7FEFF 		bl	rt_hw_interrupt_disable
 3907              	.LVL543:
 3908 003e 0746     		mov	r7, r0
 3909              	.LVL544:
 169:rt-thread/src/ipc.c ****         /* set error code to RT_ERROR */
 3910              		.loc 1 169 0
 3911 0040 2868     		ldr	r0, [r5]
 3912              	.LVL545:
 171:rt-thread/src/ipc.c **** 
 3913              		.loc 1 171 0
 3914 0042 4FF0FF33 		mov	r3, #-1
 3915 0046 C361     		str	r3, [r0, #28]
 178:rt-thread/src/ipc.c **** 
 3916              		.loc 1 178 0
 3917 0048 1438     		subs	r0, r0, #20
 3918              	.LVL546:
 3919 004a FFF7FEFF 		bl	rt_thread_resume
 3920              	.LVL547:
 181:rt-thread/src/ipc.c ****     }
 3921              		.loc 1 181 0
 3922 004e 3846     		mov	r0, r7
 3923 0050 FFF7FEFF 		bl	rt_hw_interrupt_enable
 3924              	.LVL548:
 3925              	.L285:
 3926              	.LBB349:
 3927              	.LBB350:
 3928              		.loc 2 100 0
 3929 0054 2B68     		ldr	r3, [r5]
 3930              	.LVL549:
 3931              	.LBE350:
 3932              	.LBE349:
 163:rt-thread/src/ipc.c ****     {
 3933              		.loc 1 163 0
 3934 0056 9D42     		cmp	r5, r3
 3935 0058 EFD1     		bne	.L286
 3936 005a 02E0     		b	.L287
 3937              	.LVL550:
 3938              	.L288:
 3939              	.LBE348:
 3940              	.LBE347:
2415:rt-thread/src/ipc.c **** 
2416:rt-thread/src/ipc.c ****         /* release all message in the queue */
2417:rt-thread/src/ipc.c ****         while (mq->msg_queue_head != RT_NULL)
2418:rt-thread/src/ipc.c ****         {
2419:rt-thread/src/ipc.c ****             /* get message from queue */
2420:rt-thread/src/ipc.c ****             msg = (struct rt_mq_message *)mq->msg_queue_head;
2421:rt-thread/src/ipc.c **** 
2422:rt-thread/src/ipc.c ****             /* move message queue head */
2423:rt-thread/src/ipc.c ****             mq->msg_queue_head = msg->next;
2424:rt-thread/src/ipc.c ****             /* reach queue tail, set to NULL */
2425:rt-thread/src/ipc.c ****             if (mq->msg_queue_tail == msg)
2426:rt-thread/src/ipc.c ****                 mq->msg_queue_tail = RT_NULL;
2427:rt-thread/src/ipc.c **** 
2428:rt-thread/src/ipc.c ****             /* put message to free list */
2429:rt-thread/src/ipc.c ****             msg->next = (struct rt_mq_message *)mq->msg_queue_free;
ARM GAS  /tmp/ccOtHhPO.s 			page 120


 3941              		.loc 1 2429 0
 3942 005c 226B     		ldr	r2, [r4, #48]
 3943 005e 1A60     		str	r2, [r3]
2430:rt-thread/src/ipc.c ****             mq->msg_queue_free = msg;
 3944              		.loc 1 2430 0
 3945 0060 2363     		str	r3, [r4, #48]
 3946              	.LVL551:
 3947              	.L287:
2417:rt-thread/src/ipc.c ****         {
 3948              		.loc 1 2417 0
 3949 0062 A36A     		ldr	r3, [r4, #40]
 3950 0064 3BB1     		cbz	r3, .L295
 3951              	.LVL552:
2423:rt-thread/src/ipc.c ****             /* reach queue tail, set to NULL */
 3952              		.loc 1 2423 0
 3953 0066 1A68     		ldr	r2, [r3]
 3954 0068 A262     		str	r2, [r4, #40]
2425:rt-thread/src/ipc.c ****                 mq->msg_queue_tail = RT_NULL;
 3955              		.loc 1 2425 0
 3956 006a E26A     		ldr	r2, [r4, #44]
 3957 006c 9342     		cmp	r3, r2
 3958 006e F5D1     		bne	.L288
2426:rt-thread/src/ipc.c **** 
 3959              		.loc 1 2426 0
 3960 0070 0022     		movs	r2, #0
 3961 0072 E262     		str	r2, [r4, #44]
 3962 0074 F2E7     		b	.L288
 3963              	.LVL553:
 3964              	.L295:
2431:rt-thread/src/ipc.c ****         }
2432:rt-thread/src/ipc.c **** 
2433:rt-thread/src/ipc.c ****         /* clean entry */
2434:rt-thread/src/ipc.c ****         mq->entry = 0;
 3965              		.loc 1 2434 0
 3966 0076 0025     		movs	r5, #0
 3967              	.LVL554:
 3968 0078 A584     		strh	r5, [r4, #36]	@ movhi
2435:rt-thread/src/ipc.c **** 
2436:rt-thread/src/ipc.c ****         /* enable interrupt */
2437:rt-thread/src/ipc.c ****         rt_hw_interrupt_enable(level);
 3969              		.loc 1 2437 0
 3970 007a 3046     		mov	r0, r6
 3971 007c FFF7FEFF 		bl	rt_hw_interrupt_enable
 3972              	.LVL555:
2438:rt-thread/src/ipc.c **** 
2439:rt-thread/src/ipc.c ****         rt_schedule();
 3973              		.loc 1 2439 0
 3974 0080 FFF7FEFF 		bl	rt_schedule
 3975              	.LVL556:
2440:rt-thread/src/ipc.c **** 
2441:rt-thread/src/ipc.c ****         return RT_EOK;
 3976              		.loc 1 2441 0
 3977 0084 2846     		mov	r0, r5
 3978 0086 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3979              	.LVL557:
 3980              	.L290:
 3981              	.LCFI49:
ARM GAS  /tmp/ccOtHhPO.s 			page 121


 3982              		.cfi_def_cfa_offset 0
 3983              		.cfi_restore 3
 3984              		.cfi_restore 4
 3985              		.cfi_restore 5
 3986              		.cfi_restore 6
 3987              		.cfi_restore 7
 3988              		.cfi_restore 14
2442:rt-thread/src/ipc.c ****     }
2443:rt-thread/src/ipc.c **** 
2444:rt-thread/src/ipc.c ****     return -RT_ERROR;
 3989              		.loc 1 2444 0
 3990 0088 4FF0FF30 		mov	r0, #-1
 3991              	.LVL558:
 3992 008c 7047     		bx	lr
 3993              		.cfi_endproc
 3994              	.LFE49:
 3996              		.text
 3997              	.Letext0:
 3998              		.file 3 "rt-thread/include/rtdef.h"
 3999              		.file 4 "/opt/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/lock.h"
 4000              		.file 5 "/opt/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_types.h"
 4001              		.file 6 "/opt/gcc-arm-none-eabi-6-2017-q2-update/lib/gcc/arm-none-eabi/6.3.1/include/stddef.h"
 4002              		.file 7 "/opt/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/reent.h"
 4003              		.file 8 "/opt/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/time.h"
 4004              		.file 9 "/opt/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/errno.h"
 4005              		.file 10 "rt-thread/components/finsh/finsh_api.h"
 4006              		.file 11 "rt-thread/include/rthw.h"
 4007              		.file 12 "rt-thread/include/rtthread.h"
ARM GAS  /tmp/ccOtHhPO.s 			page 122


DEFINED SYMBOLS
                            *ABS*:0000000000000000 ipc.c
     /tmp/ccOtHhPO.s:18     .text.rt_sem_init:0000000000000000 $t
     /tmp/ccOtHhPO.s:25     .text.rt_sem_init:0000000000000000 rt_sem_init
     /tmp/ccOtHhPO.s:77     .text.rt_sem_detach:0000000000000000 $t
     /tmp/ccOtHhPO.s:84     .text.rt_sem_detach:0000000000000000 rt_sem_detach
     /tmp/ccOtHhPO.s:152    .text.rt_sem_create:0000000000000000 $t
     /tmp/ccOtHhPO.s:159    .text.rt_sem_create:0000000000000000 rt_sem_create
     /tmp/ccOtHhPO.s:214    .text.rt_sem_delete:0000000000000000 $t
     /tmp/ccOtHhPO.s:221    .text.rt_sem_delete:0000000000000000 rt_sem_delete
     /tmp/ccOtHhPO.s:289    .text.rt_sem_take:0000000000000000 $t
     /tmp/ccOtHhPO.s:296    .text.rt_sem_take:0000000000000000 rt_sem_take
     /tmp/ccOtHhPO.s:522    .text.rt_sem_take:00000000000000e4 $d
     /tmp/ccOtHhPO.s:528    .text.rt_sem_trytake:0000000000000000 $t
     /tmp/ccOtHhPO.s:535    .text.rt_sem_trytake:0000000000000000 rt_sem_trytake
     /tmp/ccOtHhPO.s:557    .text.rt_sem_release:0000000000000000 $t
     /tmp/ccOtHhPO.s:564    .text.rt_sem_release:0000000000000000 rt_sem_release
     /tmp/ccOtHhPO.s:647    .text.rt_sem_release:0000000000000040 $d
     /tmp/ccOtHhPO.s:652    .text.rt_sem_control:0000000000000000 $t
     /tmp/ccOtHhPO.s:659    .text.rt_sem_control:0000000000000000 rt_sem_control
     /tmp/ccOtHhPO.s:761    .text.rt_mutex_init:0000000000000000 $t
     /tmp/ccOtHhPO.s:768    .text.rt_mutex_init:0000000000000000 rt_mutex_init
     /tmp/ccOtHhPO.s:825    .text.rt_mutex_detach:0000000000000000 $t
     /tmp/ccOtHhPO.s:832    .text.rt_mutex_detach:0000000000000000 rt_mutex_detach
     /tmp/ccOtHhPO.s:900    .text.rt_mutex_create:0000000000000000 $t
     /tmp/ccOtHhPO.s:907    .text.rt_mutex_create:0000000000000000 rt_mutex_create
     /tmp/ccOtHhPO.s:968    .text.rt_mutex_delete:0000000000000000 $t
     /tmp/ccOtHhPO.s:975    .text.rt_mutex_delete:0000000000000000 rt_mutex_delete
     /tmp/ccOtHhPO.s:1043   .text.rt_mutex_take:0000000000000000 $t
     /tmp/ccOtHhPO.s:1050   .text.rt_mutex_take:0000000000000000 rt_mutex_take
     /tmp/ccOtHhPO.s:1325   .text.rt_mutex_take:0000000000000130 $d
     /tmp/ccOtHhPO.s:1331   .text.rt_mutex_release:0000000000000000 $t
     /tmp/ccOtHhPO.s:1338   .text.rt_mutex_release:0000000000000000 rt_mutex_release
     /tmp/ccOtHhPO.s:1487   .text.rt_mutex_release:000000000000009c $d
     /tmp/ccOtHhPO.s:1492   .text.rt_mutex_control:0000000000000000 $t
     /tmp/ccOtHhPO.s:1499   .text.rt_mutex_control:0000000000000000 rt_mutex_control
     /tmp/ccOtHhPO.s:1515   .text.rt_event_init:0000000000000000 $t
     /tmp/ccOtHhPO.s:1522   .text.rt_event_init:0000000000000000 rt_event_init
     /tmp/ccOtHhPO.s:1572   .text.rt_event_detach:0000000000000000 $t
     /tmp/ccOtHhPO.s:1579   .text.rt_event_detach:0000000000000000 rt_event_detach
     /tmp/ccOtHhPO.s:1647   .text.rt_event_create:0000000000000000 $t
     /tmp/ccOtHhPO.s:1654   .text.rt_event_create:0000000000000000 rt_event_create
     /tmp/ccOtHhPO.s:1707   .text.rt_event_delete:0000000000000000 $t
     /tmp/ccOtHhPO.s:1714   .text.rt_event_delete:0000000000000000 rt_event_delete
     /tmp/ccOtHhPO.s:1782   .text.rt_event_send:0000000000000000 $t
     /tmp/ccOtHhPO.s:1789   .text.rt_event_send:0000000000000000 rt_event_send
     /tmp/ccOtHhPO.s:1961   .text.rt_event_send:00000000000000b4 $d
     /tmp/ccOtHhPO.s:1966   .text.rt_event_recv:0000000000000000 $t
     /tmp/ccOtHhPO.s:1973   .text.rt_event_recv:0000000000000000 rt_event_recv
     /tmp/ccOtHhPO.s:2274   .text.rt_event_recv:0000000000000154 $d
     /tmp/ccOtHhPO.s:2280   .text.rt_event_control:0000000000000000 $t
     /tmp/ccOtHhPO.s:2287   .text.rt_event_control:0000000000000000 rt_event_control
     /tmp/ccOtHhPO.s:2386   .text.rt_mq_init:0000000000000000 $t
     /tmp/ccOtHhPO.s:2393   .text.rt_mq_init:0000000000000000 rt_mq_init
     /tmp/ccOtHhPO.s:2503   .text.rt_mq_detach:0000000000000000 $t
     /tmp/ccOtHhPO.s:2510   .text.rt_mq_detach:0000000000000000 rt_mq_detach
     /tmp/ccOtHhPO.s:2619   .text.rt_mq_create:0000000000000000 $t
ARM GAS  /tmp/ccOtHhPO.s 			page 123


     /tmp/ccOtHhPO.s:2626   .text.rt_mq_create:0000000000000000 rt_mq_create
     /tmp/ccOtHhPO.s:2758   .text.rt_mq_delete:0000000000000000 $t
     /tmp/ccOtHhPO.s:2765   .text.rt_mq_delete:0000000000000000 rt_mq_delete
     /tmp/ccOtHhPO.s:2878   .text.rt_mq_send_wait:0000000000000000 $t
     /tmp/ccOtHhPO.s:2885   .text.rt_mq_send_wait:0000000000000000 rt_mq_send_wait
     /tmp/ccOtHhPO.s:3249   .text.rt_mq_send_wait:0000000000000184 $d
     /tmp/ccOtHhPO.s:3254   .text.rt_mq_send:0000000000000000 $t
     /tmp/ccOtHhPO.s:3261   .text.rt_mq_send:0000000000000000 rt_mq_send
     /tmp/ccOtHhPO.s:3283   .text.rt_mq_urgent:0000000000000000 $t
     /tmp/ccOtHhPO.s:3290   .text.rt_mq_urgent:0000000000000000 rt_mq_urgent
     /tmp/ccOtHhPO.s:3433   .text.rt_mq_urgent:0000000000000090 $d
     /tmp/ccOtHhPO.s:3438   .text.rt_mq_recv:0000000000000000 $t
     /tmp/ccOtHhPO.s:3445   .text.rt_mq_recv:0000000000000000 rt_mq_recv
     /tmp/ccOtHhPO.s:3817   .text.rt_mq_recv:0000000000000194 $d
     /tmp/ccOtHhPO.s:3823   .text.rt_mq_control:0000000000000000 $t
     /tmp/ccOtHhPO.s:3830   .text.rt_mq_control:0000000000000000 rt_mq_control
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
rt_object_init
rt_hw_interrupt_disable
rt_thread_resume
rt_hw_interrupt_enable
rt_object_detach
rt_object_allocate
rt_object_delete
rt_thread_self
rt_thread_suspend
rt_timer_control
rt_timer_start
rt_schedule
rt_object_trytake_hook
rt_object_take_hook
rt_object_put_hook
rt_thread_control
rt_malloc
rt_free
rt_tick_get
rt_memcpy
